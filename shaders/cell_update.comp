#version 430

// Local work group size
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// SSBOs: Structure of Arrays
layout(std430, binding = 0) buffer Positions {
    vec4 positions[]; // xyz = position, w = radius
};
layout(std430, binding = 1) buffer Velocities {
    vec4 velocities[]; // xyz = velocity, w = mass
};
layout(std430, binding = 2) buffer Accelerations {
    vec4 accelerations[]; // xyz = acceleration, w = unused
};

// Uniforms
uniform float u_deltaTime;
uniform int u_cellCount;
uniform float u_damping;
uniform int u_draggedCellIndex; // Index of cell being dragged (-1 if none)

void main() {
    uint index = gl_GlobalInvocationID.x;

    if (index >= uint(u_cellCount)) return;
    if (int(index) == u_draggedCellIndex) return;

    // Update velocity based on acceleration
    velocities[index].xyz += accelerations[index].xyz * u_deltaTime;

    // Apply damping
    velocities[index].xyz *= u_damping;

    // Update position based on velocity
    positions[index].xyz += velocities[index].xyz * u_deltaTime;

    // Boundary constraints (bounce off edges)
    vec3 pos = positions[index].xyz;
    float bounds = 50.0;

    if (abs(pos.x) > bounds) {
        positions[index].x = sign(pos.x) * bounds;
        velocities[index].x *= -0.8;
    }
    if (abs(pos.y) > bounds) {
        positions[index].y = sign(pos.y) * bounds;
        velocities[index].y *= -0.8;
    }
    if (abs(pos.z) > bounds) {
        positions[index].z = sign(pos.z) * bounds;
        velocities[index].z *= -0.8;
    }
}
