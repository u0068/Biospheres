#version 460 core

layout(local_size_x = 256) in;

// Voxel data structure (16³ grid)
struct VoxelData
{
    vec4 nutrientDensity;
    vec4 positionAndSize;
    vec4 colorAndAlpha;
    float lifetime;
    float maxLifetime;
    uint isActive;
    uint _padding;
};

// Particle data: xyz = position, w = nutrient density
struct ParticleData
{
    vec4 data; // xyz = position, w = total nutrient
};

layout(std430, binding = 0) readonly buffer VoxelBuffer
{
    VoxelData voxels[];
};

layout(std430, binding = 1) writeonly buffer ParticleBuffer
{
    ParticleData particles[];
};

layout(binding = 0, offset = 0) uniform atomic_uint particleCounter;

// Fast hash function for procedural randomness
float hash(vec3 p)
{
    p = fract(p * vec3(0.1031, 0.1030, 0.0973));
    p += dot(p, p.yzx + 33.33);
    return fract((p.x + p.y) * p.z);
}

// Generate 3D random offset
vec3 randomOffset(vec3 seed)
{
    float x = hash(seed) * 2.0 - 1.0;
    float y = hash(seed + vec3(12.9898, 78.233, 37.719)) * 2.0 - 1.0;
    float z = hash(seed + vec3(93.989, 17.259, 63.521)) * 2.0 - 1.0;
    return vec3(x, y, z);
}

uniform int u_voxelResolution;  // 16 for voxel grid
uniform float u_worldSize;
uniform float u_particleJitter; // Random offset amount (0-2+)
uniform float u_time;           // Current time for animated jitter

void main()
{
    uint voxelIdx = gl_GlobalInvocationID.x;
    
    // Don't process beyond max voxels
    uint totalVoxels = uint(u_voxelResolution * u_voxelResolution * u_voxelResolution);
    if (voxelIdx >= totalVoxels)
        return;
    
    VoxelData voxel = voxels[voxelIdx];
    
    // Skip inactive voxels
    if (voxel.isActive == 0)
        return;
    
    // Calculate total nutrient density
    float totalNutrient = voxel.nutrientDensity.r + voxel.nutrientDensity.g + 
                          voxel.nutrientDensity.b + voxel.nutrientDensity.a;
    
    // Generate particles even at very low densities to allow smooth fade-in/out
    // The fragment shader will handle fading based on density
    if (totalNutrient < 0.0001)
        return;
    
    // Convert voxel index to voxel coordinate (16³)
    int voxelZ = int(voxelIdx) / (u_voxelResolution * u_voxelResolution);
    int voxelY = (int(voxelIdx) / u_voxelResolution) % u_voxelResolution;
    int voxelX = int(voxelIdx) % u_voxelResolution;
    
    // Generate ONE particle per voxel (16³ instead of 64³)
    // This is 64x fewer particles and much faster
    float voxelCellSize = u_worldSize / float(u_voxelResolution);
    float halfWorld = u_worldSize * 0.5;
    
    // Calculate voxel center position
    vec3 voxelCenter = vec3(
        -halfWorld + (float(voxelX) + 0.5) * voxelCellSize,
        -halfWorld + (float(voxelY) + 0.5) * voxelCellSize,
        -halfWorld + (float(voxelZ) + 0.5) * voxelCellSize
    );
    
    // Apply random jitter if enabled
    if (u_particleJitter > 0.0)
    {
        vec3 seed = vec3(float(voxelX), float(voxelY), float(voxelZ));
        // u_particleJitter scales from 0 (no offset) to 2+ (full voxel size or more)
        vec3 offset = randomOffset(seed) * voxelCellSize * u_particleJitter * 0.5;
        voxelCenter += offset;
    }
    
    // Add particle
    uint particleIdx = atomicCounterIncrement(particleCounter);
    
    // Safety check for buffer overflow (now only need 16³ = 4096 max)
    uint maxParticles = uint(u_voxelResolution * u_voxelResolution * u_voxelResolution);
    if (particleIdx < maxParticles)
    {
        particles[particleIdx].data = vec4(voxelCenter, totalNutrient);
    }
}
