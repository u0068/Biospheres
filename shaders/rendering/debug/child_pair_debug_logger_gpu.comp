#version 430 core
#extension GL_ARB_gpu_shader_int64 : enable

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Cell data structure matching the one in the main simulation
struct ComputeCell {
    vec4 positionAndMass; // x, y, z, mass
    vec4 velocity;        // Fixed to match CPU layout
    vec4 acceleration;    // Fixed to match CPU layout
    vec4 orientation;     // quaternion: w, x, y, z
    vec4 angularVelocity;
    vec4 angularAcceleration;
    vec4 signallingSubstances;
    int modeIndex;
    float age;
    float toxins;
    float nitrates;
    // Unique ID system
    uint64_t uniqueID;     // Packed ID: [parent(32)] [cell(31)] [child(1)]
    uint64_t padding1;     // Padding to maintain alignment
    uint padding2[4];    // Additional padding to ensure 16-byte alignment
};

// Parent-children mapping structure
struct ParentChildren {
    uint childAIndex;
    uint childBIndex;
    uint isActive;
    uint padding;
};

// Debug structure to store child pair information
struct ChildPairDebugInfo {
    uint parentID;        // Parent ID
    uint childAIndex;     // Index of child A (child flag = 0)
    uint childBIndex;     // Index of child B (child flag = 1)
    uint64_t childAUniqueID;  // Unique ID of child A
    uint64_t childBUniqueID;  // Unique ID of child B
    vec4 childAPosition;  // Position of child A
    vec4 childBPosition;  // Position of child B
    float distance;       // Distance between children
    uint isValid;         // Whether this pair is valid
    uint padding[2];      // Padding for alignment
};

// Input: Cell data
layout(std430, binding = 0) buffer CellBuffer {
    ComputeCell cells[];
};

// Input: Parent-children mapping (GPU-only, no CPU sync needed)
layout(std430, binding = 1) buffer ParentChildrenBuffer {
    ParentChildren parentChildrenTable[];
};

// Output: Debug buffer for child pairs
layout(std430, binding = 2) buffer ChildPairDebugBuffer {
    ChildPairDebugInfo debugPairs[];
};

// Counter buffer for atomic operations
layout(std430, binding = 3) buffer CounterBuffer {
    uint pairCount;
    uint padding[3]; // Padding to maintain alignment
};

// Cell count
layout(std430, binding = 4) buffer CellCountBuffer {
    uint cellCount;
    uint pendingCellCount;
};

// Extract parent ID from unique ID
uint getParentID(uint64_t uniqueID) {
    return uint((uniqueID >> 32) & 0xFFFFFFFF);
}

// Extract child flag from unique ID (0 = child A, 1 = child B)
uint getChildFlag(uint64_t uniqueID) {
    return uint(uniqueID & 0x1);
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    if (index >= cellCount) {
        return;
    }
    
    ComputeCell currentCell = cells[index];
    
    // Skip cells with no parent (initial spawned cells)
    uint parentID = getParentID(currentCell.uniqueID);
    if (parentID == 0) {
        return;
    }
    
    // Only process child A (child flag = 0) to avoid duplicate processing
    uint childFlag = getChildFlag(currentCell.uniqueID);
    if (childFlag != 0) {
        return; // Skip child B
    }
    
    // O(1) lookup using the parent-children buffer!
    ParentChildren parentEntry = parentChildrenTable[parentID];
    
    // Check if this parent has both children
    if (parentEntry.isActive == 0 || parentEntry.childAIndex == 0xFFFFFFFF || parentEntry.childBIndex == 0xFFFFFFFF) {
        return; // No complete pair
    }
    
    // Verify we're the child A for this parent
    if (parentEntry.childAIndex != index) {
        return; // Not our parent
    }
    
    // Get child B data
    uint childBIndex = parentEntry.childBIndex;
    if (childBIndex >= cellCount) {
        return; // Invalid index
    }
    
    ComputeCell childBCell = cells[childBIndex];
    
    // Verify child B has the same parent
    uint childBParentID = getParentID(childBCell.uniqueID);
    if (childBParentID != parentID) {
        return; // Invalid parent-child relationship
    }
    
    // Use atomic operation to get a unique debug entry
    uint debugIndex = atomicAdd(pairCount, 1);
    
    // Ensure we don't exceed the maximum debug entries
    if (debugIndex >= debugPairs.length()) {
        return;
    }
    
    // Calculate distance between children
    vec3 childAPos = currentCell.positionAndMass.xyz;
    vec3 childBPos = childBCell.positionAndMass.xyz;
    float distance = length(childAPos - childBPos);
    
    // Store the debug information
    debugPairs[debugIndex].parentID = parentID;
    debugPairs[debugIndex].childAIndex = index;
    debugPairs[debugIndex].childBIndex = childBIndex;
    debugPairs[debugIndex].childAUniqueID = currentCell.uniqueID;
    debugPairs[debugIndex].childBUniqueID = childBCell.uniqueID;
    debugPairs[debugIndex].childAPosition = vec4(childAPos, currentCell.positionAndMass.w);
    debugPairs[debugIndex].childBPosition = vec4(childBPos, childBCell.positionAndMass.w);
    debugPairs[debugIndex].distance = distance;
    debugPairs[debugIndex].isValid = 1;
} 