#version 430 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Cell data structure matching the one in the main simulation
struct ComputeCell {
    vec4 positionAndMass; // x, y, z, mass
    vec4 velocity;        // Fixed to match CPU layout
    vec4 acceleration;    // Fixed to match CPU layout
    vec4 orientation;     // quaternion: w, x, y, z
    vec4 angularVelocity;
    vec4 angularAcceleration;
    vec4 signallingSubstances;
    int modeIndex;
    float age;
    float toxins;
    float nitrates;
    // Unique ID system
    uint uniqueID;     // Packed ID: [parent(16)] [cell(15)] [child(1)]
    uint padding1;     // Padding to maintain alignment
    uvec2 padding2;    // Additional padding to ensure 16-byte alignment
};

// Spatial index structure - maps parent ID to child indices
struct ParentIndex {
    uint parentID;        // Parent ID
    uint childAIndex;     // Index of child A (child flag = 0)
    uint childBIndex;     // Index of child B (child flag = 1)
    uint isActive;        // Whether this parent has active children
};

// Input: Cell data
layout(std430, binding = 0) buffer CellBuffer {
    ComputeCell cells[];
};

// Output: Spatial index (parent lookup table)
layout(std430, binding = 1) buffer ParentIndexBuffer {
    ParentIndex parentIndices[];
};

// Counter buffer for atomic operations
layout(std430, binding = 2) buffer CounterBuffer {
    uint parentCount;
    uint padding[3]; // Padding to maintain alignment
};

// Cell count
layout(std430, binding = 3) buffer CellCountBuffer {
    uint cellCount;
    uint pendingCellCount;
};

// Extract parent ID from unique ID
uint getParentID(uint uniqueID) {
    return (uniqueID >> 16) & 0xFFFF;
}

// Extract child flag from unique ID (0 = child A, 1 = child B)
uint getChildFlag(uint uniqueID) {
    return uniqueID & 0x1;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    if (index >= cellCount) {
        return;
    }
    
    ComputeCell currentCell = cells[index];
    
    // Skip cells with no parent (initial spawned cells)
    uint parentID = getParentID(currentCell.uniqueID);
    if (parentID == 0) {
        return;
    }
    
    // OPTIMIZED: Only process child A (child flag = 0) to avoid duplicate processing
    // Child B will be found by child A, so we don't need to search for siblings
    uint childFlag = getChildFlag(currentCell.uniqueID);
    if (childFlag != 0) {
        return; // Skip child B
    }
    
    // Look for sibling (child B with same parent ID)
    // NOTE: This is O(nÂ²) but only runs when cell count changes, not every frame
    uint siblingIndex = 0xFFFFFFFF; // Invalid index
    
    for (uint i = 0; i < cellCount; i++) {
        if (i == index) continue; // Skip self
        
        ComputeCell otherCell = cells[i];
        uint otherParentID = getParentID(otherCell.uniqueID);
        uint otherChildFlag = getChildFlag(otherCell.uniqueID);
        
        // Check if it's our sibling (same parent, different child flag)
        if (otherParentID == parentID && otherChildFlag == 1) {
            siblingIndex = i;
            break;
        }
    }
    
    // If no sibling found, no parent index to create
    if (siblingIndex == 0xFFFFFFFF) {
        return;
    }
    
    // Use atomic operation to get a unique parent index
    uint parentIndex = atomicAdd(parentCount, 1);
    
    // Ensure we don't exceed the maximum parent indices
    if (parentIndex >= parentIndices.length()) {
        return;
    }
    
    // Store the parent index
    parentIndices[parentIndex].parentID = parentID;
    parentIndices[parentIndex].childAIndex = index;
    parentIndices[parentIndex].childBIndex = siblingIndex;
    parentIndices[parentIndex].isActive = 1;
} 