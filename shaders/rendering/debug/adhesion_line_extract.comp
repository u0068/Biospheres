#version 430 core

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass;   // x, y, z, mass
    vec4 velocity;          // x, y, z, padding
    vec4 acceleration;      // x, y, z, padding
    vec4 prevAcceleration;  // x, y, z, padding
    vec4 orientation;       // Quaternion to (prevent gimbal lock)
    vec4 angularVelocity;   // Pseudo-vector for easy math
    vec4 angularAcceleration;       // Pseudo-vector for easy math
    vec4 prevAngularAcceleration;   // Pseudo-vector for easy math
    // Internal:
    vec4 signallingSubstances; // 4 substances for now
    int modeIndex;  // absolute index of the cell's mode
    float age; // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
    
    // Lineage tracking (AA.BB.C format)
    uint parentLineageId;       // AA: Parent's unique ID (0 for root cells)
    uint uniqueId;              // BB: This cell's unique ID
    uint childNumber;           // C: Child number (1 or 2, 0 for root cells)
    uint _lineagePadding;       // Padding to maintain 16-byte alignment
};

// Adhesion connection structure - stores permanent connections between sibling cells
struct AdhesionConnection {
    uint cellAIndex;      // Index of first cell in the connection
    uint cellBIndex;      // Index of second cell in the connection
    uint modeIndex;       // Mode index for the connection ( to lookup adhesion settings )
    uint isActive;        // Whether this connection is still active (1 = active, 0 = inactive)
    uint zoneA;           // Zone classification for cell A (0=ZoneA, 1=ZoneB, 2=ZoneC)
    uint zoneB;           // Zone classification for cell B (0=ZoneA, 1=ZoneB, 2=ZoneC)
    vec3 anchorDirectionA; // Anchor direction for cell A in local cell space (normalized)
    float paddingA;       // Padding to ensure 16-byte alignment
    vec3 anchorDirectionB; // Anchor direction for cell B in local cell space (normalized)
    float paddingB;       // Padding to ensure 16-byte alignment
    vec4 twistReferenceA; // Reference quaternion for twist constraint for cell A (16 bytes)
    vec4 twistReferenceB; // Reference quaternion for twist constraint for cell B (16 bytes)
    uint _padding[2];     // Padding to ensure 16-byte alignment (96 bytes total)
};

// Adhesion line vertex data - each line has 2 vertices
// This struct must match the C++ AdhesionLineVertex struct exactly
struct AdhesionLineVertex {
    vec4 position;    // World position (w unused, but needed for alignment)
    vec4 color;       // RGB color (a unused, but needed for alignment)
};

// Input: Cell data
layout(std430, binding = 0) buffer CellBuffer {
    ComputeCell cells[];
};

layout(std430, binding = 1) coherent buffer AdhesionConnectionBuffer {
    AdhesionConnection connections[];
};

// Output: Adhesion line vertices
layout(std430, binding = 2) coherent buffer AdhesionLineBuffer {
    AdhesionLineVertex lineVertices[];
};

// Cell count
layout(std430, binding = 3) coherent buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    int freeAdhesionTop;
};

vec3 rotateVectorByQuaternion(vec3 v, vec4 q) {
    vec3 u = q.xyz;
    float s = q.w;
    return 2.0 * dot(u, v) * u + (s * s - dot(u, u)) * v + 2.0 * s * cross(u, v);
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    if (index >= totalAdhesionCount) {
        return;
    }
    
    AdhesionConnection currentAdhesion = connections[index];
    
    // Only process active connections
    if (currentAdhesion.isActive == 0) {
        return;
    }
    
    // Additional bounds checking to prevent invalid cell access
    if (currentAdhesion.cellAIndex >= totalCellCount || currentAdhesion.cellBIndex >= totalCellCount) {
        return;
    }
    
    // Get cell data
    ComputeCell cellA = cells[currentAdhesion.cellAIndex];
    ComputeCell cellB = cells[currentAdhesion.cellBIndex];
    
    // Safety check: if anchor directions are not properly initialized (all zeros), use defaults
    vec3 anchorA, anchorB;
    if (length(currentAdhesion.anchorDirectionA) < 0.001 && length(currentAdhesion.anchorDirectionB) < 0.001) {
        // Fallback: use default anchor positions (this should not happen in genome-based system)
        // Use cell centers to avoid spatial dependencies
        vec3 posA = cellA.positionAndMass.xyz;
        vec3 posB = cellB.positionAndMass.xyz;
        
        anchorA = posA;
        anchorB = posB;
    } else {
        // Use stored anchor directions (ideal geometry) to calculate anchor positions
        vec3 posA = cellA.positionAndMass.xyz;
        vec3 posB = cellB.positionAndMass.xyz;
        float radiusA = pow(cellA.positionAndMass.w, 1.0/3.0);
        float radiusB = pow(cellB.positionAndMass.w, 1.0/3.0);
        
        // Transform stored anchor directions from local to world space
        // These directions represent the ideal center-to-center geometry at rest length
        vec3 worldAnchorDirectionA = rotateVectorByQuaternion(currentAdhesion.anchorDirectionA, cellA.orientation);
        vec3 worldAnchorDirectionB = rotateVectorByQuaternion(currentAdhesion.anchorDirectionB, cellB.orientation);
        
        // Place anchors at radius intersections using the ideal directions
        anchorA = posA + worldAnchorDirectionA * radiusA;
        anchorB = posB + worldAnchorDirectionB * radiusB;
    }
    
    // Get cell centers for drawing center-to-center lines
    vec3 centerA = cellA.positionAndMass.xyz;
    vec3 centerB = cellB.positionAndMass.xyz;
    
    // Use a distinctive color for adhesion lines (orange/amber)
    float ratio = (totalAdhesionCount > 1) ? (index / float(totalAdhesionCount - 1)) : 0.0;
    vec4 lineColor = vec4(1.0, ratio, 0.0, 1.0); // Orange/Amber for active
    
    // Calculate midpoint between the two centers (not anchors)
    vec3 midPoint = (centerA + centerB) * 0.5;
    
    // Each cell pair now generates two line segments (3 points)
    // We need 4 vertices (2 per line segment) for the two-colored line
    uint lineIndex = index * 4;
    
    // Define zone colors
    vec4 zoneColors[3];
    zoneColors[0] = vec4(0.0, 1.0, 0.0, 1.0); // Green for Zone A
    zoneColors[1] = vec4(0.0, 0.0, 1.0, 1.0); // Blue for Zone B
    zoneColors[2] = vec4(1.0, 0.0, 0.0, 1.0); // Red for Zone C
    
    // Ensure zone indices are within bounds
    uint zoneA = min(currentAdhesion.zoneA, 2u);
    uint zoneB = min(currentAdhesion.zoneB, 2u);
    
    // Store the first line segment (from centerA to midpoint)
    // Line goes center-to-center, but anchor points remain at radius for visualization
    if (lineIndex < lineVertices.length() - 1) {
        lineVertices[lineIndex].position = vec4(centerA, 1.0);
        lineVertices[lineIndex].color = zoneColors[zoneA];
        
        lineVertices[lineIndex + 1].position = vec4(midPoint, 1.0);
        lineVertices[lineIndex + 1].color = zoneColors[zoneA];
    }
    
    // Store the second line segment (from midpoint to centerB)
    if (lineIndex + 2 < lineVertices.length() - 1) {
        lineVertices[lineIndex + 2].position = vec4(midPoint, 1.0);
        lineVertices[lineIndex + 2].color = zoneColors[zoneB];
        
        lineVertices[lineIndex + 3].position = vec4(centerB, 1.0);
        lineVertices[lineIndex + 3].color = zoneColors[zoneB];
    }
} 
