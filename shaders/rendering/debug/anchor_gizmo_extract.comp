#version 430 core

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass;   // x, y, z, mass
    vec4 velocity;          // x, y, z, padding
    vec4 acceleration;      // x, y, z, padding
    vec4 prevAcceleration;  // x, y, z, padding
    vec4 orientation;       // Quaternion to (prevent gimbal lock)
    vec4 angularVelocity;   // Pseudo-vector for easy math
    vec4 angularAcceleration;       // Pseudo-vector for easy math
    vec4 prevAngularAcceleration;   // Pseudo-vector for easy math
    // Internal:
    vec4 signallingSubstances; // 4 substances for now
    int modeIndex;  // absolute index of the cell's mode
    float age; // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
};

// Adhesion connection structure - stores permanent connections between sibling cells
struct AdhesionConnection {
    uint cellAIndex;      // Index of first cell in the connection
    uint cellBIndex;      // Index of second cell in the connection
    uint modeIndex;       // Mode index for the connection ( to lookup adhesion settings )
    uint isActive;        // Whether this connection is still active (1 = active, 0 = inactive)
    vec3 anchorDirectionA; // Anchor direction for cell A in local cell space (normalized)
    float paddingA;       // Padding to ensure 16-byte alignment
    vec3 anchorDirectionB; // Anchor direction for cell B in local cell space (normalized)
    float paddingB;       // Padding to ensure 16-byte alignment
    vec4 twistReferenceA; // Reference quaternion for twist constraint for cell A (16 bytes)
    vec4 twistReferenceB; // Reference quaternion for twist constraint for cell B (16 bytes)
};

struct AdhesionSettings
{
    bool canBreak;
    float breakForce;
    float restLength;
    float linearSpringStiffness;
    float linearSpringDamping;
    float orientationSpringStiffness;
    float orientationSpringDamping;
    float maxAngularDeviation;      // Does nothing yet
    
    // Twist constraint parameters
    float twistConstraintStiffness; // Stiffness of twist constraint around adhesion axis
    float twistConstraintDamping;   // Damping of twist constraint
    bool enableTwistConstraint;     // Whether to apply twist constraints
    
    // Padding to ensure proper alignment - GLSL handles this automatically but we keep it for consistency
    // Note: In GLSL, the compiler will add padding as needed for std430 layout
};

// GPU Mode structure
struct GPUMode {
    vec4 color;           // R, G, B, padding
    vec4 orientationA;    // Quaternion
    vec4 orientationB;    // Quaternion
    vec4 splitDirection;  // x, y, z, padding
    ivec2 childModes;     // mode indices for children
    float splitInterval;
    int genomeOffset;
    AdhesionSettings adhesionSettings;
    int parentMakeAdhesion; // Boolean flag for adhesion creation
    int childAKeepAdhesion; // Boolean flag for child A to keep adhesion
    int childBKeepAdhesion; // Boolean flag for child B to keep adhesion
    int maxAdhesions;       // Max number of adhesions
};

// Anchor sphere instance data (matches cell rendering structure)
// Total size: 48 bytes (3 * vec4), 16-byte aligned
struct AnchorInstance {
    vec4 positionAndRadius;  // xyz = position, w = radius (16 bytes)
    vec4 color;              // rgb = color, a = unused (16 bytes)
    vec4 orientation;        // quaternion (unused for spheres, but matches structure) (16 bytes)
};

// Input: Cell data
layout(std430, binding = 0) buffer CellBuffer {
    ComputeCell cells[];
};

// Input: Mode data
layout(std430, binding = 1) buffer ModeBuffer {
    GPUMode modes[];
};

// Input: Adhesion connection data
layout(std430, binding = 2) buffer AdhesionConnectionBuffer {
    AdhesionConnection connections[];
};

// Output: Anchor instances
layout(std430, binding = 3) buffer AnchorBuffer {
    AnchorInstance anchorInstances[];
};

// Output: Total anchor count
layout(std430, binding = 4) buffer AnchorCountBuffer {
    uint totalAnchorCount;
};

// Cell count
layout(std430, binding = 5) buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    uint freeAdhesionTop;
};

// Rotate vector by quaternion
vec3 rotateVectorByQuaternion(vec3 v, vec4 q) {
    vec3 u = q.xyz;
    float s = q.w;
    return 2.0 * dot(u, v) * u + (s * s - dot(u, u)) * v + 2.0 * s * cross(u, v);
}

void main() {
    uint cellIndex = gl_GlobalInvocationID.x;
    
    if (cellIndex >= totalCellCount) return;
    
    ComputeCell cell = cells[cellIndex];
    vec3 cellPos = cell.positionAndMass.xyz;
    float cellRadius = pow(cell.positionAndMass.w, 1.0/3.0);
    

    // Check each adhesion index for this cell
    for (int i = 0; i < 20; ++i) {
        int adhesionIndex = cell.adhesionIndices[i];
        if (adhesionIndex < 0) continue; // No adhesion connection
        
        AdhesionConnection connection = connections[adhesionIndex];
        if (connection.isActive == 0) continue; // Inactive connection
        
        // Determine which cell this is in the connection and get the appropriate anchor direction
        bool isCellA = (connection.cellAIndex == cellIndex);
        
        // Safety check: if anchor directions are not properly initialized (all zeros), calculate them dynamically
        vec3 anchorPos;
        if (length(connection.anchorDirectionA) < 0.001 && length(connection.anchorDirectionB) < 0.001) {
            // Fallback: calculate anchor position dynamically
            uint otherCellIndex = isCellA ? connection.cellBIndex : connection.cellAIndex;
            if (otherCellIndex < totalCellCount) {
                ComputeCell otherCell = cells[otherCellIndex];
                vec3 otherCellPos = otherCell.positionAndMass.xyz;
                vec3 directionToOther = normalize(otherCellPos - cellPos);
                anchorPos = cellPos + directionToOther * cellRadius;
            } else {
                // Fallback to cell center if other cell is invalid
                anchorPos = cellPos;
            }
        } else {
            // Use the stored local anchor direction, transformed to world space
            vec3 localAnchorDirection = isCellA ? connection.anchorDirectionA : connection.anchorDirectionB;
            vec3 worldAnchorDirection = rotateVectorByQuaternion(localAnchorDirection, cell.orientation);
            anchorPos = cellPos + worldAnchorDirection * cellRadius;
        }
        
        // Calculate anchor sphere radius
        float anchorRadius = cellRadius * 0.15; // 15% of cell radius
        
        // Get instance index and create instance data
        uint anchorIndex = atomicAdd(totalAnchorCount, 1);
        
        // Create anchor instance (using the same structure as cell rendering)
        anchorInstances[anchorIndex].positionAndRadius = vec4(anchorPos, anchorRadius);
        anchorInstances[anchorIndex].color = isCellA ? vec4(0.0, 0.5, 1.0, 1.0) : vec4(1.0, 0.5, 0.0, 1.0); // Blue or Orange color
        anchorInstances[anchorIndex].orientation = vec4(0.0, 0.0, 0.0, 1.0); // Identity quaternion
    }
} 
