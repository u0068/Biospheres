#version 430 core

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass;   // x, y, z, mass
    vec4 velocity;          // x, y, z, padding
    vec4 acceleration;      // x, y, z, padding
    vec4 prevAcceleration;  // x, y, z, padding
    vec4 orientation;       // Quaternion to (prevent gimbal lock)
    vec4 genomeOrientation; // Quaternion for genome-derived orientation - NEVER affected by physics
    vec4 angularVelocity;   // Pseudo-vector for easy math
    vec4 angularAcceleration;       // Pseudo-vector for easy math
    vec4 prevAngularAcceleration;   // Pseudo-vector for easy math
    // Internal:
    vec4 signallingSubstances; // 4 substances for now
    int modeIndex;  // absolute index of the cell's mode
    float age; // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
    
    // Padding to maintain 16-byte alignment for the entire struct
    uint _padding[4];
};

// Gizmo line data - each cell generates 6 vertices (3 lines, 2 vertices each)
struct GizmoVertex {
    vec4 position;    // World position (w unused, but needed for alignment)
    vec4 color;       // RGB color (a unused, but needed for alignment)
};

// Input: Cell data
layout(std430, binding = 0) buffer CellBuffer {
    ComputeCell cells[];
};

// Output: Gizmo line vertices
layout(std430, binding = 1) buffer GizmoBuffer {
    GizmoVertex gizmoVertices[];
};

// Cell count
layout(std430, binding = 2) buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    uint freeAdhesionTop;
};

vec3 rotateVectorByQuaternion(vec3 v, vec4 q) {
    vec3 u = q.xyz;
    float s = q.w;
    return 2.0 * dot(u, v) * u + (s * s - dot(u, u)) * v + 2.0 * s * cross(u, v);
}

void main() {
    uint cellIndex = gl_GlobalInvocationID.x;
    
    if (cellIndex >= totalCellCount) return;
    
    ComputeCell cell = cells[cellIndex];
    vec3 cellPos = cell.positionAndMass.xyz;
    float cellRadius = pow(cell.positionAndMass.w, 1.0/3.0);
    
    // Calculate gizmo length based on cell size
    float gizmoLength = cellRadius * 1.8; // 1.8x the cell radius
    
    // Local coordinate system vectors
    vec3 forward = vec3(1.0, 0.0, 0.0);  // Local X-axis (red)
    vec3 right = vec3(0.0, 1.0, 0.0);    // Local Y-axis (green) 
    vec3 up = vec3(0.0, 0.0, 1.0);       // Local Z-axis (blue)
    
    // Transform local vectors to world space
    vec3 worldForward = rotateVectorByQuaternion(forward, cell.orientation);
    vec3 worldRight = rotateVectorByQuaternion(right, cell.orientation);
    vec3 worldUp = rotateVectorByQuaternion(up, cell.orientation);

    // Each cell generates 6 vertices (3 lines, 2 vertices each)
    uint baseIndex = cellIndex * 6;
    
    // Forward axis line (blue)
    gizmoVertices[baseIndex + 0].position = vec4(cellPos, 1.0);
    gizmoVertices[baseIndex + 0].color = vec4(0.0, 0.0, 1.0, 1.0);
    gizmoVertices[baseIndex + 1].position = vec4(cellPos + worldForward * gizmoLength, 1.0);
    gizmoVertices[baseIndex + 1].color = vec4(0.0, 0.0, 1.0, 1.0);
    
    // Right axis line (green)
    gizmoVertices[baseIndex + 2].position = vec4(cellPos, 1.0);
    gizmoVertices[baseIndex + 2].color = vec4(0.0, 1.0, 0.0, 1.0);
    gizmoVertices[baseIndex + 3].position = vec4(cellPos + worldRight * gizmoLength, 1.0);
    gizmoVertices[baseIndex + 3].color = vec4(0.0, 1.0, 0.0, 1.0);
    
    // Up axis line (red)
    gizmoVertices[baseIndex + 4].position = vec4(cellPos, 1.0);
    gizmoVertices[baseIndex + 4].color = vec4(1.0, 0.0, 0.0, 1.0);
    gizmoVertices[baseIndex + 5].position = vec4(cellPos + worldUp * gizmoLength, 1.0);
    gizmoVertices[baseIndex + 5].color = vec4(1.0, 0.0, 0.0, 1.0);
} 
