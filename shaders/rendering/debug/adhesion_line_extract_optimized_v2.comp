#version 430 core
#extension GL_ARB_gpu_shader_int64 : enable

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Cell data structure matching the one in the main simulation
struct ComputeCell {
    vec4 positionAndMass; // x, y, z, mass
    vec4 velocity;        // Fixed to match CPU layout
    vec4 acceleration;    // Fixed to match CPU layout
    vec4 orientation;     // quaternion: w, x, y, z
    vec4 angularVelocity;
    vec4 angularAcceleration;
    vec4 signallingSubstances;
    int modeIndex;
    float age;
    float toxins;
    float nitrates;
    // Unique ID system
    uint64_t uniqueID;     // Packed ID: [parent(32)] [cell(31)] [child(1)]
    uint64_t padding1;     // Padding to maintain alignment
    uint padding2[4];    // Additional padding to ensure 16-byte alignment
};

// GPU Mode structure
struct GPUMode {
    vec4 color;           // R, G, B, padding
    vec4 orientationA;    // quaternion
    vec4 orientationB;    // quaternion
    vec4 splitDirection;  // x, y, z, padding
    ivec2 childModes;     // mode indices for children
    float splitInterval;
    int genomeOffset;
    int parentMakeAdhesion; // Boolean flag for adhesion creation
    int padding;          // Padding to maintain alignment
};

// Parent-children mapping structure
struct ParentChildren {
    uint childAIndex;
    uint childBIndex;
    uint isActive;
    uint padding;
};

// Adhesion line vertex data - each line has 2 vertices
struct AdhesionLineVertex {
    vec4 position;    // World position (w unused, but needed for alignment)
    vec4 color;       // RGB color (a unused, but needed for alignment)
};

// Input: Cell data
layout(std430, binding = 0) buffer CellBuffer {
    ComputeCell cells[];
};

// Input: Mode data
layout(std430, binding = 1) buffer ModeBuffer {
    GPUMode modes[];
};

// Input: Parent-children mapping (O(1) lookup)
layout(std430, binding = 2) buffer ParentChildrenBuffer {
    ParentChildren parentChildrenTable[];
};

// Output: Adhesion line vertices
layout(std430, binding = 3) buffer AdhesionLineBuffer {
    AdhesionLineVertex lineVertices[];
};

// Cell count and parent table size
layout(std430, binding = 4) buffer CountBuffer {
    uint cellCount;
    uint parentTableSize;
    uint padding[2];
};

// Extract parent ID from unique ID
uint getParentID(uint64_t uniqueID) {
    return uint((uniqueID >> 32) & 0xFFFFFFFF);
}

// Extract child flag from unique ID (0 = child A, 1 = child B)
uint getChildFlag(uint64_t uniqueID) {
    return uint(uniqueID & 0x1);
}

// Convert quaternion to rotation matrix
mat3 quatToMat3(vec4 quat) {
    float x = quat.x, y = quat.y, z = quat.z, w = quat.w;
    float x2 = x + x, y2 = y + y, z2 = z + z;
    float xx = x * x2, xy = x * y2, xz = x * z2;
    float yy = y * y2, yz = y * z2, zz = z * z2;
    float wx = w * x2, wy = w * y2, wz = w * z2;

    return mat3(
        1.0 - (yy + zz), xy + wz, xz - wy,
        xy - wz, 1.0 - (xx + zz), yz + wx,
        xz + wy, yz - wx, 1.0 - (xx + yy)
    );
}

// Determine zone color based on position relative to cell's own split plane
vec4 getZoneColor(vec3 pos, ComputeCell cell, GPUMode mode) {
    // Transform the split direction by the cell's current orientation
    vec3 splitNormal = normalize(quatToMat3(cell.orientation) * mode.splitDirection.xyz);
    vec3 cellPos = cell.positionAndMass.xyz;
    vec3 toPos = normalize(pos - cellPos);
    float d = dot(toPos, splitNormal);
    
    // Convert 10 degrees to radians and calculate cosine threshold for perpendicular
    // 90 degrees - 10 degrees = 80 degrees, so threshold is cos(80Â°)
    float angleThreshold = cos(radians(80.0));
    float absDot = abs(d);
    
    if (absDot < angleThreshold) {
        return vec4(1.0, 0.0, 0.0, 1.0); // Red for zone C (within 10 degrees of perpendicular)
    } else if (d > 0.01) {
        return vec4(0.0, 0.0, 1.0, 1.0); // Blue for zone A (reversed)
    } else {
        return vec4(0.0, 1.0, 0.0, 1.0); // Green for zone B (reversed)
    }
}

void main() {
    uint parentID = gl_GlobalInvocationID.x;
    if (parentID >= parentTableSize) {
        return;
    }

    ParentChildren entry = parentChildrenTable[parentID];
    if (entry.isActive == 0 || entry.childAIndex == 0xFFFFFFFF || entry.childBIndex == 0xFFFFFFFF) {
        return; // No valid pair
    }
    if (entry.childAIndex >= cellCount || entry.childBIndex >= cellCount) {
        return; // Out of bounds
    }

    ComputeCell childA = cells[entry.childAIndex];
    ComputeCell childB = cells[entry.childBIndex];

    // Only draw if parent allows adhesion (check mode of either child)
    int modeIdxA = childA.modeIndex;
    int modeIdxB = childB.modeIndex;
    if (modeIdxA < 0 || modeIdxA >= modes.length() || modeIdxB < 0 || modeIdxB >= modes.length()) {
        return;
    }
    GPUMode modeA = modes[modeIdxA];
    GPUMode modeB = modes[modeIdxB];
    bool parentAllowsAdhesion = (modeA.parentMakeAdhesion != 0) || (modeB.parentMakeAdhesion != 0);
    if (!parentAllowsAdhesion) {
        return;
    }

    // Calculate line vertices
    vec3 posA = childA.positionAndMass.xyz;
    vec3 posB = childB.positionAndMass.xyz;
    vec3 midpoint = (posA + posB) * 0.5;

    // Create two line segments: childA to midpoint, and midpoint to childB
    // Each parent generates two lines (4 vertices total)
    uint lineIndex = parentID * 4;

    // Store the line vertices with zone-based coloring
    if (lineIndex + 3 < lineVertices.length()) {
        // Add bounds checking for mode indices
        if (childA.modeIndex < 0 || childA.modeIndex >= modes.length() ||
            childB.modeIndex < 0 || childB.modeIndex >= modes.length()) {
            return; // Skip if mode indices are invalid
        }
        
        // Get the modes for each child
        GPUMode modeForChildA = modes[childA.modeIndex];
        GPUMode modeForChildB = modes[childB.modeIndex];
        
        // First segment: childA to midpoint - color based on segment position relative to childA's split plane
        vec3 segmentAPos = (posA + midpoint) * 0.5; // Middle of first segment
        vec4 colorA = getZoneColor(segmentAPos, childA, modeForChildA);
        lineVertices[lineIndex].position = vec4(posA, 1.0);
        lineVertices[lineIndex].color = colorA;
        lineVertices[lineIndex + 1].position = vec4(midpoint, 1.0);
        lineVertices[lineIndex + 1].color = colorA;
        
        // Second segment: childB to midpoint - color based on segment position relative to childB's split plane
        vec3 segmentBPos = (posB + midpoint) * 0.5; // Middle of second segment
        vec4 colorB = getZoneColor(segmentBPos, childB, modeForChildB);
        lineVertices[lineIndex + 2].position = vec4(posB, 1.0);
        lineVertices[lineIndex + 2].color = colorB;
        lineVertices[lineIndex + 3].position = vec4(midpoint, 1.0);
        lineVertices[lineIndex + 3].color = colorB;
    }
} 