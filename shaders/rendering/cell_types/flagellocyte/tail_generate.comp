#version 430 core

layout(local_size_x = 64) in;

// Input: Cell data (full ComputeCell structure)
struct ComputeCell {
    vec4 positionAndMass;
    vec4 velocity;
    vec4 acceleration;
    vec4 prevAcceleration;
    vec4 orientation;
    vec4 angularVelocity;
    vec4 angularAcceleration;
    vec4 prevAngularAcceleration;
    vec4 signallingSubstances;
    int modeIndex;
    float age;
    float toxins;
    float nitrates;
    int adhesionIndices[20];
    uint parentLineageId;
    uint uniqueId;
    uint childNumber;
    uint _lineagePadding;
};

// GPU Mode structure for colors
struct GPUModeAdhesionSettings {
    int canBreak;
    float breakForce;
    float restLength;
    float linearSpringStiffness;
    float linearSpringDamping;
    float orientationSpringStiffness;
    float orientationSpringDamping;
    float maxAngularDeviation;
    float twistConstraintStiffness;
    float twistConstraintDamping;
    int enableTwistConstraint;
    int _padding;
};

struct GPUMode {
    vec4 color;
    vec4 orientationA;
    vec4 orientationB;
    vec4 splitDirection;
    ivec2 childModes;
    float splitInterval;
    int genomeOffset;
    GPUModeAdhesionSettings adhesionSettings;
    int parentMakeAdhesion;
    int childAKeepAdhesion;
    int childBKeepAdhesion;
    int maxAdhesions;
    float flagellocyteSwimSpeed;
    float flagellocyteNutrientConsumption;
    float nutrientPriority;
    int cellType;
};

layout(std430, binding = 0) readonly buffer CellBuffer {
    ComputeCell cells[];
};

layout(std430, binding = 2) readonly buffer ModeBuffer {
    GPUMode modes[];
};

// Output: Tail vertices
struct TailVertex {
    vec4 position;  // xyz = position, w = fade factor
    vec4 normal;    // xyz = normal, w unused
    vec4 color;     // rgb = color, w unused
};

layout(std430, binding = 1) writeonly buffer TailVertexBuffer {
    TailVertex tailVertices[];
};

// Tail parameters
uniform int uCellCount;
uniform float uTime = 0.0;
uniform vec3 uCameraPos = vec3(0.0);
uniform float uFadeStartDistance = 50.0;
uniform float uFadeEndDistance = 100.0;

// Hardcoded tail settings
const float uTailLength = 2.5;
const float uTailThickness = 0.25;
const float uSpiralTightness = 1.0;
const float uSpiralRadius = 0.2;
const float uRotationSpeed = 2.0;
const float uTailTaper = 0.8;
const int uTailSegments = 20;

// Number of radial subdivisions and cap segments (fixed for simplicity)
const int RADIAL_SEGMENTS = 8;
const int CAP_SEGMENTS = 4; // Segments for rounded end cap
const int MAX_TAIL_SEGMENTS = 64; // Maximum for buffer allocation

// Convert quaternion to rotation matrix
mat3 quatToMat3(vec4 q) {
    float x = q.x, y = q.y, z = q.z, w = q.w;
    float x2 = x + x, y2 = y + y, z2 = z + z;
    float xx = x * x2, xy = x * y2, xz = x * z2;
    float yy = y * y2, yz = y * z2, zz = z * z2;
    float wx = w * x2, wy = w * y2, wz = w * z2;
    
    return mat3(
        1.0 - (yy + zz), xy + wz, xz - wy,
        xy - wz, 1.0 - (xx + zz), yz + wx,
        xz + wy, yz - wx, 1.0 - (xx + yy)
    );
}

void main() {
    uint cellIndex = gl_GlobalInvocationID.x;
    if (cellIndex >= uCellCount) return;
    
    ComputeCell cell = cells[cellIndex];
    
    // Check if this cell is a flagellocyte (has swim speed > 0)
    int modeIndex = cell.modeIndex;
    if (modeIndex < 0 || modeIndex >= modes.length()) return;
    float swimSpeed = modes[modeIndex].flagellocyteSwimSpeed;
    if (swimSpeed <= 0.0) {
        // Not a flagellocyte - set tail vertices far away to make them invisible
        int maxVerticesPerCell = (MAX_TAIL_SEGMENTS + 1) * RADIAL_SEGMENTS + (CAP_SEGMENTS * RADIAL_SEGMENTS) + 1;
        uint baseVertexIndex = cellIndex * maxVerticesPerCell;
        vec4 farAway = vec4(1000000.0, 1000000.0, 1000000.0, 0.0); // Far outside view frustum
        for (int i = 0; i < maxVerticesPerCell; i++) {
            tailVertices[baseVertexIndex + i].position = farAway;
            tailVertices[baseVertexIndex + i].normal = vec4(0.0, 0.0, 1.0, 0.0);
            tailVertices[baseVertexIndex + i].color = vec4(0.0);
        }
        return;
    }
    
    vec3 cellPos = cell.positionAndMass.xyz;
    float cellMass = cell.positionAndMass.w;
    float cellRadius = pow(cellMass, 1.0 / 3.0); // Radius = mass^(1/3)
    vec4 orientation = cell.orientation;
    
    // Get color from mode buffer
    vec3 cellColor = modes[modeIndex].color.rgb;
    
    mat3 rotMatrix = quatToMat3(orientation);
    
    // Tail direction (along negative Z axis in local space)
    vec3 tailDirection = rotMatrix * vec3(0, 0, 1);
    vec3 right = rotMatrix * vec3(1, 0, 0);
    vec3 up = rotMatrix * vec3(0, 1, 0);
    
    // Scale tail dimensions based on cell radius
    // This makes the tail proportional to the cell size
    float tailLength = uTailLength * cellRadius;
    float tailThickness = uTailThickness * cellRadius;
    float spiralRadius = uSpiralRadius * cellRadius;
    
    // Start point of tail (just inside the back of sphere to avoid gaps)
    vec3 tailStart = cellPos - tailDirection * (cellRadius * 0.85);
    
    // Current rotation for spiral - scaled by swim speed
    // Faster swim speed = faster tail rotation
    float currentRotation = uTime * uRotationSpeed * swimSpeed;
    
    int tailSegments = min(uTailSegments, MAX_TAIL_SEGMENTS);
    // Use MAX_TAIL_SEGMENTS for buffer layout to ensure consistent spacing
    int maxVerticesPerCell = (MAX_TAIL_SEGMENTS + 1) * RADIAL_SEGMENTS + (CAP_SEGMENTS * RADIAL_SEGMENTS) + 1;
    uint baseVertexIndex = cellIndex * maxVerticesPerCell;
    
    // Calculate fade factor based on distance from camera
    float distanceToCamera = length(cellPos - uCameraPos);
    float fadeFactor = 1.0 - smoothstep(uFadeStartDistance, uFadeEndDistance, distanceToCamera);
    fadeFactor = clamp(fadeFactor, 0.0, 1.0);
    
    // Generate vertices for each segment
    for (int segment = 0; segment <= tailSegments; segment++) {
        float t = float(segment) / float(tailSegments);
        float axisPos = t * tailLength;
        
        // Spiral angle
        float spiralAngle = (t * uSpiralTightness * 6.28318) + currentRotation;
        
        // Gradually increase spiral radius from 0 to full radius
        // This creates a smooth transition from center to spiral
        float spiralRadiusFactor = smoothstep(0.0, 0.3, t); // Ramp up over first 30% of tail
        vec3 spiralOffset = (right * cos(spiralAngle) + up * sin(spiralAngle)) * (spiralRadius * spiralRadiusFactor);
        
        // Center of this ring
        vec3 ringCenter = tailStart - tailDirection * axisPos + spiralOffset;
        
        // Thickness taper - lerp between full thickness and tapered based on uTailTaper
        // uTailTaper = 0.0: uniform thickness
        // uTailTaper = 1.0: full taper to point
        float thickness = tailThickness * (1.0 - t * uTailTaper);
        
        // Calculate tangent for proper normal orientation
        vec3 tangent = normalize(-tailDirection + 
            (right * (-sin(spiralAngle)) + up * cos(spiralAngle)) * 
            (spiralRadius * uSpiralTightness * 6.28318 / tailLength));
        
        // Generate ring of vertices
        for (int radial = 0; radial < RADIAL_SEGMENTS; radial++) {
            float angle = float(radial) / float(RADIAL_SEGMENTS) * 6.28318;
            
            // Position around ring
            vec3 radialOffset = (right * cos(angle) + up * sin(angle)) * thickness;
            vec3 vertexPos = ringCenter + radialOffset;
            
            // Normal pointing outward from ring center
            vec3 normal = normalize(radialOffset);
            
            uint vertexIndex = baseVertexIndex + segment * RADIAL_SEGMENTS + radial;
            tailVertices[vertexIndex].position = vec4(vertexPos, fadeFactor);
            tailVertices[vertexIndex].normal = vec4(normal, 0.0);
            tailVertices[vertexIndex].color = vec4(cellColor, 1.0);
        }
    }
    
    // Generate rounded end cap
    uint capBaseIndex = baseVertexIndex + (tailSegments + 1) * RADIAL_SEGMENTS;
    
    // Get the last ring position and properties
    float lastT = 1.0;
    float lastAxisPos = lastT * tailLength;
    float lastSpiralAngle = (lastT * uSpiralTightness * 6.28318) + currentRotation;
    float lastSpiralRadiusFactor = smoothstep(0.0, 0.3, lastT);
    vec3 lastSpiralOffset = (right * cos(lastSpiralAngle) + up * sin(lastSpiralAngle)) * (spiralRadius * lastSpiralRadiusFactor);
    vec3 lastRingCenter = tailStart - tailDirection * lastAxisPos + lastSpiralOffset;
    float lastThickness = tailThickness * (1.0 - lastT * uTailTaper);
    
    // Generate cap rings (hemisphere)
    for (int capSeg = 1; capSeg <= CAP_SEGMENTS; capSeg++) {
        float capT = float(capSeg) / float(CAP_SEGMENTS);
        float hemisphereAngle = capT * 1.5708; // 0 to PI/2 (90 degrees)
        
        // Position along tail axis for this cap ring
        float capOffset = sin(hemisphereAngle) * lastThickness;
        float capRadius = cos(hemisphereAngle) * lastThickness;
        
        vec3 capRingCenter = lastRingCenter - tailDirection * capOffset;
        
        for (int radial = 0; radial < RADIAL_SEGMENTS; radial++) {
            float angle = float(radial) / float(RADIAL_SEGMENTS) * 6.28318;
            
            vec3 radialOffset = (right * cos(angle) + up * sin(angle)) * capRadius;
            vec3 vertexPos = capRingCenter + radialOffset;
            
            // Normal points outward from hemisphere center
            vec3 toVertex = vertexPos - lastRingCenter;
            vec3 normal = normalize(toVertex);
            
            uint vertexIndex = capBaseIndex + (capSeg - 1) * RADIAL_SEGMENTS + radial;
            tailVertices[vertexIndex].position = vec4(vertexPos, fadeFactor);
            tailVertices[vertexIndex].normal = vec4(normal, 0.0);
            tailVertices[vertexIndex].color = vec4(cellColor, 1.0);
        }
    }
    
    // Add single tip vertex at the very end
    uint tipIndex = capBaseIndex + CAP_SEGMENTS * RADIAL_SEGMENTS;
    vec3 tipPos = lastRingCenter - tailDirection * lastThickness;
    tailVertices[tipIndex].position = vec4(tipPos, fadeFactor);
    tailVertices[tipIndex].normal = vec4(-tailDirection, 0.0);
    tailVertices[tipIndex].color = vec4(cellColor, 1.0);
}
