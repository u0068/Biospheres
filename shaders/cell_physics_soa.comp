#version 430

// Local work group size
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Structure of Arrays (SoA) approach for better memory access patterns
layout(std430, binding = 0) restrict buffer PositionBuffer {
    vec3 positions[];
};

layout(std430, binding = 1) restrict buffer RadiusBuffer {
    float radii[];
};

layout(std430, binding = 2) restrict buffer VelocityBuffer {
    vec3 velocities[];
};

layout(std430, binding = 3) restrict buffer MassBuffer {
    float masses[];
};

layout(std430, binding = 4) restrict buffer AccelerationBuffer {
    vec3 accelerations[];
};

// Uniforms
uniform float u_deltaTime;
uniform int u_cellCount;
uniform float u_damping;
uniform int u_draggedCellIndex; // Index of cell being dragged (-1 if none)

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    // Check bounds
    if (index >= u_cellCount) {
        return;
    }
    
    // Skip physics for dragged cell - it will be positioned directly
    if (int(index) == u_draggedCellIndex) {
        // Clear velocity and acceleration for dragged cell
        velocities[index] = vec3(0.0);
        accelerations[index] = vec3(0.0);
        return;
    }
    
    // Reset acceleration
    accelerations[index] = vec3(0.0);
    
    // Calculate forces from other cells (collision resolution)
    vec3 totalForce = vec3(0.0);
    vec3 myPos = positions[index];
    float myRadius = radii[index];
    float myMass = masses[index];
    
    for (uint j = 0; j < u_cellCount; ++j) {
        if (j == index) continue;
        
        vec3 otherPos = positions[j];
        float otherRadius = radii[j];
        float otherMass = masses[j];
        
        vec3 direction = myPos - otherPos;
        float distance = length(direction);
        float minDistance = myRadius + otherRadius;
        
        // Collision response
        if (distance < minDistance && distance > 0.001) {
            direction = normalize(direction);
            
            // Simple elastic collision force
            float overlap = minDistance - distance;
            float forceStrength = overlap * 100.0; // Spring constant
            
            // Mass-based force distribution
            float massRatio = otherMass / (myMass + otherMass);
            totalForce += direction * forceStrength * massRatio;
        }
    }
    
    // Apply force to acceleration
    accelerations[index] = totalForce / myMass;
}
