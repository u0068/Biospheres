#version 430

// Optimized work group size for better memory coalescing
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass;   // x, y, z, mass
    vec4 velocity;          // x, y, z, padding
    vec4 acceleration;      // x, y, z, padding
    vec4 prevAcceleration;  // x, y, z, padding
    vec4 orientation;       // Quaternion to (prevent gimbal lock)
    vec4 genomeOrientation; // Quaternion for genome-derived orientation - NEVER affected by physics
    vec4 angularVelocity;   // Pseudo-vector for easy math
    vec4 angularAcceleration;       // Pseudo-vector for easy math
    vec4 prevAngularAcceleration;   // Pseudo-vector for easy math
    // Internal:
    vec4 signallingSubstances; // 4 substances for now
    int modeIndex;  // absolute index of the cell's mode
    float age; // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
    
    // Padding to maintain 16-byte alignment for the entire struct
    uint _padding[4];
};

// Shader storage buffer objects
layout(std430, binding = 0) restrict buffer CellBuffer {
    ComputeCell cells[];
};

layout(std430, binding = 1) restrict buffer GridCountBuffer {
    uint gridCounts[];
};

// Cell count buffer for GPU Main System
// Tracks cell and adhesion counts for the main simulation
layout(std430, binding = 2) buffer CellCountBuffer {
    uint allocatedCellCount;      // Total cell slots (living + dead)
    uint liveCellCount;           // Currently living cells
    uint allocatedAdhesionCount;  // Total adhesion slots
    uint freeAdhesionTop;         // Top of free adhesion stack
};

// Uniforms
uniform int u_gridResolution;
uniform float u_gridCellSize;
uniform float u_worldSize;

// Function to convert world position to grid coordinates
ivec3 worldToGrid(vec3 worldPos) {
    // Clamp to world bounds first
    vec3 clampedPos = clamp(worldPos, vec3(-u_worldSize * 0.5), vec3(u_worldSize * 0.5));
    
    // Convert to grid coordinates [0, gridResolution)
    vec3 normalizedPos = (clampedPos + u_worldSize * 0.5) / u_worldSize;
    ivec3 gridPos = ivec3(normalizedPos * u_gridResolution);
    
    // Ensure we stay within bounds
    return clamp(gridPos, ivec3(0), ivec3(u_gridResolution - 1));
}

// Function to convert 3D grid coordinates to 1D index
uint gridToIndex(ivec3 gridPos) {
    return uint(gridPos.x + gridPos.y * u_gridResolution + gridPos.z * u_gridResolution * u_gridResolution);
}

void main() {
    uint cellIndex = gl_GlobalInvocationID.x;
      // Check bounds
    if (cellIndex >= allocatedCellCount) {
        return;
    }
    
    // Get cell position
    vec3 cellPos = cells[cellIndex].positionAndMass.xyz;
    
    // Convert to grid coordinates
    ivec3 gridPos = worldToGrid(cellPos);
    uint gridIndex = gridToIndex(gridPos);
    
    // Atomically increment the count for this grid cell
    atomicAdd(gridCounts[gridIndex], 1);
}

