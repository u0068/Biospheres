#version 430 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Input: Full cell data from physics simulation

struct GPUModeAdhesionSettings
{
    int canBreak;                 // bool -> int (4 bytes)
    float breakForce;
    float restLength;
    float linearSpringStiffness;
    float linearSpringDamping;
    float orientationSpringStiffness;
    float orientationSpringDamping;
    float maxAngularDeviation;
    float twistConstraintStiffness;
    float twistConstraintDamping;
    int enableTwistConstraint;    // bool -> int (4 bytes)
    int _padding;                 // pad to 48 bytes
};

// GPU Mode structure
struct GPUMode {
    vec4 color;           // R, G, B, padding
    vec4 orientationA;    // Quaternion
    vec4 orientationB;    // Quaternion
    vec4 splitDirection;  // x, y, z, padding
    ivec2 childModes;     // mode indices for children
    float splitInterval;
    int genomeOffset;
    GPUModeAdhesionSettings adhesionSettings;
    int parentMakeAdhesion;
    int childAKeepAdhesion;
    int childBKeepAdhesion;
    int maxAdhesions;
    float flagellocyteThrustForce;
    float _padding1;
    float _padding2;
    float _padding3;
};

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass;   // x, y, z, mass
    vec4 velocity;          // x, y, z, padding
    vec4 acceleration;      // x, y, z, padding
    vec4 prevAcceleration;  // x, y, z, padding
    vec4 orientation;       // Quaternion to (prevent gimbal lock)
    vec4 angularVelocity;   // Pseudo-vector for easy math
    vec4 angularAcceleration;       // Pseudo-vector for easy math
    vec4 prevAngularAcceleration;   // Pseudo-vector for easy math
    // Internal:
    vec4 signallingSubstances; // 4 substances for now
    int modeIndex;  // absolute index of the cell's mode
    float age; // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
    
    // Lineage tracking (AA.BB.C format)
    uint parentLineageId;       // AA: Parent's unique ID (0 for root cells)
    uint uniqueId;              // BB: This cell's unique ID
    uint childNumber;           // C: Child number (1 or 2, 0 for root cells)
    uint _lineagePadding;       // Padding to maintain 16-byte alignment
};

struct InstanceData {
    vec4 positionAndRadius;
    vec4 color;
    vec4 orientation;  // quaternion for rotation
};

layout(std430, binding = 0) buffer CellBuffer {
    // Cell structure: positionAndRadius, velocityAndMass, acceleration
    ComputeCell cellData[];
};

layout(std430, binding = 1) restrict buffer modeBuffer {
    GPUMode modes[];
};

// Output: Compact instance data for rendering
layout(std430, binding = 2) buffer InstanceBuffer {
    InstanceData instanceData[]; // Only position, radius and color
};

layout(std430, binding = 3) buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    uint freeAdhesionTop;
};

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    if (index >= totalCellCount) return;
    
    // Skip dead cells (mass = 0)
    if (cellData[index].positionAndMass.w <= 0.0) {
        // Set radius to 0 so it won't be rendered
        instanceData[index].positionAndRadius = vec4(0.0, 0.0, 0.0, 0.0);
        return;
    }
    
    float myRadius = pow(cellData[index].positionAndMass.w, 1./3.);
    instanceData[index].positionAndRadius = vec4(cellData[index].positionAndMass.xyz, myRadius);
    
    instanceData[index].color = modes[cellData[index].modeIndex].color;
    instanceData[index].orientation = cellData[index].orientation;
}

