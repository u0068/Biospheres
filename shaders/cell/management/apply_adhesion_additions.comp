#version 430
#extension GL_ARB_gpu_shader_int64 : enable

layout(local_size_x = 64) in;

struct ComputeAdhesion {
    uint cellIndexA;        // Index of first connected cell
    uint cellIndexB;        // Index of second connected cell
    float breakForce;       // Force required to break the adhesion
    float restLength;       // Rest length of the adhesion
    float linearSpringStiffness;  // Spring stiffness
    float linearSpringDamping;    // Spring damping
    float orientationSpringStrength; // Orientation spring strength
    float maxAngularDeviation;    // Maximum angular deviation (radians)
    uint isActive;          // Whether this adhesion is active (1) or broken (0)
    uint padding[3];        // Padding for 16-byte alignment
};

layout(std430, binding = 0) buffer AdhesionAdditionQueue {
    uint cellIndexA[100000];
    uint cellIndexB[100000];
    float breakForce[100000];
    float restLength[100000];
    float linearSpringStiffness[100000];
    float linearSpringDamping[100000];
    float orientationSpringStrength[100000];
    float maxAngularDeviation[100000];
    uint isActive[100000];
    uint padding[3];
};

layout(std430, binding = 1) buffer AdhesionInputBuffer {
    ComputeAdhesion inputAdhesions[];
};

layout(std430, binding = 2) buffer AdhesionOutputBuffer {
    ComputeAdhesion outputAdhesions[];
};

layout(std430, binding = 3) buffer AdhesionCountBuffer {
    uint adhesionCount;
    uint pendingAdhesionCount;
};

uniform int u_maxAdhesions;

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= pendingAdhesionCount) return;

    // Calculate target index based on current adhesion count + queue index
    uint targetIndex = adhesionCount + index;
    
    // Check bounds
    if (targetIndex >= uint(u_maxAdhesions)) return;
    
    // Copy existing adhesions to output buffer
    if (index < adhesionCount) {
        outputAdhesions[index] = inputAdhesions[index];
    }
    
    // Add new adhesion at the end
    outputAdhesions[targetIndex].cellIndexA = cellIndexA[index];
    outputAdhesions[targetIndex].cellIndexB = cellIndexB[index];
    outputAdhesions[targetIndex].breakForce = breakForce[index];
    outputAdhesions[targetIndex].restLength = restLength[index];
    outputAdhesions[targetIndex].linearSpringStiffness = linearSpringStiffness[index];
    outputAdhesions[targetIndex].linearSpringDamping = linearSpringDamping[index];
    outputAdhesions[targetIndex].orientationSpringStrength = orientationSpringStrength[index];
    outputAdhesions[targetIndex].maxAngularDeviation = maxAngularDeviation[index];
    outputAdhesions[targetIndex].isActive = isActive[index];
} 