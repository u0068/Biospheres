#version 430 core
#extension GL_ARB_gpu_shader_int64 : enable

// Optimized work group size for better GPU utilization
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass; // x, y, z, mass
    vec4 velocity;        // Fixed to match CPU layout
    vec4 acceleration;    // Fixed to match CPU layout
    vec4 orientation; // angular stuff in quaternion to prevent gimbal lock
    vec4 angularVelocity;
    vec4 angularAcceleration;
    // Internal:
    vec4 signallingSubstances; // 4 substances for now
    int modeIndex;
    float age; // also used for split timer
    float toxins;
    float nitrates;
    // Unique ID system
    uint64_t uniqueID;     // Packed ID: [parent(32)] [cell(31)] [child(1)]
    uint64_t padding1;     // Padding to maintain alignment
    uint padding2[4];    // Additional padding to ensure 16-byte alignment
};

// Parent-children mapping structure
struct ParentChildren {
    uint childAIndex;
    uint childBIndex;
    uint isActive;
    uint padding;
};

// Shader storage buffer objects
layout(std430, binding = 0) restrict buffer CellInputBuffer {
    ComputeCell inputCells[];  // Previous frame cell data (read-only)
};

layout(std430, binding = 1) restrict buffer ParentChildrenBuffer {
    ParentChildren parentChildrenTable[];  // O(1) parent-to-children lookup
};

layout(std430, binding = 2) restrict buffer CellOutputBuffer {
    ComputeCell outputCells[];  // Current frame cell data (write-only)
};

layout(std430, binding = 3) buffer CellCountBuffer {
    uint cellCount;
};

// Physics parameters for child pairs
uniform float u_childPairAttractionStrength = 50.0;  // How strongly children attract each other
uniform float u_childPairRepulsionDistance = 2.0;    // Distance at which children start repelling
uniform float u_childPairMaxDistance = 10.0;         // Maximum distance for child pair interactions
uniform float u_childPairDamping = 0.95;             // Velocity damping for child pairs

// Extract parent ID from unique ID
uint getParentID(uint64_t uniqueID) {
    return uint((uniqueID >> 32) & 0xFFFFFFFF);
}

// Extract child flag from unique ID (0 = child A, 1 = child B)
uint getChildFlag(uint64_t uniqueID) {
    return uint(uniqueID & 0x1);
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    // Check bounds
    if (index >= cellCount) {
        return;
    }
    
    // Copy input cell data to output
    outputCells[index] = inputCells[index];
    
    // Skip cells with no parent (initial spawned cells)
    uint parentID = getParentID(inputCells[index].uniqueID);
    if (parentID == 0) {
        return;
    }
    
    // Only process child A (child flag = 0) to avoid duplicate processing
    uint childFlag = getChildFlag(inputCells[index].uniqueID);
    if (childFlag != 0) {
        return; // Skip child B
    }
    
    // O(1) lookup using the parent-children buffer!
    ParentChildren parentEntry = parentChildrenTable[parentID];
    
    // Check if this parent has both children
    if (parentEntry.isActive == 0 || parentEntry.childAIndex == 0xFFFFFFFF || parentEntry.childBIndex == 0xFFFFFFFF) {
        return; // No complete pair
    }
    
    // Verify we're the child A for this parent
    if (parentEntry.childAIndex != index) {
        return; // Not our parent
    }
    
    // Get child B data
    uint childBIndex = parentEntry.childBIndex;
    if (childBIndex >= cellCount) {
        return; // Invalid index
    }
    
    ComputeCell childBCell = inputCells[childBIndex];
    
    // Verify child B has the same parent
    uint childBParentID = getParentID(childBCell.uniqueID);
    if (childBParentID != parentID) {
        return; // Invalid parent-child relationship
    }
    
    // Calculate physics between child pairs
    vec3 childAPos = inputCells[index].positionAndMass.xyz;
    vec3 childBPos = childBCell.positionAndMass.xyz;
    vec3 delta = childBPos - childAPos;
    float distance = length(delta);
    
    // Skip if children are too far apart
    if (distance > u_childPairMaxDistance) {
        return;
    }
    
    // Calculate forces based on distance
    vec3 force = vec3(0.0);
    
    if (distance > 0.001) { // Avoid division by zero
        vec3 direction = normalize(delta);
        
        if (distance < u_childPairRepulsionDistance) {
            // Repulsion force when too close
            float overlap = u_childPairRepulsionDistance - distance;
            force = -direction * overlap * u_childPairAttractionStrength * 2.0;
        } else {
            // Attraction force when at reasonable distance
            float attraction = u_childPairAttractionStrength * (1.0 - distance / u_childPairMaxDistance);
            force = direction * attraction;
        }
        
        // Apply damping to velocities
        vec3 childAVel = inputCells[index].velocity.xyz;
        vec3 childBVel = childBCell.velocity.xyz;
        
        // Apply forces to both children (equal and opposite)
        float childAMass = inputCells[index].positionAndMass.w;
        float childBMass = childBCell.positionAndMass.w;
        
        // Update acceleration for child A
        outputCells[index].acceleration.xyz += force / childAMass;
        
        // Update acceleration for child B (opposite force)
        outputCells[childBIndex].acceleration.xyz -= force / childBMass;
        
        // Apply velocity damping to both children
        outputCells[index].velocity.xyz *= u_childPairDamping;
        outputCells[childBIndex].velocity.xyz *= u_childPairDamping;
    }
} 