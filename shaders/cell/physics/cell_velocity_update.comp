#version 430 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass;   // x, y, z, mass
    vec4 velocity;          // x, y, z, padding
    vec4 acceleration;      // x, y, z, padding
    vec4 prevAcceleration;  // x, y, z, padding
    vec4 orientation;       // Quaternion to (prevent gimbal lock)
    vec4 angularVelocity;   // Pseudo-vector for easy math
    vec4 angularAcceleration;       // Pseudo-vector for easy math
    vec4 prevAngularAcceleration;   // Pseudo-vector for easy math
    // Internal:
    vec4 signallingSubstances; // 4 substances for now
    int modeIndex;  // absolute index of the cell's mode
    float age; // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
};

// Shader storage buffer objects
layout(std430, binding = 0) restrict buffer ReadCellBuffer {
    ComputeCell inputCells[];
};

layout(std430, binding = 1) restrict buffer WriteCellBuffer {
    ComputeCell outputCells[];
};

layout(std430, binding = 2) coherent buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    uint freeAdhesionTop;
};

// Uniforms
uniform float u_deltaTime;
uniform float u_damping;
uniform int u_draggedCellIndex; // Index of cell being dragged (-1 if none)

// Quaternion multiplication function
vec4 quatMultiply(vec4 q1, vec4 q2) {
    return vec4(
        q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y,
        q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x,
        q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w,
        q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z
    );
}

// Velocity + angular velocity update
void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= totalCellCount) return;
    if (int(index) == u_draggedCellIndex) return;

    ComputeCell cell = inputCells[index];
    cell.age += u_deltaTime * 0.5;

    // --- Linear verlet velocity ---
    vec3 vel = cell.velocity.xyz;
    vec3 acc_old = cell.prevAcceleration.xyz;
    vec3 acc_new = cell.acceleration.xyz;

    vel += 0.5 * (acc_old + acc_new) * u_deltaTime;
    vel *= pow(u_damping, u_deltaTime * 100.0);

    cell.velocity.xyz = vel;

    // --- Angular verlet velocity ---
    vec3 w = cell.angularVelocity.xyz;
    vec3 alpha_old = cell.prevAngularAcceleration.xyz;
    vec3 alpha_new = cell.angularAcceleration.xyz;

    w += 0.5 * (alpha_old + alpha_new) * u_deltaTime;
    w *= pow(u_damping, u_deltaTime * 100.0);

    cell.angularVelocity.xyz = w;

    outputCells[index] = cell;
}

