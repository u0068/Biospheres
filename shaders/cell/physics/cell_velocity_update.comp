#version 430 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass;   // x, y, z, mass
    vec4 velocity;          // x, y, z, padding
    vec4 acceleration;      // x, y, z, padding
    vec4 prevAcceleration;  // x, y, z, padding
    vec4 orientation;       // Quaternion to (prevent gimbal lock)
    vec4 genomeOrientation; // Quaternion for genome-derived orientation - NEVER affected by physics
    vec4 angularVelocity;   // Pseudo-vector for easy math
    vec4 angularAcceleration;       // Pseudo-vector for easy math
    vec4 prevAngularAcceleration;   // Pseudo-vector for easy math
    // Internal:
    vec4 signallingSubstances; // 4 substances for now
    int modeIndex;  // absolute index of the cell's mode
    float age; // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
    
    // Padding to maintain 16-byte alignment for the entire struct
    uint _padding[4];
};

// Shader storage buffer objects
layout(std430, binding = 0) restrict buffer ReadCellBuffer {
    ComputeCell inputCells[];
};

layout(std430, binding = 1) restrict buffer WriteCellBuffer {
    ComputeCell outputCells[];
};

layout(std430, binding = 2) coherent buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    uint freeAdhesionTop;
};

// Uniforms
uniform float u_deltaTime;
uniform float u_damping;
uniform int u_draggedCellIndex; // Index of cell being dragged (-1 if none)

// Sphere barrier uniforms
uniform float u_sphereRadius;
uniform vec3 u_sphereCenter;
uniform bool u_enableVelocityBarrier;
uniform float u_barrierDamping;
uniform float u_barrierPushDistance;

// Quaternion multiplication function
vec4 quatMultiply(vec4 q1, vec4 q2) {
    return vec4(
        q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y,
        q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x,
        q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w,
        q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z
    );
}

// Velocity + angular velocity update
void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= totalCellCount) return;
    if (int(index) == u_draggedCellIndex) return;

    ComputeCell cell = inputCells[index];
    cell.age += u_deltaTime * 0.5;

    // --- Linear verlet velocity ---
    vec3 vel = cell.velocity.xyz;
    vec3 acc_old = cell.prevAcceleration.xyz;
    vec3 acc_new = cell.acceleration.xyz;

    vel += 0.5 * (acc_old + acc_new) * u_deltaTime;
    vel *= pow(u_damping, u_deltaTime * 100.0);
    
    // --- Velocity Barrier Logic ---
    if (u_enableVelocityBarrier) {
        vec3 cellPos = cell.positionAndMass.xyz;
        float distanceFromCenter = length(cellPos - u_sphereCenter);
        
        // Check if cell is outside or very close to the sphere boundary
        if (distanceFromCenter > u_sphereRadius - u_barrierPushDistance) {
            // Calculate direction from sphere center to cell
            vec3 outwardDirection = normalize(cellPos - u_sphereCenter);
            
            // Check if velocity is pointing outward (away from center)
            float outwardVelocity = dot(vel, outwardDirection);
            
            if (outwardVelocity > 0.0) {
                // Reverse the outward component of velocity
                vel -= outwardDirection * outwardVelocity * 2.0;
                
                // Apply additional damping
                vel *= u_barrierDamping;
                
                // Add small inward push to prevent getting stuck
                vel -= outwardDirection * 0.5;
            }
            
            // If cell is already outside, push it back inside
            if (distanceFromCenter > u_sphereRadius) {
                vec3 pushDirection = -outwardDirection;
                float pushStrength = (distanceFromCenter - u_sphereRadius) * 2.0;
                vel += pushDirection * pushStrength;
            }
        }
    }

    cell.velocity.xyz = vel;
    //cell.acceleration = vec4(0.0);

    // --- Angular verlet velocity ---
    vec3 w = cell.angularVelocity.xyz;
    vec3 alpha_old = cell.prevAngularAcceleration.xyz;
    vec3 alpha_new = cell.angularAcceleration.xyz;

    w += 0.5 * (alpha_old + alpha_new) * u_deltaTime;
    w *= pow(u_damping, u_deltaTime * 100.0);

    cell.angularVelocity.xyz = w;
    //cell.angularAcceleration = vec4(0.0);

    outputCells[index] = cell;
}

