#version 430 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass;   // x, y, z, mass
    vec4 velocity;          // x, y, z, padding
    vec4 acceleration;      // x, y, z, padding
    vec4 prevAcceleration;  // x, y, z, padding
    vec4 orientation;       // Quaternion to (prevent gimbal lock)
    vec4 angularVelocity;   // Pseudo-vector for easy math
    vec4 angularAcceleration;       // Pseudo-vector for easy math
    vec4 prevAngularAcceleration;   // Pseudo-vector for easy math
    // Internal:
    vec4 signallingSubstances; // 4 substances for now
    int modeIndex;  // absolute index of the cell's mode
    float age; // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
};

// Shader storage buffer objects
layout(std430, binding = 0) restrict buffer ReadCellBuffer {
    ComputeCell inputCells[];
};

layout(std430, binding = 1) restrict buffer WriteCellBuffer {
    ComputeCell outputCells[];
};

layout(std430, binding = 2) coherent buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    uint freeAdhesionTop;
};

// Uniforms
uniform float u_deltaTime;
uniform int u_draggedCellIndex; // Index of cell being dragged (-1 if none)

// Quaternion multiplication function
vec4 quatMultiply(vec4 q1, vec4 q2) {
    return vec4(
        q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y,
        q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x,
        q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w,
        q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z
    );
}

// Rotate quaternion by pseudovector
vec4 quatRotate(vec4 q, vec3 v) {
    float mag = length(v);
    
    if (mag > 0.001) {
        // Normalize angular velocity to get rotation axis
        vec3 rotationAxis = v / mag;
        
        // Create quaternion for this rotation
        float halfAngle = mag * 0.5;
        vec4 rotationQuat = vec4(rotationAxis * sin(halfAngle), cos(halfAngle));
        
        // Apply rotation to current orientation
        q = quatMultiply(rotationQuat, q);
        q = normalize(q);
    }

    return q;
}

// Position + orientation update
void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= totalCellCount) return;
    if (int(index) == u_draggedCellIndex) return;

    ComputeCell cell = inputCells[index];
    cell.age += u_deltaTime * 0.5;

    // --- Linear verlet position ---
    vec3 pos = cell.positionAndMass.xyz;
    vec3 vel = cell.velocity.xyz;
    vec3 acc = cell.acceleration.xyz;

    pos += vel * u_deltaTime + 0.5 * acc * (u_deltaTime * u_deltaTime);

    cell.positionAndMass.xyz = pos;
    cell.prevAcceleration = vec4(acc, 0.0);
    cell.acceleration = vec4(0.0);

    // --- Angular verlet orientation ---
    vec4 q = cell.orientation; // quaternion
    vec3 w = cell.angularVelocity.xyz;
    vec3 alpha = cell.angularAcceleration.xyz;

    // Predict angular velocity
    vec3 delta_orientation = w * u_deltaTime;// + 0.5 * alpha * u_deltaTime * u_deltaTime;

    q = quatRotate(q, delta_orientation);

    cell.orientation = q;
    cell.prevAngularAcceleration = vec4(alpha, 0.0);
    cell.angularAcceleration = vec4(0.0);

    outputCells[index] = cell;
}
