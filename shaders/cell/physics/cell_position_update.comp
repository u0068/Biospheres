#version 430 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass;   // x, y, z, mass
    vec4 velocity;          // x, y, z, padding
    vec4 acceleration;      // x, y, z, padding
    vec4 prevAcceleration;  // x, y, z, padding
    vec4 orientation;       // Quaternion to (prevent gimbal lock)
    vec4 angularVelocity;   // Pseudo-vector for easy math
    vec4 angularAcceleration;       // Pseudo-vector for easy math
    vec4 prevAngularAcceleration;   // Pseudo-vector for easy math
    // Internal:
    vec4 signallingSubstances; // 4 substances for now
    int modeIndex;  // absolute index of the cell's mode
    float age; // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
    
    // Lineage tracking (AA.BB.C format)
    uint parentLineageId;       // AA: Parent's unique ID (0 for root cells)
    uint uniqueId;              // BB: This cell's unique ID
    uint childNumber;           // C: Child number (1 or 2, 0 for root cells)
    uint _lineagePadding;       // Padding to maintain 16-byte alignment
};

// Shader storage buffer objects
layout(std430, binding = 0) restrict buffer ReadCellBuffer {
    ComputeCell inputCells[];
};

layout(std430, binding = 1) restrict buffer WriteCellBuffer {
    ComputeCell outputCells[];
};

layout(std430, binding = 2) coherent buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    uint freeAdhesionTop;
};

// Uniforms
uniform float u_deltaTime;
uniform int u_draggedCellIndex; // Index of cell being dragged (-1 if none)
uniform float u_worldSize; // World boundary size

// Quaternion multiplication function
vec4 quatMultiply(vec4 q1, vec4 q2) {
    return vec4(
        q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y,
        q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x,
        q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w,
        q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z
    );
}

// Rotate quaternion by pseudovector
vec4 quatRotate(vec4 q, vec3 v) {
    float mag = length(v);
    
    if (mag > 0.001) {
        // Normalize angular velocity to get rotation axis
        vec3 rotationAxis = v / mag;
        
        // Create quaternion for this rotation
        float halfAngle = mag * 0.5;
        vec4 rotationQuat = vec4(rotationAxis * sin(halfAngle), cos(halfAngle));
        
        // Apply rotation to current orientation
        q = quatMultiply(rotationQuat, q);
        q = normalize(q);
    }

    return q;
}

// Position + orientation update
void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= totalCellCount) return;
    if (int(index) == u_draggedCellIndex) return;

    ComputeCell cell = inputCells[index];
    cell.age += u_deltaTime * 0.5;

    // --- Linear verlet position ---
    vec3 pos = cell.positionAndMass.xyz;
    vec3 vel = cell.velocity.xyz;
    vec3 acc = cell.acceleration.xyz;

    pos += vel * u_deltaTime + 0.5 * acc * (u_deltaTime * u_deltaTime);

    // Apply boundary containment with velocity reversal and rolling contact
    float halfWorld = u_worldSize * 0.5;
    float cellRadius = pow(cell.positionAndMass.w, 1.0/3.0);
    vec3 w = cell.angularVelocity.xyz;
    
    // Rolling friction coefficient for walls
    float wallFriction = 0.3;
    
    // Check each axis and apply rolling contact mechanics
    // X-axis boundaries
    if (pos.x - cellRadius < -halfWorld) {
        pos.x = -halfWorld + cellRadius;
        vel.x = -vel.x * 0.5; // Reverse and dampen normal velocity
        
        // Rolling contact: apply torque from tangential velocity
        vec3 contactNormal = vec3(1.0, 0.0, 0.0); // Wall normal points inward
        vec3 tangentialVel = vel - dot(vel, contactNormal) * contactNormal;
        vec3 contactOffset = vec3(-cellRadius, 0.0, 0.0); // Contact point relative to center
        
        // Torque from friction: τ = r × F, where F opposes tangential motion
        vec3 frictionTorque = cross(contactOffset, -tangentialVel * wallFriction);
        w += frictionTorque * u_deltaTime / (cellRadius * cellRadius); // Apply torque impulse
        
    } else if (pos.x + cellRadius > halfWorld) {
        pos.x = halfWorld - cellRadius;
        vel.x = -vel.x * 0.5;
        
        vec3 contactNormal = vec3(-1.0, 0.0, 0.0);
        vec3 tangentialVel = vel - dot(vel, contactNormal) * contactNormal;
        vec3 contactOffset = vec3(cellRadius, 0.0, 0.0);
        vec3 frictionTorque = cross(contactOffset, -tangentialVel * wallFriction);
        w += frictionTorque * u_deltaTime / (cellRadius * cellRadius);
    }
    
    // Y-axis boundaries
    if (pos.y - cellRadius < -halfWorld) {
        pos.y = -halfWorld + cellRadius;
        vel.y = -vel.y * 0.5;
        
        vec3 contactNormal = vec3(0.0, 1.0, 0.0);
        vec3 tangentialVel = vel - dot(vel, contactNormal) * contactNormal;
        vec3 contactOffset = vec3(0.0, -cellRadius, 0.0);
        vec3 frictionTorque = cross(contactOffset, -tangentialVel * wallFriction);
        w += frictionTorque * u_deltaTime / (cellRadius * cellRadius);
        
    } else if (pos.y + cellRadius > halfWorld) {
        pos.y = halfWorld - cellRadius;
        vel.y = -vel.y * 0.5;
        
        vec3 contactNormal = vec3(0.0, -1.0, 0.0);
        vec3 tangentialVel = vel - dot(vel, contactNormal) * contactNormal;
        vec3 contactOffset = vec3(0.0, cellRadius, 0.0);
        vec3 frictionTorque = cross(contactOffset, -tangentialVel * wallFriction);
        w += frictionTorque * u_deltaTime / (cellRadius * cellRadius);
    }
    
    // Z-axis boundaries
    if (pos.z - cellRadius < -halfWorld) {
        pos.z = -halfWorld + cellRadius;
        vel.z = -vel.z * 0.5;
        
        vec3 contactNormal = vec3(0.0, 0.0, 1.0);
        vec3 tangentialVel = vel - dot(vel, contactNormal) * contactNormal;
        vec3 contactOffset = vec3(0.0, 0.0, -cellRadius);
        vec3 frictionTorque = cross(contactOffset, -tangentialVel * wallFriction);
        w += frictionTorque * u_deltaTime / (cellRadius * cellRadius);
        
    } else if (pos.z + cellRadius > halfWorld) {
        pos.z = halfWorld - cellRadius;
        vel.z = -vel.z * 0.5;
        
        vec3 contactNormal = vec3(0.0, 0.0, -1.0);
        vec3 tangentialVel = vel - dot(vel, contactNormal) * contactNormal;
        vec3 contactOffset = vec3(0.0, 0.0, cellRadius);
        vec3 frictionTorque = cross(contactOffset, -tangentialVel * wallFriction);
        w += frictionTorque * u_deltaTime / (cellRadius * cellRadius);
    }
    
    cell.angularVelocity.xyz = w; // Update angular velocity after wall collisions

    cell.positionAndMass.xyz = pos;
    cell.velocity.xyz = vel; // Update velocity after boundary check
    cell.prevAcceleration = vec4(acc, 0.0);
    cell.acceleration = vec4(0.0);

    // --- Angular verlet orientation ---
    vec4 q = cell.orientation; // quaternion
    // w already updated from wall collisions above
    vec3 alpha = cell.angularAcceleration.xyz;

    // Predict angular velocity
    vec3 delta_orientation = w * u_deltaTime;// + 0.5 * alpha * u_deltaTime * u_deltaTime;

    q = quatRotate(q, delta_orientation);

    cell.orientation = q;
    cell.prevAngularAcceleration = vec4(alpha, 0.0);
    cell.angularAcceleration = vec4(0.0);

    outputCells[index] = cell;
}
