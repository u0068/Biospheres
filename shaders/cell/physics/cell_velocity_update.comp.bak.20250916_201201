#version 430 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass; // x, y, z, mass
    vec4 velocity;
    vec4 acceleration;
    vec4 orientation;     // angular stuff in quaternion to prevent gimbal lock
    vec4 angularVelocity;
    vec4 angularAcceleration;
    // Internal:
    vec4 signallingSubstances; // 4 substances for now
    int modeIndex;  // absolute index of the cell's mode
    float age; // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
};

// Shader storage buffer objects
layout(std430, binding = 0) restrict buffer ReadCellBuffer {
    ComputeCell inputCells[];
};

layout(std430, binding = 1) restrict buffer WriteCellBuffer {
    ComputeCell outputCells[];
};

layout(std430, binding = 2) coherent buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    uint freeAdhesionTop;
};

// Uniforms
uniform float u_deltaTime;
uniform float u_damping;
uniform int u_draggedCellIndex; // Index of cell being dragged (-1 if none)

// Quaternion multiplication function
vec4 quatMultiply(vec4 q1, vec4 q2) {
    return vec4(
        q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y,
        q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x,
        q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w,
        q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z
    );
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= totalCellCount) return;

    ComputeCell cell = inputCells[index];

    vec3 vel = cell.velocity.xyz;
    vec3 acc_old = cell.previousAcceleration.xyz; // store old acceleration somewhere safe
    vec3 acc_new = cell.acceleration.xyz;        // recomputed in between passes

    // Update velocity
    vel += 0.5 * (acc_old + acc_new) * u_deltaTime;

    // Apply damping
    vel *= pow(u_damping, u_deltaTime * 100.0);

    cell.velocity.xyz = vel;

    outputCells[index] = cell;
}