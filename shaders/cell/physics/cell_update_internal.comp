#version 430 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass;   // x, y, z, mass
    vec4 velocity;          // x, y, z, padding
    vec4 acceleration;      // x, y, z, padding
    vec4 prevAcceleration;  // x, y, z, padding
    vec4 orientation;       // Quaternion to (prevent gimbal lock)
    vec4 angularVelocity;   // Pseudo-vector for easy math
    vec4 angularAcceleration;       // Pseudo-vector for easy math
    vec4 prevAngularAcceleration;   // Pseudo-vector for easy math
    // Internal:
    vec4 signallingSubstances;  // 4 substances for now
    int modeIndex;              // absolute index of the cell's mode
    float age;                  // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
    
    // Lineage tracking (AA.BB.C format)
    uint parentLineageId;       // AA: Parent's unique ID (0 for root cells)
    uint uniqueId;              // BB: This cell's unique ID
    uint childNumber;           // C: Child number (1 or 2, 0 for root cells)
    uint _lineagePadding;       // Padding to maintain 16-byte alignment
};

struct GPUModeAdhesionSettings
{
    int canBreak;                 // bool -> int (4 bytes)
    float breakForce;
    float restLength;
    float linearSpringStiffness;
    float linearSpringDamping;
    float orientationSpringStiffness;
    float orientationSpringDamping;
    float maxAngularDeviation;
    float twistConstraintStiffness;
    float twistConstraintDamping;
    int enableTwistConstraint;    // bool -> int (4 bytes)
    int _padding;                 // pad to 48 bytes
};

// GPU Mode structure
struct GPUMode {
    vec4 color;           // R, G, B, padding
    vec4 orientationA;    // Quaternion
    vec4 orientationB;    // Quaternion
    vec4 splitDirection;  // x, y, z, padding
    ivec2 childModes;     // mode indices for children
    float splitInterval;
    int genomeOffset;
    GPUModeAdhesionSettings adhesionSettings;
    int parentMakeAdhesion; // Boolean flag for adhesion creation
    int childAKeepAdhesion; // Boolean flag for child A to keep adhesion
    int childBKeepAdhesion; // Boolean flag for child B to keep adhesion
    int maxAdhesions;       // Max number of adhesions
};

// Adhesion connection structure - stores permanent connections between sibling cells
struct AdhesionConnection {
    uint cellAIndex;      // Index of first cell in the connection
    uint cellBIndex;      // Index of second cell in the connection
    uint modeIndex;       // Mode index for the connection ( to lookup adhesion settings )
    uint isActive;        // Whether this connection is still active (1 = active, 0 = inactive)
    uint zoneA;           // Zone classification for cell A (0=ZoneA, 1=ZoneB, 2=ZoneC)
    uint zoneB;           // Zone classification for cell B (0=ZoneA, 1=ZoneB, 2=ZoneC)
    uint sourceChildNumA; // Child number that created this bond for cell A (1 or 2, 0 if not from child)
    uint sourceChildNumB; // Child number that created this bond for cell B (1 or 2, 0 if not from child)
    vec3 anchorDirectionA; // Anchor direction for cell A in local cell space (normalized)
    float paddingA;       // Padding to ensure 16-byte alignment
    vec3 anchorDirectionB; // Anchor direction for cell B in local cell space (normalized)
    float paddingB;       // Padding to ensure 16-byte alignment
    vec4 twistReferenceA; // Reference quaternion for twist constraint for cell A (16 bytes)
    vec4 twistReferenceB; // Reference quaternion for twist constraint for cell B (16 bytes)
    uint _padding[2];     // Padding to ensure 16-byte alignment (96 bytes total)
};

// Enhanced diagnostic entry structure - matches C++ EnhancedDiagnosticEntry
struct EnhancedDiagnosticEntry {
    // Core event data
    uint eventType;           // DiagnosticEventType
    uint frameIndex;          // Frame when event occurred
    uint cellA;               // Primary cell involved
    uint cellB;               // Secondary cell (if applicable, -1 otherwise)

    // Event-specific data
    uint connectionIndex;     // For adhesion events
    uint modeIndex;           // Mode of primary cell
    uint splitEventID;        // Groups related split events
    uint parentCellID;        // For inheritance tracking

    // Spatial data
    float positionA[3];       // Position of cell A
    float positionB[3];       // Position of cell B (if applicable)
    float anchorDirA[3];      // Anchor direction for cell A
    float anchorDirB[3];      // Anchor direction for cell B

    // Physics data
    float velocityA[3];       // Velocity of cell A
    float velocityB[3];       // Velocity of cell B (if applicable)
    float massA;              // Mass of cell A
    float massB;              // Mass of cell B (if applicable)

    // Cell state data
    float ageA;               // Age of cell A
    float ageB;               // Age of cell B (if applicable)
    float toxinsA;            // Toxin level of cell A
    float toxinsB;            // Toxin level of cell B (if applicable)
    float nitratesA;          // Nitrate level of cell A
    float nitratesB;          // Nitrate level of cell B (if applicable)

    // Signaling substances
    float signallingA[4];     // Signalling substances of cell A
    float signallingB[4];     // Signalling substances of cell B

    // Lineage data for cell A
    uint lineageA_parentId;   // Parent unique ID for cell A
    uint lineageA_uniqueId;   // Unique ID for cell A
    uint lineageA_childNum;   // Child number for cell A

    // Lineage data for cell B
    uint lineageB_parentId;   // Parent unique ID for cell B
    uint lineageB_uniqueId;   // Unique ID for cell B
    uint lineageB_childNum;   // Child number for cell B

    // Additional event data
    float eventValue1;        // Generic event-specific value 1
    float eventValue2;        // Generic event-specific value 2
    uint eventFlags;          // Bit flags for event properties

    // Padding to ensure 16-byte alignment (added 6 uint32_t fields = 24 bytes)
    float _padding[1];
};

layout(std430, binding = 0) restrict buffer ReadCellBuffer {
    ComputeCell inputCells[];
};

layout(std430, binding = 1) restrict buffer modeBuffer {
    GPUMode modes[];
};

layout(std430, binding = 2) restrict buffer WriteCellBuffer {
    ComputeCell outputCells[];
};

layout(std430, binding = 3) coherent buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    int freeAdhesionTop;
};

layout(std430, binding = 4) coherent buffer AdhesionConnectionBuffer {
    AdhesionConnection connections[];
};

layout(std430, binding = 5) coherent buffer freeCellSlotBuffer {
    uint freeCellSlotIndices[];
};

layout(std430, binding = 6) coherent buffer freeAdhesionSlotBuffer {
    uint freeAdhesionSlotIndices[];
};

layout(std430, binding = 7) coherent buffer EnhancedDiagnosticBuffer {
    EnhancedDiagnosticEntry diagnosticEntries[];
};

layout(std430, binding = 8) coherent buffer DiagnosticCountBuffer {
    uint diagnosticCount;
};

layout(std430, binding = 9) coherent buffer UniqueIdBuffer {
    uint nextUniqueId;
};

uniform float u_deltaTime;
uniform int u_maxCells;
uniform int u_maxAdhesions;
uniform int u_enableAdhesionDiagnostics;
uniform int u_currentFrame;

vec4 quatMultiply(vec4 q1, vec4 q2) {
    return vec4(
        q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y,
        q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x,
        q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w,
        q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z
    );
}

// Classify bond direction into zones (A, B, C) based on angle from split direction
// Based on Unity CellAdhesionManager classification logic
uint classifyBondDirection(vec3 bondDirLocal, vec3 splitDirLocal, float inheritanceAngleDeg) {
    float dot = dot(bondDirLocal, splitDirLocal);
    float angle = acos(clamp(dot, -1.0, 1.0)) * 180.0 / 3.141592653589793; // Convert to degrees
    float halfWidth = inheritanceAngleDeg * 1.0;
    float equatorialAngle = 90.0;

    if (abs(angle - equatorialAngle) <= halfWidth)
        return 2u; // Zone C (equatorial)
    else if (dot > 0.0)
        return 1u; // Zone B (positive dot product)
    else
        return 0u; // Zone A (negative dot product)
}

vec3 rotateVectorByQuaternion(vec3 v, vec4 q) {
    // v' = q * v * q^-1
    // Optimized version using cross product:
    vec3 u = q.xyz;
    float s = q.w;

    return 2.0 * dot(u, v) * u
         + (s * s - dot(u, u)) * v
         + 2.0 * s * cross(u, v);
}

vec4 quatInverse(vec4 q) {
    float norm = dot(q, q);
    if (norm > 0.0) {
        return vec4(-q.xyz, q.w) / norm;
    }
    return vec4(0.0, 0.0, 0.0, 1.0);
}

// Hash function to generate a pseudo-random float in [0,1] from a uint seed
float hash11(uint n) {
    n = (n ^ 61u) ^ (n >> 16u);
    n *= 9u;
    n = n ^ (n >> 4u);
    n *= 0x27d4eb2du;
    n = n ^ (n >> 15u);
    return float(n & 0x00FFFFFFu) / float(0x01000000u);
}

// Create a small random quaternion for a tiny rotation (angle in radians)
vec4 smallRandomQuat(float angle, uint seed) {
    // Random axis
    float rand1 = hash11(seed * 3u + 0u);
    float rand2 = hash11(seed * 3u + 1u);
    float rand3 = hash11(seed * 3u + 2u);
    vec3 axis = normalize(vec3(rand1, rand2, rand3) * 2.0 - 1.0);
    float halfAngle = angle * 0.5;
    float s = sin(halfAngle);
    return normalize(vec4(axis * s, cos(halfAngle)));
}

// Helper function to convert cell index to lineage ID (A.B.C format packed into uint)
uint getLineageIdFromIndex(uint cellIndex) {
    if (cellIndex >= inputCells.length()) return 0u;

    ComputeCell cell = inputCells[cellIndex];
    // Pack lineage ID as: (parentLineageId << 16) | (uniqueId << 8) | childNumber
    return (cell.parentLineageId << 16) | (cell.uniqueId << 8) | cell.childNumber;
}

// Function to log enhanced diagnostic entries
void logEnhancedDiagnostic(uint eventType, uint cellALineageId, uint cellBLineageId, uint connectionIndex,
                          uint modeIndex, uint splitEventID, uint parentCellLineageId,
                          vec3 anchorDirA, vec3 anchorDirB, float eventValue1, float eventValue2, uint eventFlags) {
    if (u_enableAdhesionDiagnostics == 0) return;

    // Atomically increment the counter and get the index
    uint index = atomicAdd(diagnosticCount, 1u);

    // Check if we have space in the buffer
    if (index >= diagnosticEntries.length()) return;

    // Create the enhanced diagnostic entry
    EnhancedDiagnosticEntry entry;

    // Core event data (store lineage IDs instead of indexes)
    entry.eventType = eventType;
    entry.frameIndex = uint(u_currentFrame);
    entry.cellA = cellALineageId;
    entry.cellB = cellBLineageId;

    // Event-specific data
    entry.connectionIndex = connectionIndex;
    entry.modeIndex = modeIndex;
    entry.splitEventID = splitEventID;
    entry.parentCellID = parentCellLineageId;

    // Get cell data for comprehensive logging (use lineage IDs to find cells)
    ComputeCell cellDataA;
    ComputeCell cellDataB;
    bool foundA = false, foundB = false;

    // Find cells by lineage ID (this is a simple linear search for diagnostic purposes)
    for (uint i = 0; i < totalCellCount && (!foundA || !foundB); ++i) {
        ComputeCell candidate = inputCells[i];
        uint candidateLineage = (candidate.parentLineageId << 16) | (candidate.uniqueId << 8) | candidate.childNumber;

        if (!foundA && candidateLineage == cellALineageId) {
            cellDataA = candidate;
            foundA = true;
        }
        if (!foundB && candidateLineage == cellBLineageId) {
            cellDataB = candidate;
            foundB = true;
        }
    }

    // Store lineage data for cell A (if found)
    if (foundA) {
        entry.lineageA_parentId = cellDataA.parentLineageId;
        entry.lineageA_uniqueId = cellDataA.uniqueId;
        entry.lineageA_childNum = cellDataA.childNumber;

        entry.positionA[0] = cellDataA.positionAndMass.x;
        entry.positionA[1] = cellDataA.positionAndMass.y;
        entry.positionA[2] = cellDataA.positionAndMass.z;
        entry.velocityA[0] = cellDataA.velocity.x;
        entry.velocityA[1] = cellDataA.velocity.y;
        entry.velocityA[2] = cellDataA.velocity.z;
        entry.massA = cellDataA.positionAndMass.w;
        entry.ageA = cellDataA.age;
        entry.toxinsA = cellDataA.toxins;
        entry.nitratesA = cellDataA.nitrates;
        entry.signallingA[0] = cellDataA.signallingSubstances.x;
        entry.signallingA[1] = cellDataA.signallingSubstances.y;
        entry.signallingA[2] = cellDataA.signallingSubstances.z;
        entry.signallingA[3] = cellDataA.signallingSubstances.w;
    } else {
        // Initialize cell A lineage data to invalid values
        entry.lineageA_parentId = 0xFFFFFFFF;
        entry.lineageA_uniqueId = 0xFFFFFFFF;
        entry.lineageA_childNum = 0xFFFFFFFF;
        entry.positionA[0] = 0.0; entry.positionA[1] = 0.0; entry.positionA[2] = 0.0;
        entry.velocityA[0] = 0.0; entry.velocityA[1] = 0.0; entry.velocityA[2] = 0.0;
        entry.massA = 0.0; entry.ageA = 0.0; entry.toxinsA = 0.0; entry.nitratesA = 0.0;
        entry.signallingA[0] = 0.0; entry.signallingA[1] = 0.0; entry.signallingA[2] = 0.0; entry.signallingA[3] = 0.0;
    }

    // Get second cell data if applicable
    if (cellBLineageId != 0xFFFFFFFF && foundB) {
        // Store lineage data for cell B
        entry.lineageB_parentId = cellDataB.parentLineageId;
        entry.lineageB_uniqueId = cellDataB.uniqueId;
        entry.lineageB_childNum = cellDataB.childNumber;

        entry.positionB[0] = cellDataB.positionAndMass.x;
        entry.positionB[1] = cellDataB.positionAndMass.y;
        entry.positionB[2] = cellDataB.positionAndMass.z;
        entry.velocityB[0] = cellDataB.velocity.x;
        entry.velocityB[1] = cellDataB.velocity.y;
        entry.velocityB[2] = cellDataB.velocity.z;
        entry.massB = cellDataB.positionAndMass.w;
        entry.ageB = cellDataB.age;
        entry.toxinsB = cellDataB.toxins;
        entry.nitratesB = cellDataB.nitrates;
        entry.signallingB[0] = cellDataB.signallingSubstances.x;
        entry.signallingB[1] = cellDataB.signallingSubstances.y;
        entry.signallingB[2] = cellDataB.signallingSubstances.z;
        entry.signallingB[3] = cellDataB.signallingSubstances.w;
    } else {
        // Initialize cell B lineage data to invalid values
        entry.lineageB_parentId = 0xFFFFFFFF;
        entry.lineageB_uniqueId = 0xFFFFFFFF;
        entry.lineageB_childNum = 0xFFFFFFFF;

        // Clear second cell data if not applicable
        entry.positionB[0] = 0.0f; entry.positionB[1] = 0.0f; entry.positionB[2] = 0.0f;
        entry.velocityB[0] = 0.0f; entry.velocityB[1] = 0.0f; entry.velocityB[2] = 0.0f;
        entry.massB = 0.0f; entry.ageB = 0.0f; entry.toxinsB = 0.0f; entry.nitratesB = 0.0f;
        entry.signallingB[0] = 0.0f; entry.signallingB[1] = 0.0f; entry.signallingB[2] = 0.0f; entry.signallingB[3] = 0.0f;
    }

    // Anchor directions
    entry.anchorDirA[0] = anchorDirA.x;
    entry.anchorDirA[1] = anchorDirA.y;
    entry.anchorDirA[2] = anchorDirA.z;
    entry.anchorDirB[0] = anchorDirB.x;
    entry.anchorDirB[1] = anchorDirB.y;
    entry.anchorDirB[2] = anchorDirB.z;

    // Event values
    entry.eventValue1 = eventValue1;
    entry.eventValue2 = eventValue2;
    entry.eventFlags = eventFlags;

    // Padding (7 floats for 16-byte alignment)
    for (int i = 0; i < 7; i++) {
        entry._padding[i] = 0.0f;
    }

    // Write the entry to the buffer
    diagnosticEntries[index] = entry;
}

// Legacy wrapper function for backward compatibility
void logAdhesionDiagnostic(uint connectionIndex, uint cellALineageId, uint cellBLineageId, uint modeIndex,
                          uint reasonCode, vec3 anchorDirA, vec3 anchorDirB,
                          uint frameIndex, uint splitEventID, uint parentCellLineageId,
                          uint inheritanceType, uint originalConnectionIndex, float adhesionZone) {
    // Map legacy reason codes to enhanced event types (adhesion events are 0-29)
    // For inherited connections, use eventFlags to store original connection index
    uint flags = 0u;
    if (reasonCode == 0) { // Inherited connection
        // Store original connection index in the upper 16 bits of eventFlags
        flags = (originalConnectionIndex << 16) | (inheritanceType & 0xFFFF);
    }
    logEnhancedDiagnostic(reasonCode, cellALineageId, cellBLineageId, connectionIndex, modeIndex,
                         splitEventID, parentCellLineageId, anchorDirA, anchorDirB,
                         adhesionZone, float(inheritanceType), flags);
}

uint getNewAdhesionIndex() {
    // Try to reserve a free adhesion slot
    // Snapshot free top value without modifying it first
    int freeTopBefore = freeAdhesionTop;
    if (freeTopBefore > 0) {
        // Now reserve slot *safely*
        int freeTop = atomicAdd(freeAdhesionTop, -1);
        if (freeTop > 0) {
            return freeAdhesionSlotIndices[freeTop - 1];
        } else {
            // Another thread raced and depleted the stack before we got here
            atomicAdd(freeAdhesionTop, 1); // revert
        }
    }

    // Fallback to allocating a new slot
    uint newAdhesionIndex = atomicAdd(totalAdhesionCount, 1);
    if (newAdhesionIndex >= u_maxAdhesions) {
        atomicMin(totalAdhesionCount, u_maxAdhesions);
        return -1;
    }
    return newAdhesionIndex;
}

// Add adhesion with preserved anchor directions (for inheritance)
// Returns the connection index on success, -1 on failure
int addAdhesionWithDirections(uint cellAIndex, uint cellBIndex, uint modeIndex, vec3 preservedAnchorA, vec3 preservedAnchorB, uint sourceChildA, uint sourceChildB) {
    uint newAdhesionIndex = getNewAdhesionIndex();
    if (newAdhesionIndex == uint(-1)) {
        // Failed to reserve an adhesion index
        return -1;
    }

    // Check for available slot in cell A
    int slotA = -1;
    for (int j = 0; j < 20; ++j) {
        if (outputCells[cellAIndex].adhesionIndices[j] < 0) {
            slotA = j;
            break;
        }
    }

    // Check for available slot in cell B
    int slotB = -1;
    for (int j = 0; j < 20; ++j) {
        if (outputCells[cellBIndex].adhesionIndices[j] < 0) {
            slotB = j;
            break;
        }
    }

    if (slotA == -1 || slotB == -1) {
        // Roll back the reservation if any cell has no free slot
        int reservation = atomicAdd(freeAdhesionTop, 1);
        int topIndex = reservation;
        freeAdhesionSlotIndices[topIndex] = newAdhesionIndex;
        return -1;
    }

    // Use the preserved anchor directions directly (already in local space)
    vec3 anchorDirectionA = preservedAnchorA;
    vec3 anchorDirectionB = preservedAnchorB;

    // Store current orientations as twist reference for constraint
    vec4 twistReferenceA = inputCells[cellAIndex].orientation;
    vec4 twistReferenceB = inputCells[cellBIndex].orientation;

    // Classify zones for both cells based on their split directions
    ComputeCell cellA = inputCells[cellAIndex];
    ComputeCell cellB = inputCells[cellBIndex];
    GPUMode modeA = modes[cellA.modeIndex];
    GPUMode modeB = modes[cellB.modeIndex];

    // Extract positions for zone classification
    vec3 posA = cellA.positionAndMass.xyz;
    vec3 posB = cellB.positionAndMass.xyz;

    // Classify zone for cell A (direction from A to B in A's local space)
    vec3 bondDirFromA = normalize(posB - posA);
    vec3 bondDirLocalA = rotateVectorByQuaternion(bondDirFromA, quatInverse(cellA.orientation));
    uint zoneA = classifyBondDirection(bondDirLocalA, modeA.splitDirection.xyz, 10.0); // Use 10° inheritance angle as default

    // Classify zone for cell B (direction from B to A in B's local space)
    vec3 bondDirFromB = normalize(posA - posB);
    vec3 bondDirLocalB = rotateVectorByQuaternion(bondDirFromB, quatInverse(cellB.orientation));
    uint zoneB = classifyBondDirection(bondDirLocalB, modeB.splitDirection.xyz, 10.0); // Use 10° inheritance angle as default

    // Write connection and assign indices with source child metadata
    connections[newAdhesionIndex] = AdhesionConnection(
        cellAIndex,
        cellBIndex,
        modeIndex,
        1, // isActive
        zoneA,
        zoneB,
        sourceChildA, // sourceChildNumA - which child created this for cell A
        sourceChildB, // sourceChildNumB - which child created this for cell B
        anchorDirectionA,
        0.0, // paddingA
        anchorDirectionB,
        0.0, // paddingB
        twistReferenceA,
        twistReferenceB,
        uint[2](0u, 0u) // padding to ensure 16-byte alignment
    );
    outputCells[cellAIndex].adhesionIndices[slotA] = int(newAdhesionIndex);
    outputCells[cellBIndex].adhesionIndices[slotB] = int(newAdhesionIndex);

    return int(newAdhesionIndex);
}

bool addAdhesion(uint cellAIndex, uint cellBIndex, uint modeIndex) {
    uint newAdhesionIndex = getNewAdhesionIndex();
    if (newAdhesionIndex == uint(-1)) {
        // Failed to reserve an adhesion index
        return false;
    }

    // Check for available slot in cell A
    int slotA = -1;
    for (int j = 0; j < 20; ++j) {
        if (outputCells[cellAIndex].adhesionIndices[j] < 0) {
            slotA = j;
            break;
        }
    }

    // Check for available slot in cell B
    int slotB = -1;
    for (int j = 0; j < 20; ++j) {
        if (outputCells[cellBIndex].adhesionIndices[j] < 0) {
            slotB = j;
            break;
        }
    }

    if (slotA == -1 || slotB == -1) {
        // Roll back the reservation if any cell has no free slot
        int reservation = atomicAdd(freeAdhesionTop, 1);
        int topIndex = reservation;
        freeAdhesionSlotIndices[topIndex] = newAdhesionIndex;
        return false;
    }

    // Calculate initial anchor directions in local cell space
    // Use spatial calculation since this is called immediately after split when positions are correct
    vec3 posA = inputCells[cellAIndex].positionAndMass.xyz;
    vec3 posB = inputCells[cellBIndex].positionAndMass.xyz;

    // Calculate direction vectors from each cell to the other in world space
    vec3 directionAtoB = normalize(posB - posA);
    vec3 directionBtoA = normalize(posA - posB);

    // Transform world space directions to local cell space using inverse cell orientations
    // This ensures anchors are stored relative to the cell's local coordinate system
    vec4 invOrientationA = quatInverse(inputCells[cellAIndex].orientation);
    vec4 invOrientationB = quatInverse(inputCells[cellBIndex].orientation);

    vec3 anchorDirectionA = rotateVectorByQuaternion(directionAtoB, invOrientationA);
    vec3 anchorDirectionB = rotateVectorByQuaternion(directionBtoA, invOrientationB);

    // Store current orientations as twist reference for constraint
    vec4 twistReferenceA = inputCells[cellAIndex].orientation;
    vec4 twistReferenceB = inputCells[cellBIndex].orientation;

    // Classify zones for both cells based on their split directions
    ComputeCell cellA = inputCells[cellAIndex];
    ComputeCell cellB = inputCells[cellBIndex];
    GPUMode modeA = modes[cellA.modeIndex];
    GPUMode modeB = modes[cellB.modeIndex];

    // Use already declared position variables for zone classification

    // Classify zone for cell A (direction from A to B in A's local space)
    vec3 bondDirFromA = normalize(posB - posA);
    vec3 bondDirLocalA = rotateVectorByQuaternion(bondDirFromA, quatInverse(cellA.orientation));
    uint zoneA = classifyBondDirection(bondDirLocalA, modeA.splitDirection.xyz, 10.0); // Use 10° inheritance angle as default

    // Classify zone for cell B (direction from B to A in B's local space)
    vec3 bondDirFromB = normalize(posA - posB);
    vec3 bondDirLocalB = rotateVectorByQuaternion(bondDirFromB, quatInverse(cellB.orientation));
    uint zoneB = classifyBondDirection(bondDirLocalB, modeB.splitDirection.xyz, 10.0); // Use 10° inheritance angle as default

    // Write connection and assign indices
    connections[newAdhesionIndex] = AdhesionConnection(
        cellAIndex,
        cellBIndex,
        modeIndex,
        1, // isActive
        zoneA,
        zoneB,
        0u, // sourceChildNumA (0 = not from child, direct adhesion)
        0u, // sourceChildNumB (0 = not from child, direct adhesion)
        anchorDirectionA,
        0.0, // paddingA
        anchorDirectionB,
        0.0, // paddingB
        twistReferenceA,
        twistReferenceB,
        uint[2](0u, 0u) // padding to ensure 16-byte alignment
    );
    outputCells[cellAIndex].adhesionIndices[slotA] = int(newAdhesionIndex);
    outputCells[cellBIndex].adhesionIndices[slotB] = int(newAdhesionIndex);

    // Log diagnostic entry for direct adhesion creation
    logAdhesionDiagnostic(
        newAdhesionIndex, getLineageIdFromIndex(cellAIndex), getLineageIdFromIndex(cellBIndex), modeIndex,
        1, // reasonCode: Direct
        anchorDirectionA, anchorDirectionB,
        uint(u_currentFrame), 0u, // frameIndex, splitEventID (0 for direct)
        0u, 0u, 0u, 0.0 // parentCellID, inheritanceType, originalConnectionIndex, adhesionZone
    );

    return true;
}

void removeAdhesion(int adhesionIndex){
    // Log diagnostic entry for adhesion removal
    if (adhesionIndex >= 0 && adhesionIndex < connections.length()) {
        AdhesionConnection conn = connections[adhesionIndex];
        logAdhesionDiagnostic(
            uint(adhesionIndex), getLineageIdFromIndex(conn.cellAIndex), getLineageIdFromIndex(conn.cellBIndex), conn.modeIndex,
            2, // reasonCode: Broken
            conn.anchorDirectionA, conn.anchorDirectionB,
            uint(u_currentFrame), 0u, // frameIndex, splitEventID (0 for general removal)
            0u, 0u, 0u, 0.0 // parentCellID, inheritanceType, originalConnectionIndex, adhesionZone
        );
    }
    
    // Mark as inactive
    
    // Remove from cellA
    connections[adhesionIndex].isActive = 0;
    for (int i = 0; i < 20; ++i) {
        if (outputCells[connections[adhesionIndex].cellAIndex].adhesionIndices[i] == adhesionIndex) {
            outputCells[connections[adhesionIndex].cellAIndex].adhesionIndices[i] = -1;
            break;
        }
    }

    // Remove from cellB
    for (int i = 0; i < 20; ++i) {
        if (outputCells[connections[adhesionIndex].cellBIndex].adhesionIndices[i] == adhesionIndex) {
            outputCells[connections[adhesionIndex].cellBIndex].adhesionIndices[i] = -1;
            break;
        }
    }

    // Push to free stack safely
    int freeIndex = atomicAdd(freeAdhesionTop, 1);
    if (freeIndex < u_maxAdhesions) {
        freeAdhesionSlotIndices[freeIndex] = adhesionIndex;
    } else {
        freeAdhesionTop = u_maxAdhesions;
    }
}

float priority(uint seed) {
    // Generate a pseudo-random priority based on the seed
    return hash11(seed ^ uint(u_currentFrame));
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= totalCellCount) return;

    ComputeCell cell = inputCells[index];
    GPUMode mode = modes[cell.modeIndex];

    outputCells[index] = cell; // Default output is the same cell

    if (cell.age < mode.splitInterval) return;

    int adhesionCount = 0;
    for (int i = 0; i < 20; ++i) {
        if (cell.adhesionIndices[i] >= 0) {
            adhesionCount++;
        }
    }
    if (adhesionCount >= mode.maxAdhesions) return; // Too many adhesions, cannot split

    // Begin split logic

    // === Compute Split Priority ===
    float myPriority = priority(index);

    // === Check Adhered Cells ===
    for (int i = 0; i < 20; ++i) {
        int adhesionIdx = cell.adhesionIndices[i];
        if (adhesionIdx < 0) continue;

        AdhesionConnection conn = connections[adhesionIdx];
        if (conn.isActive == 0) continue;

        uint otherIndex = (conn.cellAIndex == index) ? conn.cellBIndex : conn.cellAIndex;
        ComputeCell other = inputCells[otherIndex];
        GPUMode otherMode = modes[other.modeIndex];

        if (other.age < otherMode.splitInterval) continue; // Other cell not splitting

        // If other cell wants to split, compare priority
        float otherPriority = priority(otherIndex);
        if (otherPriority < myPriority) {
            // Defer this split - other cell has higher priority (lower index)
            return;
        }
    }

    // CRITICAL FIX: Replace atomic splitting with safer reservation system
    // First, check if we have space for a new cell
    uint currentCount = totalCellCount;
    if (currentCount >= u_maxCells) {
        // No space available, cancel the split
        outputCells[index] = cell;
        return;
    }
    
    // Try to reserve a slot atomically
    uint newIndex = atomicAdd(totalCellCount, 1);

    // Check if we successfully got a valid slot
    if (newIndex >= u_maxCells) {
        // We exceeded the limit, rollback and cancel
        atomicAdd(totalCellCount, -1);
        outputCells[index] = cell;
        return;
    }

    // Successfully reserved a slot, increment live count
    atomicAdd(liveCellCount, 1);

    // CRITICAL FIX: Add memory barrier to ensure atomic operations are complete
    memoryBarrierBuffer();
    
    // CRITICAL FIX: Double-check bounds after memory barrier
    if (newIndex >= u_maxCells) {
        // Rollback the increment if we're still out of bounds
        atomicAdd(totalCellCount, -1);
        atomicAdd(liveCellCount, -1);
        outputCells[index] = cell;
        return;
    }

    uint childAIndex = index;
    uint childBIndex = newIndex;

    vec3 offset = rotateVectorByQuaternion(mode.splitDirection.xyz, cell.orientation) * 0.5;

    // Both child cells should start with the same age after the split
    // Since we already aged the parent cell by deltaTime this frame,
    // we need to subtract the excess age beyond the split interval
    float startAge = cell.age - mode.splitInterval;

    // Apply rotation deltas to parent orientation
    vec4 q_parent = cell.orientation;
    vec4 q_childA = normalize(quatMultiply(q_parent, mode.orientationA));
    vec4 q_childB = normalize(quatMultiply(q_parent, mode.orientationB));

    // Add a tiny random variance to each child orientation (0.001 degree = 0.001 * PI / 180 radians)
    float tinyAngle = 0.001 * 0.017453292519943295; // radians

    // Use child indices to generate different seeds for each child
    vec4 q_varA = smallRandomQuat(tinyAngle, childAIndex);
    vec4 q_varB = smallRandomQuat(tinyAngle, childBIndex);
    q_childA = normalize(quatMultiply(q_childA, q_varA));
    q_childB = normalize(quatMultiply(q_childB, q_varB));

    ComputeCell childA = cell;
    childA.positionAndMass.xyz += offset;
    childA.age = startAge;
    childA.modeIndex = mode.childModes.x;
    childA.orientation = q_childA;
    // Lineage tracking: Child A inherits parent's unique ID and becomes child 1
    childA.parentLineageId = cell.uniqueId;  // Parent's unique ID becomes child's parent lineage ID
    childA.uniqueId = atomicAdd(nextUniqueId, 1); // Get next unique ID atomically
    childA.childNumber = 1;  // First child
    for (int i = 0; i < 20; ++i) {
        childA.adhesionIndices[i] = -1; // Reset adhesion indices for the new child
    }

    ComputeCell childB = cell;
    childB.positionAndMass.xyz -= offset;
    childB.age = startAge + 0.001;
    childB.modeIndex = mode.childModes.y;
    childB.orientation = q_childB;
    // Lineage tracking: Child B gets new unique ID and becomes child 2
    childB.parentLineageId = cell.uniqueId;  // Parent's unique ID becomes child's parent lineage ID
    childB.uniqueId = atomicAdd(nextUniqueId, 1); // Get next unique ID atomically
    childB.childNumber = 2;  // Second child
    for (int i = 0; i < 20; ++i) {
        childB.adhesionIndices[i] = -1; // Reset adhesion indices for the new child
    }

    // Store new cells
    outputCells[childAIndex] = childA;
    outputCells[childBIndex] = childB;

    // CRITICAL FIX: Also write to input buffer to maintain consistency across all buffers
    inputCells[childAIndex] = childA;
    inputCells[childBIndex] = childB;

    // Log cell replacement event - parent cell is replaced by its children
    logEnhancedDiagnostic(
        34u, // CELL_REPLACED
        getLineageIdFromIndex(childAIndex), // Child A lineage ID (replaces parent)
        getLineageIdFromIndex(childBIndex), // Child B lineage ID (replaces parent)
        0xFFFFFFFF, // No connection index
        cell.modeIndex, // Parent's original mode
        1u, // Split event ID
        getLineageIdFromIndex(index), // Original parent lineage ID
        vec3(0.0), vec3(0.0), // No anchor directions for lifecycle events
        cell.age, float(mode.splitInterval), // Event values: parent's age, split interval
        0u // eventFlags
    );
    
    // Log diagnostic events for cell lifecycle
    // Cell split start event for parent (log that parent will split into two children)
    logEnhancedDiagnostic(
        32u, // CELL_SPLIT_START
        getLineageIdFromIndex(index), // Original parent lineage ID (before split)
        getLineageIdFromIndex(childAIndex), // Child A lineage ID (continuation of parent)
        0xFFFFFFFF, // No connection index
        cell.modeIndex, // Parent's mode
        1u, // Split event ID
        getLineageIdFromIndex(index), // Original parent lineage ID
        vec3(0.0), vec3(0.0), // No anchor directions for lifecycle events
        cell.age, float(mode.splitInterval), // Event values: actual age, split interval
        0u // eventFlags
    );

    // Also log split start for child B
    logEnhancedDiagnostic(
        32u, // CELL_SPLIT_START
        getLineageIdFromIndex(childAIndex), // Child A lineage ID
        getLineageIdFromIndex(childBIndex), // Child B lineage ID
        0xFFFFFFFF, // No connection index
        childA.modeIndex, // Child A's mode
        1u, // Split event ID
        getLineageIdFromIndex(index), // Original parent lineage ID
        vec3(0.0), vec3(0.0), // No anchor directions for lifecycle events
        startAge, float(mode.splitInterval), // Event values: starting age, split interval
        0u // eventFlags
    );
    
    // Debug output for lineage tracking (this will be visible in console)
    // Note: This is a simple way to verify lineage assignment works
    // In a real implementation, you might want to use a more sophisticated logging system
    
    // Cell birth event for child A (continuation of parent)
    logEnhancedDiagnostic(
        30u, // CELL_BIRTH
        getLineageIdFromIndex(childAIndex), // Child A lineage ID
        0xFFFFFFFF, // No second cell
        0xFFFFFFFF, // No connection index
        childA.modeIndex, // Child A's mode
        1u, // Split event ID
        getLineageIdFromIndex(index), // Original parent lineage ID
        vec3(0.0), vec3(0.0), // No anchor directions for lifecycle events
        startAge, float(mode.splitInterval), // Event values: starting age, split interval
        0u // eventFlags
    );

    // Cell birth event for new child B
    logEnhancedDiagnostic(
        30u, // CELL_BIRTH
        getLineageIdFromIndex(childBIndex), // New child lineage ID
        0xFFFFFFFF, // No second cell
        0xFFFFFFFF, // No connection index
        childB.modeIndex, // Child's mode
        1u, // Split event ID
        getLineageIdFromIndex(index), // Original parent lineage ID
        vec3(0.0), vec3(0.0), // No anchor directions for lifecycle events
        startAge, float(mode.splitInterval), // Event values: starting age, split interval
        0u // eventFlags
    );
    
    // Cell split complete event (log that parent split into two children)
    logEnhancedDiagnostic(
        33u, // CELL_SPLIT_COMPLETE
        getLineageIdFromIndex(childAIndex), // Child A lineage ID (split completed)
        getLineageIdFromIndex(childBIndex), // Child B lineage ID (split completed)
        0xFFFFFFFF, // No connection index
        childA.modeIndex, // Child A's mode
        1u, // Split event ID
        getLineageIdFromIndex(index), // Original parent lineage ID
        vec3(0.0), vec3(0.0), // No anchor directions for lifecycle events
        startAge, float(mode.splitInterval), // Event values: starting age, split interval
        0u // eventFlags
    );

    // Inherit adhesions for the new child cells
    for (int i = 0; i < 20; ++i) {
        int oldAdhesionIndex = cell.adhesionIndices[i];
        if (oldAdhesionIndex < 0) continue;

        AdhesionConnection oldConnection = connections[oldAdhesionIndex];
        if (oldConnection.isActive == 0) continue;

        // CRITICAL FIX: Add memory barrier before modifying adhesion connections
        memoryBarrierBuffer();

        // Determine who the parent was connected to
        uint neighborIndex = (oldConnection.cellAIndex == childAIndex)
            ? oldConnection.cellBIndex
            : oldConnection.cellAIndex;

        // Remove the old connection
        removeAdhesion(oldAdhesionIndex);

        // Use stored anchor direction instead of spatial calculation
        // Determine which anchor direction to use based on parent's role in the connection
        bool isParentCellA = (oldConnection.cellAIndex == childAIndex); // childAIndex is same as parent index
        vec3 localAnchorDirection = isParentCellA ? oldConnection.anchorDirectionA : oldConnection.anchorDirectionB;

        // Use the stored zone information from the original connection instead of recalculating
        // The original connection already has the correct zone classification
        uint parentZone = isParentCellA ? oldConnection.zoneA : oldConnection.zoneB;

        // Apply inheritance logic
        bool childAInherits = false;
        bool childBInherits = false;
        
        // Get source child number from the connection metadata
        uint neighborSourceChildNum = isParentCellA ? oldConnection.sourceChildNumB : oldConnection.sourceChildNumA;
        
        // Zone classification determines base inheritance
        if (parentZone == 2u) {
            // Zone C (equatorial) - use metadata for child-type matching if available
            if (neighborSourceChildNum > 0u) {
                // We have metadata - match child types to prevent diagonal connections
                if (neighborSourceChildNum == 1u && mode.childAKeepAdhesion == 1) {
                    childAInherits = true;  // Child A (child 1) connects to neighbor child 1
                } else if (neighborSourceChildNum == 2u && mode.childBKeepAdhesion == 1) {
                    childBInherits = true;  // Child B (child 2) connects to neighbor child 2
                }
            } else {
                // No metadata - both children inherit (standard Zone C behavior)
                childAInherits = (mode.childAKeepAdhesion == 1);
                childBInherits = (mode.childBKeepAdhesion == 1);
            }
        } else if (parentZone == 1u) {
            // Zone B - goes to Child A (normal logic, no metadata)
            childAInherits = (mode.childAKeepAdhesion == 1);
        } else {
            // Zone A - goes to Child B (normal logic, no metadata)
            childBInherits = (mode.childBKeepAdhesion == 1);
        }
        
        // Determine neighbor's role in the original connection
        bool neighborWasCellA = (oldConnection.cellAIndex == neighborIndex);
        vec3 neighborAnchorDirection = neighborWasCellA ? oldConnection.anchorDirectionA : oldConnection.anchorDirectionB;

        // Create new adhesion connections for inheriting children
        // Zone C bonds can create connections for both children, polar bonds create connections for specific children

        // Child A inheritance
        if (childAInherits) {
            // Genome-only transform: rotate parent's local anchor into child A's local space via inverse of delta quat
            vec4 invDeltaA = quatInverse(mode.orientationA);
            vec3 childAnchorDirection = rotateVectorByQuaternion(localAnchorDirection, invDeltaA);

            // Determine what to store for neighbor's source child num
            // Zone C: Store metadata (1 or 2) to match child types
            // Zones A and B: Don't store metadata (use 0)
            uint neighborSourceToStore = neighborSourceChildNum; // Propagate existing metadata
            if (neighborSourceChildNum == 0u && parentZone == 2u) {
                // Zone C with no metadata: store child number for future matching
                neighborSourceToStore = 1u;
            }

            // Preserve original side assignment: if neighbor was originally cellA, keep them as cellA
            int newConnectionIndex;
            if (neighborWasCellA) {
                // Neighbor was cellA, child becomes cellB
                // Store source child number: neighbor gets propagated metadata or 1, child stores 1 (childA)
                newConnectionIndex = addAdhesionWithDirections(neighborIndex, childAIndex, oldConnection.modeIndex, neighborAnchorDirection, childAnchorDirection, neighborSourceToStore, 1u);
            } else {
                // Neighbor was cellB, child becomes cellA
                // Store source child number: child stores 1 (childA), neighbor gets propagated metadata or 1
                newConnectionIndex = addAdhesionWithDirections(childAIndex, neighborIndex, oldConnection.modeIndex, childAnchorDirection, neighborAnchorDirection, 1u, neighborSourceToStore);
            }
            if (newConnectionIndex < 0) return;

            // Log diagnostic entry for inherited connection (Child A)
            // Use the actual cellA/cellB assignment from the connection structure
            uint actualCellA = neighborWasCellA ? neighborIndex : childAIndex;
            uint actualCellB = neighborWasCellA ? childAIndex : neighborIndex;
            logAdhesionDiagnostic(
                uint(newConnectionIndex), getLineageIdFromIndex(actualCellA), getLineageIdFromIndex(actualCellB), oldConnection.modeIndex,
                0, // reasonCode: Inherited
                neighborWasCellA ? neighborAnchorDirection : childAnchorDirection,
                neighborWasCellA ? childAnchorDirection : neighborAnchorDirection,
                uint(u_currentFrame), 1u, // frameIndex, splitEventID (1 for split event)
                getLineageIdFromIndex(index), 1u, uint(oldAdhesionIndex), float(parentZone) // original parentCellID, inheritanceType (1=childA_keeps), originalConnectionIndex, adhesionZone
            );
        }

        // Child B inheritance (Zone C bonds can also create this)
        if (childBInherits) {
            // Genome-only transform: rotate parent's local anchor into child B's local space via inverse of delta quat
            vec4 invDeltaB = quatInverse(mode.orientationB);
            vec3 childAnchorDirection = rotateVectorByQuaternion(localAnchorDirection, invDeltaB);

            // Determine what to store for neighbor's source child num
            // Zone C: Store metadata (1 or 2) to match child types
            // Zones A and B: Don't store metadata (use 0)
            uint neighborSourceToStore = neighborSourceChildNum; // Propagate existing metadata
            if (neighborSourceChildNum == 0u && parentZone == 2u) {
                // Zone C with no metadata: store child number for future matching
                neighborSourceToStore = 2u;
            }

            // Preserve original side assignment: if neighbor was originally cellA, keep them as cellA
            int newConnectionIndex;
            if (neighborWasCellA) {
                // Neighbor was cellA, child becomes cellB
                // Store source child number: neighbor gets propagated metadata or 2, child stores 2 (childB)
                newConnectionIndex = addAdhesionWithDirections(neighborIndex, childBIndex, oldConnection.modeIndex, neighborAnchorDirection, childAnchorDirection, neighborSourceToStore, 2u);
            } else {
                // Neighbor was cellB, child becomes cellA
                // Store source child number: child stores 2 (childB), neighbor gets propagated metadata or 2
                newConnectionIndex = addAdhesionWithDirections(childBIndex, neighborIndex, oldConnection.modeIndex, childAnchorDirection, neighborAnchorDirection, 2u, neighborSourceToStore);
            }
            if (newConnectionIndex < 0) return;

            // Log diagnostic entry for inherited connection (Child B)
            // Use the actual cellA/cellB assignment from the connection structure
            uint actualCellA_B = neighborWasCellA ? neighborIndex : childBIndex;
            uint actualCellB_B = neighborWasCellA ? childBIndex : neighborIndex;
            logAdhesionDiagnostic(
                uint(newConnectionIndex), getLineageIdFromIndex(actualCellA_B), getLineageIdFromIndex(actualCellB_B), oldConnection.modeIndex,
                0, // reasonCode: Inherited
                neighborWasCellA ? neighborAnchorDirection : childAnchorDirection,
                neighborWasCellA ? childAnchorDirection : neighborAnchorDirection,
                uint(u_currentFrame), 1u, // frameIndex, splitEventID (1 for split event)
                getLineageIdFromIndex(index), 2u, uint(oldAdhesionIndex), float(parentZone) // original parentCellID, inheritanceType (2=childB_keeps), originalConnectionIndex, adhesionZone
            );
        }
    }

    // Now we need to add the adhesion connection between the children
    if (mode.parentMakeAdhesion == 0)  return;

    // Create a new adhesion connection between the two children
    vec3 posA = outputCells[childAIndex].positionAndMass.xyz;
    vec3 posB = outputCells[childBIndex].positionAndMass.xyz;

    // Calculate initial anchor directions in local cell space
    vec3 directionAtoB = normalize(posB - posA);
    vec3 anchorDirectionA = rotateVectorByQuaternion(directionAtoB, quatInverse(outputCells[childAIndex].orientation));

    vec3 directionBtoA = normalize(posA - posB);
    vec3 anchorDirectionB = rotateVectorByQuaternion(directionBtoA, quatInverse(outputCells[childBIndex].orientation));

    // Classify zones for child-to-child connection based on actual bond direction
    uint childZoneA = classifyBondDirection(anchorDirectionA, mode.splitDirection.xyz, 10.0);
    uint childZoneB = classifyBondDirection(anchorDirectionB, mode.splitDirection.xyz, 10.0);

    uint childToChildConnectionIndex = getNewAdhesionIndex();
    if (childToChildConnectionIndex == uint(-1)) return;

    // Create child-to-child adhesion connection with properly classified zones
    connections[childToChildConnectionIndex] = AdhesionConnection(
        childAIndex,
        childBIndex,
        cell.modeIndex,
        1, // isActive
        childZoneA, // zoneA: Properly classified based on bond direction
        childZoneB, // zoneB: Properly classified based on bond direction
        0u, // sourceChildNumA (0 = sibling bond, not inherited)
        0u, // sourceChildNumB (0 = sibling bond, not inherited)
        anchorDirectionA,
        0.0, // paddingA
        anchorDirectionB,
        0.0, // paddingB
        outputCells[childAIndex].orientation,
        outputCells[childBIndex].orientation,
        uint[2](0u, 0u) // padding to ensure 16-byte alignment
    );

    // Assign to cell adhesion slots (find available slots)
    int slotA = -1, slotB = -1;
    for (int j = 0; j < 20; ++j) {
        if (outputCells[childAIndex].adhesionIndices[j] < 0 && slotA == -1) slotA = j;
        if (outputCells[childBIndex].adhesionIndices[j] < 0 && slotB == -1) slotB = j;
        if (slotA != -1 && slotB != -1) break;
    }

    if (slotA != -1 && slotB != -1) {
        outputCells[childAIndex].adhesionIndices[slotA] = int(childToChildConnectionIndex);
        outputCells[childBIndex].adhesionIndices[slotB] = int(childToChildConnectionIndex);

        // Log diagnostic entry for child-to-child adhesion
        logAdhesionDiagnostic(
            childToChildConnectionIndex, getLineageIdFromIndex(childAIndex), getLineageIdFromIndex(childBIndex), cell.modeIndex,
            3, // reasonCode: ChildToChild
            anchorDirectionA, anchorDirectionB,
            uint(u_currentFrame), 1u, // frameIndex, splitEventID (1 for split event)
            getLineageIdFromIndex(index), 3u, 0u, float(childZoneA) // original parentCellID, inheritanceType (3=child_to_child), originalConnectionIndex=0, adhesionZone (actual zone)
        );
    }
}