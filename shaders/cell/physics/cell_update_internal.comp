#version 430 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass;   // x, y, z, mass
    vec4 velocity;          // x, y, z, padding
    vec4 acceleration;      // x, y, z, padding
    vec4 prevAcceleration;  // x, y, z, padding
    vec4 orientation;       // Quaternion to (prevent gimbal lock) - affected by physics
    vec4 genomeOrientation; // Quaternion for genome-derived orientation - NEVER affected by physics
    vec4 angularVelocity;   // Pseudo-vector for easy math
    vec4 angularAcceleration;       // Pseudo-vector for easy math
    vec4 prevAngularAcceleration;   // Pseudo-vector for easy math
    // Internal:
    vec4 signallingSubstances;  // 4 substances for now
    int modeIndex;              // absolute index of the cell's mode
    float age;                  // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];

    // Padding to maintain 16-byte alignment for the entire struct
    uint _padding[4];
    
    };

struct GPUModeAdhesionSettings
{
    int canBreak;                 // bool -> int (4 bytes)
    float breakForce;
    float restLength;
    float linearSpringStiffness;
    float linearSpringDamping;
    float orientationSpringStiffness;
    float orientationSpringDamping;
    float maxAngularDeviation;
    float twistConstraintStiffness;
    float twistConstraintDamping;
    int enableTwistConstraint;    // bool -> int (4 bytes)
    int _padding;                 // pad to 48 bytes
};

// GPU Mode structure
struct GPUMode {
    vec4 color;
    vec4 orientationA;
    vec4 orientationB;
    vec4 splitDirection;
    ivec2 childModes;
    float splitInterval;
    int genomeOffset;
    GPUModeAdhesionSettings adhesionSettings;
    int parentMakeAdhesion;
    int childAKeepAdhesion;
    int childBKeepAdhesion;
    int maxAdhesions;
    float flagellocyteThrustForce;
    float _padding1;
    float _padding2;
    float _padding3;
};

// Adhesion connection structure - stores permanent connections between sibling cells
struct AdhesionConnection {
    uint cellAIndex;      // Index of first cell in the connection
    uint cellBIndex;      // Index of second cell in the connection
    uint modeIndex;       // Mode index for the connection ( to lookup adhesion settings )
    uint isActive;        // Whether this connection is still active (1 = active, 0 = inactive)
    uint zoneA;           // Zone classification for cell A (0=ZoneA, 1=ZoneB, 2=ZoneC)
    uint zoneB;           // Zone classification for cell B (0=ZoneA, 1=ZoneB, 2=ZoneC)
    vec3 anchorDirectionA; // Anchor direction for cell A in local cell space (normalized)
    float paddingA;       // Padding to ensure 16-byte alignment
    vec3 anchorDirectionB; // Anchor direction for cell B in local cell space (normalized)
    float paddingB;       // Padding to ensure 16-byte alignment
    vec4 twistReferenceA; // Reference quaternion for twist constraint for cell A (16 bytes)
    vec4 twistReferenceB; // Reference quaternion for twist constraint for cell B (16 bytes)
    uint _padding[4];     // Padding to ensure 16-byte alignment (96 bytes total)
};



layout(std430, binding = 0) restrict buffer ReadCellBuffer {
    ComputeCell inputCells[];
};

layout(std430, binding = 1) restrict buffer modeBuffer {
    GPUMode modes[];
};

layout(std430, binding = 2) restrict buffer WriteCellBuffer {
    ComputeCell outputCells[];
};

layout(std430, binding = 3) coherent buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    int freeAdhesionTop;
};

layout(std430, binding = 4) coherent buffer AdhesionConnectionBuffer {
    AdhesionConnection connections[];
};

layout(std430, binding = 5) coherent buffer freeCellSlotBuffer {
    uint freeCellSlotIndices[];
};

layout(std430, binding = 6) coherent buffer freeAdhesionSlotBuffer {
    uint freeAdhesionSlotIndices[];
};




uniform float u_deltaTime;
uniform int u_maxCells;
uniform int u_maxAdhesions;


vec4 quatMultiply(vec4 q1, vec4 q2) {
    return vec4(
        q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y,
        q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x,
        q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w,
        q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z
    );
}

// Classify bond direction into zones (A, B, C) based on angle from split direction
// Based on Unity CellAdhesionManager classification logic
uint classifyBondDirection(vec3 bondDirLocal, vec3 splitDirLocal, float inheritanceAngleDeg) {
    float dot = dot(bondDirLocal, splitDirLocal);
    float angle = acos(clamp(dot, -1.0, 1.0)) * 180.0 / 3.141592653589793; // Convert to degrees
    float halfWidth = inheritanceAngleDeg * 1.0;
    float equatorialAngle = 90.0;

    if (abs(angle - equatorialAngle) <= halfWidth)
        return 2u; // Zone C (equatorial)
    else if (dot > 0.0)
        return 1u; // Zone B (positive dot product)
    else
        return 0u; // Zone A (negative dot product)
}

vec3 rotateVectorByQuaternion(vec3 v, vec4 q) {
    // v' = q * v * q^-1
    // Optimized version using cross product:
    vec3 u = q.xyz;
    float s = q.w;

    return 2.0 * dot(u, v) * u
         + (s * s - dot(u, u)) * v
         + 2.0 * s * cross(u, v);
}

vec4 quatInverse(vec4 q) {
    float norm = dot(q, q);
    if (norm > 0.0) {
        return vec4(-q.xyz, q.w) / norm;
    }
    return vec4(0.0, 0.0, 0.0, 1.0); // Identity quaternion
}

// Snap anchor direction to nearest angle increment
// Snaps spherical angles (theta, phi) to the nearest increment defined by the genome orientation
vec3 snapAnchorToAngleIncrement(vec3 anchorDir, vec4 orientationDelta) {
    // Convert anchor direction to spherical coordinates
    float r = length(anchorDir);
    if (r < 0.001) return vec3(1.0, 0.0, 0.0); // Fallback for zero vector
    
    vec3 dir = anchorDir / r;
    
    // Calculate spherical angles
    float theta = atan(dir.y, dir.x); // Azimuthal angle [-π, π]
    float phi = acos(clamp(dir.z, -1.0, 1.0)); // Polar angle [0, π]
    
    // Determine angle increment from genome orientation
    // Extract rotation angle from the quaternion
    float qw = orientationDelta.w;
    float angleIncrement = 2.0 * acos(clamp(abs(qw), 0.0, 1.0)); // Angle in radians
    
    // If angle is too small, default to 90 degrees (π/2)
    if (angleIncrement < 0.1) {
        angleIncrement = 3.14159265359 / 2.0; // 90 degrees
    }
    
    // Snap theta and phi to nearest increment
    float thetaSnapped = round(theta / angleIncrement) * angleIncrement;
    float phiSnapped = round(phi / angleIncrement) * angleIncrement;
    
    // Convert back to Cartesian coordinates
    float sinPhi = sin(phiSnapped);
    vec3 snapped = vec3(
        sinPhi * cos(thetaSnapped),
        sinPhi * sin(thetaSnapped),
        cos(phiSnapped)
    );
    
    return normalize(snapped);
}

// Deterministic quaternion rotation from one vector to another
// Uses a consistent method that avoids cross product ambiguity
vec4 quatFromTwoVectors(vec3 from, vec3 to) {
    // Normalize inputs
    vec3 v1 = normalize(from);
    vec3 v2 = normalize(to);
    
    float cosAngle = dot(v1, v2);
    
    // Vectors are already aligned
    if (cosAngle > 0.9999) {
        return vec4(0.0, 0.0, 0.0, 1.0); // Identity
    }
    
    // Vectors are opposite - use deterministic perpendicular axis
    if (cosAngle < -0.9999) {
        // Choose axis deterministically based on which component is smallest
        vec3 axis;
        if (abs(v1.x) < abs(v1.y) && abs(v1.x) < abs(v1.z)) {
            axis = normalize(vec3(0.0, -v1.z, v1.y));
        } else if (abs(v1.y) < abs(v1.z)) {
            axis = normalize(vec3(-v1.z, 0.0, v1.x));
        } else {
            axis = normalize(vec3(-v1.y, v1.x, 0.0));
        }
        return vec4(axis, 0.0); // 180 degree rotation
    }
    
    // General case: use half-way quaternion method (more stable than cross product)
    vec3 halfway = normalize(v1 + v2);
    vec3 axis = vec3(
        v1.y * halfway.z - v1.z * halfway.y,
        v1.z * halfway.x - v1.x * halfway.z,
        v1.x * halfway.y - v1.y * halfway.x
    );
    float w = dot(v1, halfway);
    
    return normalize(vec4(axis, w));
}

// Hash function to generate a pseudo-random float in [0,1] from a uint seed
float hash11(uint n) {
    n = (n ^ 61u) ^ (n >> 16u);
    n *= 9u;
    n = n ^ (n >> 4u);
    n *= 0x27d4eb2du;
    n = n ^ (n >> 15u);
    return float(n & 0x00FFFFFFu) / float(0x01000000u);
}

// Create a small random quaternion for a tiny rotation (angle in radians)
vec4 smallRandomQuat(float angle, uint seed) {
    // Random axis
    float rand1 = hash11(seed * 3u + 0u);
    float rand2 = hash11(seed * 3u + 1u);
    float rand3 = hash11(seed * 3u + 2u);
    vec3 axis = normalize(vec3(rand1, rand2, rand3) * 2.0 - 1.0);
    float halfAngle = angle * 0.5;
    float s = sin(halfAngle);
    return normalize(vec4(axis * s, cos(halfAngle)));
}


uint getNewAdhesionIndex() {
    // Try to reserve a free adhesion slot
    // Snapshot free top value without modifying it first
    int freeTopBefore = freeAdhesionTop;
    if (freeTopBefore > 0) {
        // Now reserve slot *safely*
        int freeTop = atomicAdd(freeAdhesionTop, -1);
        if (freeTop > 0) {
            return freeAdhesionSlotIndices[freeTop - 1];
        } else {
            // Another thread raced and depleted the stack before we got here
            atomicAdd(freeAdhesionTop, 1); // revert
        }
    }

    // Fallback to allocating a new slot
    uint newAdhesionIndex = atomicAdd(totalAdhesionCount, 1);
    if (newAdhesionIndex >= u_maxAdhesions) {
        atomicMin(totalAdhesionCount, u_maxAdhesions);
        return -1;
    }
    return newAdhesionIndex;
}

// Add adhesion with preserved anchor directions (for inheritance)
// Returns the connection index on success, -1 on failure
int addAdhesionWithDirections(uint cellAIndex, uint cellBIndex, uint modeIndex, vec3 preservedAnchorA, vec3 preservedAnchorB) {
    uint newAdhesionIndex = getNewAdhesionIndex();
    if (newAdhesionIndex == uint(-1)) {
        // Failed to reserve an adhesion index
        return -1;
    }

    // Check for available slot in cell A using atomic compare-exchange to prevent races
    int slotA = -1;
    for (int j = 0; j < 20; ++j) {
        // Atomically try to claim this slot
        int expected = -1;
        int newValue = -2; // Temporary marker to claim the slot
        if (atomicCompSwap(outputCells[cellAIndex].adhesionIndices[j], expected, newValue) == expected) {
            slotA = j;
            break;
        }
    }

    // Check for available slot in cell B using atomic compare-exchange to prevent races
    int slotB = -1;
    for (int j = 0; j < 20; ++j) {
        // Atomically try to claim this slot
        int expected = -1;
        int newValueB = -2; // Temporary marker to claim the slot
        if (atomicCompSwap(outputCells[cellBIndex].adhesionIndices[j], expected, newValueB) == expected) {
            slotB = j;
            break;
        }
    }

    if (slotA == -1 || slotB == -1) {
        // Roll back the reservation if any cell has no free slot
        // Also release any claimed slots
        if (slotA != -1) {
            outputCells[cellAIndex].adhesionIndices[slotA] = -1;
        }
        if (slotB != -1) {
            outputCells[cellBIndex].adhesionIndices[slotB] = -1;
        }
        int reservation = atomicAdd(freeAdhesionTop, 1);
        int topIndex = reservation;
        freeAdhesionSlotIndices[topIndex] = newAdhesionIndex;
        return -1;
    }

    // Use the preserved anchor directions directly (already in local space)
    vec3 anchorDirectionA = preservedAnchorA;
    vec3 anchorDirectionB = preservedAnchorB;

    // Store current orientations as twist reference for constraint
    vec4 twistReferenceA = inputCells[cellAIndex].orientation;
    vec4 twistReferenceB = inputCells[cellBIndex].orientation;

    // Classify zones using the preserved anchor directions (already in local space)
    ComputeCell cellA = inputCells[cellAIndex];
    ComputeCell cellB = inputCells[cellBIndex];
    GPUMode modeA = modes[cellA.modeIndex];
    GPUMode modeB = modes[cellB.modeIndex];

    // Use preserved anchor directions for zone classification (genome-based, not spatial)
    uint zoneA = classifyBondDirection(anchorDirectionA, modeA.splitDirection.xyz, 10.0);
    uint zoneB = classifyBondDirection(anchorDirectionB, modeB.splitDirection.xyz, 10.0);

    // Write connection and assign indices
    connections[newAdhesionIndex] = AdhesionConnection(
        cellAIndex,
        cellBIndex,
        modeIndex,
        1, // isActive
        zoneA,
        zoneB,
        anchorDirectionA,
        0.0, // paddingA
        anchorDirectionB,
        0.0, // paddingB
        twistReferenceA,
        twistReferenceB,
        uint[4](0u, 0u, 0u, 0u) // padding to ensure 16-byte alignment
    );
    outputCells[cellAIndex].adhesionIndices[slotA] = int(newAdhesionIndex);
    outputCells[cellBIndex].adhesionIndices[slotB] = int(newAdhesionIndex);
    
    // Memory barrier to ensure writes are visible to subsequent slot searches
    memoryBarrierBuffer();

    return int(newAdhesionIndex);
}

bool addAdhesion(uint cellAIndex, uint cellBIndex, uint modeIndex) {
    uint newAdhesionIndex = getNewAdhesionIndex();
    if (newAdhesionIndex == uint(-1)) {
        // Failed to reserve an adhesion index
        return false;
    }

    // Check for available slot in cell A
    int slotA = -1;
    for (int j = 0; j < 20; ++j) {
        if (outputCells[cellAIndex].adhesionIndices[j] < 0) {
            slotA = j;
            break;
        }
    }

    // Check for available slot in cell B
    int slotB = -1;
    for (int j = 0; j < 20; ++j) {
        if (outputCells[cellBIndex].adhesionIndices[j] < 0) {
            slotB = j;
            break;
        }
    }

    if (slotA == -1 || slotB == -1) {
        // Roll back the reservation if any cell has no free slot
        int reservation = atomicAdd(freeAdhesionTop, 1);
        int topIndex = reservation;
        freeAdhesionSlotIndices[topIndex] = newAdhesionIndex;
        return false;
    }

    // Calculate initial anchor directions using ONLY genome-based data
    // This function is called for sibling bonds during split
    // We need to use genome-derived orientations, not actual cell orientations
    GPUMode modeForBond = modes[modeIndex];
    
    // The split direction in the parent's local frame
    vec3 splitDirLocal = modeForBond.splitDirection.xyz;
    
    // Direction vectors in parent's local frame
    // Child A is at +offset, child B is at -offset
    vec3 directionAtoB_parentLocal = -splitDirLocal;  // A points toward B (at -offset)
    vec3 directionBtoA_parentLocal = splitDirLocal;   // B points toward A (at +offset)

    // Transform to each child's local space using genome-derived orientation deltas
    // Child A's local space: rotate by inverse of orientationA
    vec4 invDeltaA = quatInverse(modeForBond.orientationA);
    vec3 anchorDirectionA = normalize(rotateVectorByQuaternion(directionAtoB_parentLocal, invDeltaA));
    
    // Child B's local space: rotate by inverse of orientationB
    vec4 invDeltaB = quatInverse(modeForBond.orientationB);
    vec3 anchorDirectionB = normalize(rotateVectorByQuaternion(directionBtoA_parentLocal, invDeltaB));

    // Get cell data for mode lookup
    ComputeCell cellA = inputCells[cellAIndex];
    ComputeCell cellB = inputCells[cellBIndex];
    
    // Use genome-based orientations as twist reference (deterministic, independent of physics)
    // This ensures twist constraints are consistent regardless of cell rotation before split
    vec4 twistReferenceA = cellA.orientation;
    vec4 twistReferenceB = cellB.orientation;

    // Classify zones using the genome-derived anchor directions (already in local space)
    GPUMode modeA = modes[cellA.modeIndex];
    GPUMode modeB = modes[cellB.modeIndex];

    // Zone classification using genome-based anchors
    uint zoneA = classifyBondDirection(anchorDirectionA, modeA.splitDirection.xyz, 10.0);
    uint zoneB = classifyBondDirection(anchorDirectionB, modeB.splitDirection.xyz, 10.0);

    // Write connection and assign indices
    connections[newAdhesionIndex] = AdhesionConnection(
        cellAIndex,
        cellBIndex,
        modeIndex,
        1, // isActive
        zoneA,
        zoneB,
        anchorDirectionA,
        0.0, // paddingA
        anchorDirectionB,
        0.0, // paddingB
        twistReferenceA,
        twistReferenceB,
        uint[4](0u, 0u, 0u, 0u) // padding to ensure 16-byte alignment
    );
    outputCells[cellAIndex].adhesionIndices[slotA] = int(newAdhesionIndex);
    outputCells[cellBIndex].adhesionIndices[slotB] = int(newAdhesionIndex);

    return true;
}

void removeAdhesion(int adhesionIndex){
    if (adhesionIndex >= 0 && adhesionIndex < connections.length()) {
        AdhesionConnection conn = connections[adhesionIndex];
    }
    
    // Mark as inactive
    
    // Remove from cellA
    connections[adhesionIndex].isActive = 0;
    for (int i = 0; i < 20; ++i) {
        if (outputCells[connections[adhesionIndex].cellAIndex].adhesionIndices[i] == adhesionIndex) {
            outputCells[connections[adhesionIndex].cellAIndex].adhesionIndices[i] = -1;
            break;
        }
    }

    // Remove from cellB
    for (int i = 0; i < 20; ++i) {
        if (outputCells[connections[adhesionIndex].cellBIndex].adhesionIndices[i] == adhesionIndex) {
            outputCells[connections[adhesionIndex].cellBIndex].adhesionIndices[i] = -1;
            break;
        }
    }

    // Push to free stack safely
    int freeIndex = atomicAdd(freeAdhesionTop, 1);
    if (freeIndex < u_maxAdhesions) {
        freeAdhesionSlotIndices[freeIndex] = adhesionIndex;
    } else {
        freeAdhesionTop = u_maxAdhesions;
    }
}

float priority(uint seed) {
    // Generate a pseudo-random priority based on the seed
    return float(seed % 1000) / 1000.0; // Simple pseudo-random value
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= totalCellCount) return;

    ComputeCell cell = inputCells[index];
    GPUMode mode = modes[cell.modeIndex];

    outputCells[index] = cell; // Default output is the same cell

    if (cell.age < mode.splitInterval) return;

    int adhesionCount = 0;
    for (int i = 0; i < 20; ++i) {
        if (cell.adhesionIndices[i] >= 0) {
            adhesionCount++;
        }
    }
    if (adhesionCount >= mode.maxAdhesions) return; // Too many adhesions, cannot split

    // Begin split logic

    // === Compute Split Priority ===
    float myPriority = priority(index);

    // === Check Adhered Cells ===
    for (int i = 0; i < 20; ++i) {
        int adhesionIdx = cell.adhesionIndices[i];
        if (adhesionIdx < 0) continue;

        AdhesionConnection conn = connections[adhesionIdx];
        if (conn.isActive == 0) continue;

        uint otherIndex = (conn.cellAIndex == index) ? conn.cellBIndex : conn.cellAIndex;
        ComputeCell other = inputCells[otherIndex];
        GPUMode otherMode = modes[other.modeIndex];

        if (other.age < otherMode.splitInterval) continue; // Other cell not splitting

        // If other cell wants to split, compare priority
        float otherPriority = priority(otherIndex);
        if (otherPriority < myPriority) {
            // Defer this split - other cell has higher priority (lower index)
            return;
        }
    }

    // CRITICAL FIX: Replace atomic splitting with safer reservation system
    // First, check if we have space for a new cell
    uint currentCount = totalCellCount;
    if (currentCount >= u_maxCells) {
        // No space available, cancel the split
        outputCells[index] = cell;
        return;
    }
    
    // Try to reserve a slot atomically
    uint newIndex = atomicAdd(totalCellCount, 1);

    // Check if we successfully got a valid slot
    if (newIndex >= u_maxCells) {
        // We exceeded the limit, rollback and cancel
        atomicAdd(totalCellCount, -1);
        outputCells[index] = cell;
        return;
    }

    // Successfully reserved a slot, increment live count
    atomicAdd(liveCellCount, 1);

    // CRITICAL FIX: Add memory barrier to ensure atomic operations are complete
    memoryBarrierBuffer();
    
    // CRITICAL FIX: Double-check bounds after memory barrier
    if (newIndex >= u_maxCells) {
        // Rollback the increment if we're still out of bounds
        atomicAdd(totalCellCount, -1);
        atomicAdd(liveCellCount, -1);
        outputCells[index] = cell;
        return;
    }

    uint childAIndex = index;
    uint childBIndex = newIndex;

    vec3 offset = rotateVectorByQuaternion(mode.splitDirection.xyz, cell.orientation) * 0.5;

    // Both child cells should start with the same age after the split
    // Since we already aged the parent cell by deltaTime this frame,
    // we need to subtract the excess age beyond the split interval
    float startAge = cell.age - mode.splitInterval;

    // Apply rotation deltas to parent orientation (deterministic, no random variation)
    vec4 q_parent = cell.orientation;
    vec4 q_childA = normalize(quatMultiply(q_parent, mode.orientationA));
    vec4 q_childB = normalize(quatMultiply(q_parent, mode.orientationB));

    // Apply rotation deltas to parent genomeOrientation (purely genome-derived, never affected by physics)
    vec4 q_genome_parent = cell.genomeOrientation;
    vec4 q_genome_childA = normalize(quatMultiply(q_genome_parent, mode.orientationA));
    vec4 q_genome_childB = normalize(quatMultiply(q_genome_parent, mode.orientationB));

    ComputeCell childA = cell;
    childA.positionAndMass.xyz += offset;
    childA.age = startAge;
    childA.modeIndex = mode.childModes.x;
    childA.orientation = q_childA;
    childA.genomeOrientation = q_genome_childA;
        for (int i = 0; i < 20; ++i) {
        childA.adhesionIndices[i] = -1; // Reset adhesion indices for the new child
    }

    ComputeCell childB = cell;
    childB.positionAndMass.xyz -= offset;
    childB.age = startAge + 0.001;
    childB.modeIndex = mode.childModes.y;
    childB.orientation = q_childB;
    childB.genomeOrientation = q_genome_childB;
        for (int i = 0; i < 20; ++i) {
        childB.adhesionIndices[i] = -1; // Reset adhesion indices for the new child
    }

    // Store new cells
    outputCells[childAIndex] = childA;
    outputCells[childBIndex] = childB;

    // CRITICAL FIX: Also write to input buffer to maintain consistency across all buffers
    inputCells[childAIndex] = childA;
    inputCells[childBIndex] = childB;

    // Inherit adhesions for the new child cells
    for (int i = 0; i < 20; ++i) {
        int oldAdhesionIndex = cell.adhesionIndices[i];
        if (oldAdhesionIndex < 0) continue;

        // Read connection data BEFORE checking isActive, because the neighbor might have already
        // split and marked it inactive. We need the connection data regardless.
        AdhesionConnection oldConnection = connections[oldAdhesionIndex];
        
        // Skip if this connection was already processed (not from a split)
        // But allow processing if it was marked inactive by a simultaneous split
        bool wasAlreadyProcessed = (oldConnection.isActive == 0 && 
                                     oldConnection.cellAIndex != childAIndex && 
                                     oldConnection.cellBIndex != childAIndex);
        if (wasAlreadyProcessed) continue;

        // CRITICAL FIX: Add memory barrier before modifying adhesion connections
        memoryBarrierBuffer();

        // Determine who the parent was connected to
        uint neighborIndex = (oldConnection.cellAIndex == childAIndex)
            ? oldConnection.cellBIndex
            : oldConnection.cellAIndex;

        // Remove the old connection (this marks it inactive, but we already have the data)
        // Note: If neighbor also splits, it will have already read this connection data
        removeAdhesion(oldAdhesionIndex);

        // Use stored anchor direction instead of spatial calculation
        // Determine which anchor direction to use based on parent's role in the connection
        bool isParentCellA = (oldConnection.cellAIndex == childAIndex); // childAIndex is same as parent index
        vec3 localAnchorDirection = isParentCellA ? oldConnection.anchorDirectionA : oldConnection.anchorDirectionB;

        // Use the stored zone information from the original connection instead of recalculating
        // The original connection already has the correct zone classification

        float splitMagnitude = length(mode.splitDirection.xyz);
        vec3 splitDir_parent;
        float splitOffset;
        if (splitMagnitude < 0.0001) {
            splitDir_parent = vec3(0.0, 0.0, 1.0);
            splitOffset = 0.0;
        } else {
            splitDir_parent = mode.splitDirection.xyz / splitMagnitude;
            splitOffset = splitMagnitude * 0.5;
        }

        vec3 bondDir_parent = normalize(localAnchorDirection);

        float dotSplitBond = dot(splitDir_parent, bondDir_parent);
        float equatorialThreshold = sin(radians(10.0));

        uint parentZone;
        if (abs(dotSplitBond) <= equatorialThreshold) {
            parentZone = 2u;
        } else if (dotSplitBond > 0.0) {
            parentZone = 1u;
        } else {
            parentZone = 0u;
        }

        // Apply inheritance logic - simple zone-based rules
        bool childAInherits = false;
        bool childBInherits = false;
        
        // Zone classification determines inheritance
        if (parentZone == 2u) {
            // Zone C (equatorial) - both children inherit
            childAInherits = (mode.childAKeepAdhesion == 1);
            childBInherits = (mode.childBKeepAdhesion == 1);
        } else if (parentZone == 1u) {
            // Zone B - Child A inherits
            childAInherits = (mode.childAKeepAdhesion == 1);
        } else {
            // Zone A - Child B inherits
            childBInherits = (mode.childBKeepAdhesion == 1);
        }
        
        // Determine neighbor's role in the original connection
        bool neighborWasCellA = (oldConnection.cellAIndex == neighborIndex);
        
        // Create new adhesion connections for inheriting children
        // Zone C bonds can create connections for both children, polar bonds create connections for specific children

        // Get rest length for calculating ideal positions
        float restLength = modes[oldConnection.modeIndex].adhesionSettings.restLength;

        // Read neighbor cell info
        ComputeCell neighborCell = inputCells[neighborIndex];

        // Calculate positions in parent's local frame (genome-based)
        vec3 neighborPos_parentFrame = localAnchorDirection * restLength;

        // Child A inheritance
        if (childAInherits) {
            // Child A's anchor: parent's anchor adjusted for child's offset, then rotated to child's frame
            // The parent's anchor points from parent's CENTER, but childA is OFFSET from parent's center
            // So we need to adjust the direction to account for this offset
            vec3 anchorEndpoint_parentFrame = localAnchorDirection * restLength;
            vec3 childAOffset_parentFrame = splitDir_parent * splitOffset;
            vec3 childAAnchorDirection_parentFrame = normalize(anchorEndpoint_parentFrame - childAOffset_parentFrame);

            vec3 childAnchorDirection = normalize(rotateVectorByQuaternion(
                childAAnchorDirection_parentFrame,
                quatInverse(mode.orientationA)
            ));

            // Calculate neighbor's anchor: passive placement along vector from neighbor's CENTER to childA
            vec3 childAPos_parentFrame = splitDir_parent * splitOffset;
            vec3 neighborToChildA_parentFrame = normalize(childAPos_parentFrame - neighborPos_parentFrame);

            // Transform to neighbor's local frame
            vec4 relativeRotation = quatMultiply(quatInverse(neighborCell.genomeOrientation), cell.genomeOrientation);
            vec3 neighborAnchorDirection = normalize(rotateVectorByQuaternion(neighborToChildA_parentFrame, relativeRotation));

            // Preserve original side assignment: if neighbor was originally cellA, keep them as cellA
            int newConnectionIndex;
            if (neighborWasCellA) {
                // Neighbor was cellA, child becomes cellB
                newConnectionIndex = addAdhesionWithDirections(neighborIndex, childAIndex, oldConnection.modeIndex, neighborAnchorDirection, childAnchorDirection);
            } else {
                // Neighbor was cellB, child becomes cellA
                newConnectionIndex = addAdhesionWithDirections(childAIndex, neighborIndex, oldConnection.modeIndex, childAnchorDirection, neighborAnchorDirection);
            }
            
            // If connection creation failed for Child A, skip logging but continue to allow Child B to inherit
            // Failure can occur if: no free adhesion indices, Child A has no free slots, or neighbor has no free slots
            if (newConnectionIndex >= 0) {
            // Use the actual cellA/cellB assignment from the connection structure
            uint actualCellA = neighborWasCellA ? neighborIndex : childAIndex;
            uint actualCellB = neighborWasCellA ? childAIndex : neighborIndex;
        }
        }
        
        // Memory barrier to ensure Child A's connection writes are visible before Child B tries to allocate slots
        // This is critical for Zone C where both children connect to the same neighbor
        memoryBarrierBuffer();

        // Child B inheritance (Zone C bonds can also create this)
        if (childBInherits) {
            // Child B's anchor: parent's anchor adjusted for child's offset, then rotated to child's frame
            // The parent's anchor points from parent's CENTER, but childB is OFFSET from parent's center
            // So we need to adjust the direction to account for this offset
            vec3 anchorEndpoint_parentFrame = localAnchorDirection * restLength;
            vec3 childBOffset_parentFrame = -splitDir_parent * splitOffset;
            vec3 childBAnchorDirection_parentFrame = normalize(anchorEndpoint_parentFrame - childBOffset_parentFrame);

            vec3 childAnchorDirection = normalize(rotateVectorByQuaternion(
                childBAnchorDirection_parentFrame,
                quatInverse(mode.orientationB)
            ));

            // Calculate neighbor's anchor: passive placement along vector from neighbor's CENTER to childB
            vec3 childBPos_parentFrame = -splitDir_parent * splitOffset;
            vec3 neighborToChildB_parentFrame = normalize(childBPos_parentFrame - neighborPos_parentFrame);

            // Transform to neighbor's local frame
            vec4 relativeRotation = quatMultiply(quatInverse(neighborCell.genomeOrientation), cell.genomeOrientation);
            vec3 neighborAnchorDirection = normalize(rotateVectorByQuaternion(neighborToChildB_parentFrame, relativeRotation));

            // Preserve original side assignment: if neighbor was originally cellA, keep them as cellA
            int newConnectionIndex;
            if (neighborWasCellA) {
                // Neighbor was cellA, child becomes cellB
                newConnectionIndex = addAdhesionWithDirections(neighborIndex, childBIndex, oldConnection.modeIndex, neighborAnchorDirection, childAnchorDirection);
            } else {
                // Neighbor was cellB, child becomes cellA
                newConnectionIndex = addAdhesionWithDirections(childBIndex, neighborIndex, oldConnection.modeIndex, childAnchorDirection, neighborAnchorDirection);
            }
            
            // If connection creation failed, skip logging but continue processing
            if (newConnectionIndex >= 0) {
            // Use the actual cellA/cellB assignment from the connection structure
            uint actualCellA_B = neighborWasCellA ? neighborIndex : childBIndex;
            uint actualCellB_B = neighborWasCellA ? childBIndex : neighborIndex;
        }
        }
    }

    // Now we need to add the adhesion connection between the children
    if (mode.parentMakeAdhesion == 0)  return;

    // Create a new adhesion connection between the two children using ONLY genome data
    // Split direction in parent's local frame
    vec3 splitDirLocal = mode.splitDirection.xyz;
    
    // Direction vectors in parent's local frame
    // Child A is at +offset, child B is at -offset
    vec3 directionAtoB_parentLocal = -splitDirLocal;  // A points toward B (at -offset)
    vec3 directionBtoA_parentLocal = splitDirLocal;   // B points toward A (at +offset)
    
    // Transform to each child's local space using genome-derived orientation deltas
    vec4 invDeltaA = quatInverse(mode.orientationA);
    vec3 anchorDirectionA = normalize(rotateVectorByQuaternion(directionAtoB_parentLocal, invDeltaA));
    
    vec4 invDeltaB = quatInverse(mode.orientationB);
    vec3 anchorDirectionB = normalize(rotateVectorByQuaternion(directionBtoA_parentLocal, invDeltaB));

    // Classify zones using genome-derived anchors
    uint childZoneA = classifyBondDirection(anchorDirectionA, mode.splitDirection.xyz, 10.0);
    uint childZoneB = classifyBondDirection(anchorDirectionB, mode.splitDirection.xyz, 10.0);

    uint childToChildConnectionIndex = getNewAdhesionIndex();
    if (childToChildConnectionIndex == uint(-1)) return;

    // Create child-to-child adhesion connection with properly classified zones
    connections[childToChildConnectionIndex] = AdhesionConnection(
        childAIndex,
        childBIndex,
        cell.modeIndex,
        1, // isActive
        childZoneA, // zoneA: Properly classified based on bond direction
        childZoneB, // zoneB: Properly classified based on bond direction
        anchorDirectionA,
        0.0, // paddingA
        anchorDirectionB,
        0.0, // paddingB
        outputCells[childAIndex].orientation,
        outputCells[childBIndex].orientation,
        uint[4](0u, 0u, 0u, 0u) // padding to ensure 16-byte alignment
    );

    // Assign to cell adhesion slots (find available slots)
    int slotA = -1, slotB = -1;
    for (int j = 0; j < 20; ++j) {
        if (outputCells[childAIndex].adhesionIndices[j] < 0 && slotA == -1) slotA = j;
        if (outputCells[childBIndex].adhesionIndices[j] < 0 && slotB == -1) slotB = j;
        if (slotA != -1 && slotB != -1) break;
    }

    if (slotA != -1 && slotB != -1) {
        outputCells[childAIndex].adhesionIndices[slotA] = int(childToChildConnectionIndex);
        outputCells[childBIndex].adhesionIndices[slotB] = int(childToChildConnectionIndex);
    }
}
