#version 430 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass;   // x, y, z, mass
    vec4 velocity;          // x, y, z, padding
    vec4 acceleration;      // x, y, z, padding
    vec4 prevAcceleration;  // x, y, z, padding
    vec4 orientation;       // Quaternion to (prevent gimbal lock)
    vec4 angularVelocity;   // Pseudo-vector for easy math
    vec4 angularAcceleration;       // Pseudo-vector for easy math
    vec4 prevAngularAcceleration;   // Pseudo-vector for easy math
    // Internal:
    vec4 signallingSubstances;  // 4 substances for now
    int modeIndex;              // absolute index of the cell's mode
    float age;                  // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
    
    // Lineage tracking (AA.BB.C format)
    uint parentLineageId;       // AA: Parent's unique ID (0 for root cells)
    uint uniqueId;              // BB: This cell's unique ID
    uint childNumber;           // C: Child number (1 or 2, 0 for root cells)
    uint _lineagePadding;       // Padding to maintain 16-byte alignment
};

struct GPUModeAdhesionSettings
{
    int canBreak;                 // bool -> int (4 bytes)
    float breakForce;
    float restLength;
    float linearSpringStiffness;
    float linearSpringDamping;
    float orientationSpringStiffness;
    float orientationSpringDamping;
    float maxAngularDeviation;
    float twistConstraintStiffness;
    float twistConstraintDamping;
    int enableTwistConstraint;    // bool -> int (4 bytes)
    int _padding;                 // pad to 48 bytes
};

// GPU Mode structure
struct GPUMode {
    vec4 color;           // R, G, B, padding
    vec4 orientationA;    // Quaternion
    vec4 orientationB;    // Quaternion
    vec4 splitDirection;  // x, y, z, padding
    ivec2 childModes;     // mode indices for children
    float splitInterval;
    int genomeOffset;
    GPUModeAdhesionSettings adhesionSettings;
    int parentMakeAdhesion; // Boolean flag for adhesion creation
    int childAKeepAdhesion; // Boolean flag for child A to keep adhesion
    int childBKeepAdhesion; // Boolean flag for child B to keep adhesion
    int maxAdhesions;       // Max number of adhesions
};

// Adhesion connection structure - stores permanent connections between sibling cells
struct AdhesionConnection {
    uint cellAIndex;      // Index of first cell in the connection
    uint cellBIndex;      // Index of second cell in the connection
    uint modeIndex;       // Mode index for the connection ( to lookup adhesion settings )
    uint isActive;        // Whether this connection is still active (1 = active, 0 = inactive)
    vec3 anchorDirectionA; // Anchor direction for cell A in local cell space (normalized)
    float paddingA;       // Padding to ensure 16-byte alignment
    vec3 anchorDirectionB; // Anchor direction for cell B in local cell space (normalized)
    float paddingB;       // Padding to ensure 16-byte alignment
    vec4 twistReferenceA; // Reference quaternion for twist constraint for cell A (16 bytes)
    vec4 twistReferenceB; // Reference quaternion for twist constraint for cell B (16 bytes)
};

// Enhanced diagnostic entry structure - matches C++ EnhancedDiagnosticEntry
struct EnhancedDiagnosticEntry {
    // Core event data
    uint eventType;           // DiagnosticEventType
    uint frameIndex;          // Frame when event occurred
    uint cellA;               // Primary cell involved
    uint cellB;               // Secondary cell (if applicable, -1 otherwise)
    
    // Event-specific data
    uint connectionIndex;     // For adhesion events
    uint modeIndex;           // Mode of primary cell
    uint splitEventID;        // Groups related split events
    uint parentCellID;        // For inheritance tracking
    
    // Spatial data
    float positionA[3];       // Position of cell A
    float positionB[3];       // Position of cell B (if applicable)
    float anchorDirA[3];      // Anchor direction for cell A
    float anchorDirB[3];      // Anchor direction for cell B
    
    // Physics data
    float velocityA[3];       // Velocity of cell A
    float velocityB[3];       // Velocity of cell B (if applicable)
    float massA;              // Mass of cell A
    float massB;              // Mass of cell B (if applicable)
    
    // Cell state data
    float ageA;               // Age of cell A
    float ageB;               // Age of cell B (if applicable)
    float toxinsA;            // Toxin level of cell A
    float toxinsB;            // Toxin level of cell B (if applicable)
    float nitratesA;          // Nitrate level of cell A
    float nitratesB;          // Nitrate level of cell B (if applicable)
    
    // Signaling substances
    float signallingA[4];     // Signalling substances of cell A
    float signallingB[4];     // Signalling substances of cell B
    
    // Additional event data
    float eventValue1;        // Generic event-specific value 1
    float eventValue2;        // Generic event-specific value 2
    uint eventFlags;          // Bit flags for event properties
    
    // Padding to ensure 16-byte alignment
    float _padding[3];
};

layout(std430, binding = 0) restrict buffer ReadCellBuffer {
    ComputeCell inputCells[];
};

layout(std430, binding = 1) restrict buffer modeBuffer {
    GPUMode modes[];
};

layout(std430, binding = 2) restrict buffer WriteCellBuffer {
    ComputeCell outputCells[];
};

layout(std430, binding = 3) coherent buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    int freeAdhesionTop;
};

layout(std430, binding = 4) coherent buffer AdhesionConnectionBuffer {
    AdhesionConnection connections[];
};

layout(std430, binding = 5) coherent buffer freeCellSlotBuffer {
    uint freeCellSlotIndices[];
};

layout(std430, binding = 6) coherent buffer freeAdhesionSlotBuffer {
    uint freeAdhesionSlotIndices[];
};

layout(std430, binding = 7) coherent buffer EnhancedDiagnosticBuffer {
    EnhancedDiagnosticEntry diagnosticEntries[];
};

layout(std430, binding = 8) coherent buffer DiagnosticCountBuffer {
    uint diagnosticCount;
};

layout(std430, binding = 9) coherent buffer UniqueIdBuffer {
    uint nextUniqueId;
};

uniform float u_deltaTime;
uniform int u_maxCells;
uniform int u_maxAdhesions;
uniform int u_enableAdhesionDiagnostics;
uniform int u_currentFrame;
// Use a simple frame counter for diagnostics
uint u_frameNumber = 1u;

vec4 quatMultiply(vec4 q1, vec4 q2) {
    return vec4(
        q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y,
        q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x,
        q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w,
        q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z
    );
}

vec3 rotateVectorByQuaternion(vec3 v, vec4 q) {
    // v' = q * v * q^-1
    // Optimized version using cross product:
    vec3 u = q.xyz;
    float s = q.w;

    return 2.0 * dot(u, v) * u
         + (s * s - dot(u, u)) * v
         + 2.0 * s * cross(u, v);
}

vec4 quatInverse(vec4 q) {
    float norm = dot(q, q);
    if (norm > 0.0) {
        return vec4(-q.xyz, q.w) / norm;
    }
    return vec4(0.0, 0.0, 0.0, 1.0);
}

// Hash function to generate a pseudo-random float in [0,1] from a uint seed
float hash11(uint n) {
    n = (n ^ 61u) ^ (n >> 16u);
    n *= 9u;
    n = n ^ (n >> 4u);
    n *= 0x27d4eb2du;
    n = n ^ (n >> 15u);
    return float(n & 0x00FFFFFFu) / float(0x01000000u);
}

// Create a small random quaternion for a tiny rotation (angle in radians)
vec4 smallRandomQuat(float angle, uint seed) {
    // Random axis
    float rand1 = hash11(seed * 3u + 0u);
    float rand2 = hash11(seed * 3u + 1u);
    float rand3 = hash11(seed * 3u + 2u);
    vec3 axis = normalize(vec3(rand1, rand2, rand3) * 2.0 - 1.0);
    float halfAngle = angle * 0.5;
    float s = sin(halfAngle);
    return normalize(vec4(axis * s, cos(halfAngle)));
}

// Function to log enhanced diagnostic entries
void logEnhancedDiagnostic(uint eventType, uint cellA, uint cellB, uint connectionIndex, 
                          uint modeIndex, uint splitEventID, uint parentCellID,
                          vec3 anchorDirA, vec3 anchorDirB, float eventValue1, float eventValue2) {
    if (u_enableAdhesionDiagnostics == 0) return;
    
    // Atomically increment the counter and get the index
    uint index = atomicAdd(diagnosticCount, 1u);
    
    // Check if we have space in the buffer
    if (index >= diagnosticEntries.length()) return;
    
    // Create the enhanced diagnostic entry
    EnhancedDiagnosticEntry entry;
    
    // Core event data
    entry.eventType = eventType;
    entry.frameIndex = uint(u_currentFrame);
    entry.cellA = cellA;
    entry.cellB = cellB;
    
    // Event-specific data
    entry.connectionIndex = connectionIndex;
    entry.modeIndex = modeIndex;
    entry.splitEventID = splitEventID;
    entry.parentCellID = parentCellID;
    
    // Get cell data for comprehensive logging
    if (cellA < inputCells.length()) {
        ComputeCell cellDataA = inputCells[cellA];
        entry.positionA[0] = cellDataA.positionAndMass.x;
        entry.positionA[1] = cellDataA.positionAndMass.y;
        entry.positionA[2] = cellDataA.positionAndMass.z;
        entry.velocityA[0] = cellDataA.velocity.x;
        entry.velocityA[1] = cellDataA.velocity.y;
        entry.velocityA[2] = cellDataA.velocity.z;
        entry.massA = cellDataA.positionAndMass.w;
        entry.ageA = cellDataA.age;
        entry.toxinsA = cellDataA.toxins;
        entry.nitratesA = cellDataA.nitrates;
        entry.signallingA[0] = cellDataA.signallingSubstances.x;
        entry.signallingA[1] = cellDataA.signallingSubstances.y;
        entry.signallingA[2] = cellDataA.signallingSubstances.z;
        entry.signallingA[3] = cellDataA.signallingSubstances.w;
    }
    
    // Get second cell data if applicable
    if (cellB != 0xFFFFFFFF && cellB < inputCells.length()) {
        ComputeCell cellDataB = inputCells[cellB];
        entry.positionB[0] = cellDataB.positionAndMass.x;
        entry.positionB[1] = cellDataB.positionAndMass.y;
        entry.positionB[2] = cellDataB.positionAndMass.z;
        entry.velocityB[0] = cellDataB.velocity.x;
        entry.velocityB[1] = cellDataB.velocity.y;
        entry.velocityB[2] = cellDataB.velocity.z;
        entry.massB = cellDataB.positionAndMass.w;
        entry.ageB = cellDataB.age;
        entry.toxinsB = cellDataB.toxins;
        entry.nitratesB = cellDataB.nitrates;
        entry.signallingB[0] = cellDataB.signallingSubstances.x;
        entry.signallingB[1] = cellDataB.signallingSubstances.y;
        entry.signallingB[2] = cellDataB.signallingSubstances.z;
        entry.signallingB[3] = cellDataB.signallingSubstances.w;
    } else {
        // Clear second cell data if not applicable
        entry.positionB[0] = 0.0f; entry.positionB[1] = 0.0f; entry.positionB[2] = 0.0f;
        entry.velocityB[0] = 0.0f; entry.velocityB[1] = 0.0f; entry.velocityB[2] = 0.0f;
        entry.massB = 0.0f; entry.ageB = 0.0f; entry.toxinsB = 0.0f; entry.nitratesB = 0.0f;
        entry.signallingB[0] = 0.0f; entry.signallingB[1] = 0.0f; entry.signallingB[2] = 0.0f; entry.signallingB[3] = 0.0f;
    }
    
    // Anchor directions
    entry.anchorDirA[0] = anchorDirA.x;
    entry.anchorDirA[1] = anchorDirA.y;
    entry.anchorDirA[2] = anchorDirA.z;
    entry.anchorDirB[0] = anchorDirB.x;
    entry.anchorDirB[1] = anchorDirB.y;
    entry.anchorDirB[2] = anchorDirB.z;
    
    // Event values
    entry.eventValue1 = eventValue1;
    entry.eventValue2 = eventValue2;
    entry.eventFlags = 0u;
    
    // Padding
    entry._padding[0] = 0.0f;
    entry._padding[1] = 0.0f;
    entry._padding[2] = 0.0f;
    
    // Write the entry to the buffer
    diagnosticEntries[index] = entry;
}

// Legacy wrapper function for backward compatibility
void logAdhesionDiagnostic(uint connectionIndex, uint cellA, uint cellB, uint modeIndex, 
                          uint reasonCode, vec3 anchorDirA, vec3 anchorDirB, 
                          uint frameIndex, uint splitEventID, uint parentCellID, 
                          uint inheritanceType, uint originalConnectionIndex, float adhesionZone) {
    // Map legacy reason codes to enhanced event types (adhesion events are 0-29)
    logEnhancedDiagnostic(reasonCode, cellA, cellB, connectionIndex, modeIndex, 
                         splitEventID, parentCellID, anchorDirA, anchorDirB, 
                         adhesionZone, float(inheritanceType));
}

uint getNewAdhesionIndex() {
    // Try to reserve a free adhesion slot
    // Snapshot free top value without modifying it first
    int freeTopBefore = freeAdhesionTop;
    if (freeTopBefore > 0) {
        // Now reserve slot *safely*
        int freeTop = atomicAdd(freeAdhesionTop, -1);
        if (freeTop > 0) {
            return freeAdhesionSlotIndices[freeTop - 1];
        } else {
            // Another thread raced and depleted the stack before we got here
            atomicAdd(freeAdhesionTop, 1); // revert
        }
    }

    // Fallback to allocating a new slot
    uint newAdhesionIndex = atomicAdd(totalAdhesionCount, 1);
    if (newAdhesionIndex >= u_maxAdhesions) {
        atomicMin(totalAdhesionCount, u_maxAdhesions);
        return -1;
    }
    return newAdhesionIndex;
}

// Add adhesion with preserved anchor directions (for inheritance)
// Returns the connection index on success, -1 on failure
int addAdhesionWithDirections(uint cellAIndex, uint cellBIndex, uint modeIndex, vec3 preservedAnchorA, vec3 preservedAnchorB) {
    uint newAdhesionIndex = getNewAdhesionIndex();
    if (newAdhesionIndex == uint(-1)) {
        // Failed to reserve an adhesion index
        return -1;
    }

    // Check for available slot in cell A
    int slotA = -1;
    for (int j = 0; j < 20; ++j) {
        if (outputCells[cellAIndex].adhesionIndices[j] < 0) {
            slotA = j;
            break;
        }
    }

    // Check for available slot in cell B
    int slotB = -1;
    for (int j = 0; j < 20; ++j) {
        if (outputCells[cellBIndex].adhesionIndices[j] < 0) {
            slotB = j;
            break;
        }
    }

    if (slotA == -1 || slotB == -1) {
        // Roll back the reservation if any cell has no free slot
        int reservation = atomicAdd(freeAdhesionTop, 1);
        int topIndex = reservation;
        freeAdhesionSlotIndices[topIndex] = newAdhesionIndex;
        return -1;
    }

    // Use the preserved anchor directions directly (already in local space)
    vec3 anchorDirectionA = preservedAnchorA;
    vec3 anchorDirectionB = preservedAnchorB;

    // Store current orientations as twist reference for constraint
    vec4 twistReferenceA = inputCells[cellAIndex].orientation;
    vec4 twistReferenceB = inputCells[cellBIndex].orientation;

    // Write connection and assign indices
    connections[newAdhesionIndex] = AdhesionConnection(
        cellAIndex,
        cellBIndex,
        modeIndex,
        1,
        anchorDirectionA,
        0.0, // paddingA
        anchorDirectionB,
        0.0, // paddingB
        twistReferenceA,
        twistReferenceB
    );
    outputCells[cellAIndex].adhesionIndices[slotA] = int(newAdhesionIndex);
    outputCells[cellBIndex].adhesionIndices[slotB] = int(newAdhesionIndex);
    
    return int(newAdhesionIndex);
}

bool addAdhesion(uint cellAIndex, uint cellBIndex, uint modeIndex) {
    uint newAdhesionIndex = getNewAdhesionIndex();
    if (newAdhesionIndex == uint(-1)) {
        // Failed to reserve an adhesion index
        return false;
    }

    // Check for available slot in cell A
    int slotA = -1;
    for (int j = 0; j < 20; ++j) {
        if (outputCells[cellAIndex].adhesionIndices[j] < 0) {
            slotA = j;
            break;
        }
    }

    // Check for available slot in cell B
    int slotB = -1;
    for (int j = 0; j < 20; ++j) {
        if (outputCells[cellBIndex].adhesionIndices[j] < 0) {
            slotB = j;
            break;
        }
    }

    if (slotA == -1 || slotB == -1) {
        // Roll back the reservation if any cell has no free slot
        int reservation = atomicAdd(freeAdhesionTop, 1);
        int topIndex = reservation;
        freeAdhesionSlotIndices[topIndex] = newAdhesionIndex;
        return false;
    }

    // Calculate initial anchor directions in local cell space
    // Use spatial calculation since this is called immediately after split when positions are correct
    vec3 posA = inputCells[cellAIndex].positionAndMass.xyz;
    vec3 posB = inputCells[cellBIndex].positionAndMass.xyz;
    
    // Calculate direction vectors from each cell to the other in world space
    vec3 directionAtoB = normalize(posB - posA);
    vec3 directionBtoA = normalize(posA - posB);
    
    // Transform world space directions to local cell space using inverse cell orientations
    // This ensures anchors are stored relative to the cell's local coordinate system
    vec4 invOrientationA = quatInverse(inputCells[cellAIndex].orientation);
    vec4 invOrientationB = quatInverse(inputCells[cellBIndex].orientation);
    
    vec3 anchorDirectionA = rotateVectorByQuaternion(directionAtoB, invOrientationA);
    vec3 anchorDirectionB = rotateVectorByQuaternion(directionBtoA, invOrientationB);

    // Store current orientations as twist reference for constraint
    vec4 twistReferenceA = inputCells[cellAIndex].orientation;
    vec4 twistReferenceB = inputCells[cellBIndex].orientation;

    // Write connection and assign indices
    connections[newAdhesionIndex] = AdhesionConnection(
        cellAIndex,
        cellBIndex,
        modeIndex,
        1,
        anchorDirectionA,
        0.0, // paddingA
        anchorDirectionB,
        0.0, // paddingB
        twistReferenceA,
        twistReferenceB
    );
    outputCells[cellAIndex].adhesionIndices[slotA] = int(newAdhesionIndex);
    outputCells[cellBIndex].adhesionIndices[slotB] = int(newAdhesionIndex);
    
    // Log diagnostic entry for direct adhesion creation
    logAdhesionDiagnostic(
        newAdhesionIndex, cellAIndex, cellBIndex, modeIndex,
        1, // reasonCode: Direct
        anchorDirectionA, anchorDirectionB,
        u_frameNumber, 0u, // frameIndex, splitEventID (0 for direct)
        0u, 0u, 0u, 0.0 // parentCellID, inheritanceType, originalConnectionIndex, adhesionZone
    );
    
    return true;
}

void removeAdhesion(int adhesionIndex){
    // Log diagnostic entry for adhesion removal
    if (adhesionIndex >= 0 && adhesionIndex < connections.length()) {
        AdhesionConnection conn = connections[adhesionIndex];
        logAdhesionDiagnostic(
            uint(adhesionIndex), conn.cellAIndex, conn.cellBIndex, conn.modeIndex,
            2, // reasonCode: Broken
            conn.anchorDirectionA, conn.anchorDirectionB,
            u_frameNumber, 0u, // frameIndex, splitEventID (0 for general removal)
            0u, 0u, 0u, 0.0 // parentCellID, inheritanceType, originalConnectionIndex, adhesionZone
        );
    }
    
    // Mark as inactive
    
    // Remove from cellA
    connections[adhesionIndex].isActive = 0;
    for (int i = 0; i < 20; ++i) {
        if (outputCells[connections[adhesionIndex].cellAIndex].adhesionIndices[i] == adhesionIndex) {
            outputCells[connections[adhesionIndex].cellAIndex].adhesionIndices[i] = -1;
            break;
        }
    }

    // Remove from cellB
    for (int i = 0; i < 20; ++i) {
        if (outputCells[connections[adhesionIndex].cellBIndex].adhesionIndices[i] == adhesionIndex) {
            outputCells[connections[adhesionIndex].cellBIndex].adhesionIndices[i] = -1;
            break;
        }
    }

    // Push to free stack safely
    int freeIndex = atomicAdd(freeAdhesionTop, 1);
    if (freeIndex < u_maxAdhesions) {
        freeAdhesionSlotIndices[freeIndex] = adhesionIndex;
    } else {
        freeAdhesionTop = u_maxAdhesions;
    }
}

float priority(uint seed) {
    // Generate a pseudo-random priority based on the seed
    return hash11(seed ^ u_frameNumber);
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= totalCellCount) return;

    ComputeCell cell = inputCells[index];
    GPUMode mode = modes[cell.modeIndex];

    outputCells[index] = cell; // Default output is the same cell

    if (cell.age < mode.splitInterval) return;

    int adhesionCount = 0;
    for (int i = 0; i < 20; ++i) {
        if (cell.adhesionIndices[i] >= 0) {
            adhesionCount++;
        }
    }
    if (adhesionCount >= mode.maxAdhesions) return; // Too many adhesions, cannot split

    // Begin split logic

    // === Compute Split Priority ===
    float myPriority = priority(index);

    // === Check Adhered Cells ===
    for (int i = 0; i < 20; ++i) {
        int adhesionIdx = cell.adhesionIndices[i];
        if (adhesionIdx < 0) continue;

        AdhesionConnection conn = connections[adhesionIdx];
        if (conn.isActive == 0) continue;

        uint otherIndex = (conn.cellAIndex == index) ? conn.cellBIndex : conn.cellAIndex;
        ComputeCell other = inputCells[otherIndex];
        GPUMode otherMode = modes[other.modeIndex];

        if (other.age < otherMode.splitInterval) continue; // Other cell not splitting

        // If other cell wants to split, compare priority
        float otherPriority = priority(otherIndex);
        if (otherPriority < myPriority) {
            // Defer this split - other cell has higher priority (lower index)
            return;
        }
    }
    
    // CRITICAL FIX: Replace atomic splitting with safer reservation system
    // First, check if we have space for a new cell
    uint currentCount = totalCellCount;
    if (currentCount >= u_maxCells) {
        // No space available, cancel the split
        outputCells[index] = cell;
        return;
    }
    
    // Try to reserve a slot atomically
    uint newIndex = atomicAdd(totalCellCount, 1);
    
    // Check if we successfully got a valid slot
    if (newIndex >= u_maxCells) {
        // We exceeded the limit, rollback and cancel
        atomicAdd(totalCellCount, -1);
        outputCells[index] = cell;
        return;
    }
    
    // Successfully reserved a slot, increment live count
    atomicAdd(liveCellCount, 1);
    
    // CRITICAL FIX: Add memory barrier to ensure atomic operations are complete
    memoryBarrierBuffer();
    
    // CRITICAL FIX: Double-check bounds after memory barrier
    if (newIndex >= u_maxCells) {
        // Rollback the increment if we're still out of bounds
        atomicAdd(totalCellCount, -1);
        atomicAdd(liveCellCount, -1);
        outputCells[index] = cell;
        return;
    }

    uint childAIndex = index;
    uint childBIndex = newIndex;

    vec3 offset = rotateVectorByQuaternion(mode.splitDirection.xyz, cell.orientation) * 0.5;

    // Both child cells should start with the same age after the split
    // Since we already aged the parent cell by deltaTime this frame,
    // we need to subtract the excess age beyond the split interval
    float startAge = cell.age - mode.splitInterval;

    // Apply rotation deltas to parent orientation
    vec4 q_parent = cell.orientation;
    vec4 q_childA = normalize(quatMultiply(q_parent, mode.orientationA));
    vec4 q_childB = normalize(quatMultiply(q_parent, mode.orientationB));

    // Add a tiny random variance to each child orientation (0.001 degree = 0.001 * PI / 180 radians)
    float tinyAngle = 0.001 * 0.017453292519943295; // radians

    // Use child indices to generate different seeds for each child
    vec4 q_varA = smallRandomQuat(tinyAngle, childAIndex);
    vec4 q_varB = smallRandomQuat(tinyAngle, childBIndex);
    q_childA = normalize(quatMultiply(q_childA, q_varA));
    q_childB = normalize(quatMultiply(q_childB, q_varB));

    ComputeCell childA = cell;
    childA.positionAndMass.xyz += offset;
    childA.age = startAge;
    childA.modeIndex = mode.childModes.x;
    childA.orientation = q_childA;
    // Lineage tracking: Child A inherits parent's unique ID and becomes child 1
    childA.parentLineageId = cell.uniqueId;  // Parent's unique ID becomes child's parent lineage ID
    childA.uniqueId = atomicAdd(nextUniqueId, 1); // Get next unique ID atomically
    childA.childNumber = 1;  // First child
    for (int i = 0; i < 20; ++i) {
        childA.adhesionIndices[i] = -1; // Reset adhesion indices for the new child
    }

    ComputeCell childB = cell;
    childB.positionAndMass.xyz -= offset;
    childB.age = startAge + 0.001;
    childB.modeIndex = mode.childModes.y;
    childB.orientation = q_childB;
    // Lineage tracking: Child B gets new unique ID and becomes child 2
    childB.parentLineageId = cell.uniqueId;  // Parent's unique ID becomes child's parent lineage ID
    childB.uniqueId = atomicAdd(nextUniqueId, 1); // Get next unique ID atomically
    childB.childNumber = 2;  // Second child
    for (int i = 0; i < 20; ++i) {
        childB.adhesionIndices[i] = -1; // Reset adhesion indices for the new child
    }
    
    // Store new cells
    outputCells[childAIndex] = childA;
    outputCells[childBIndex] = childB;
    
    // CRITICAL FIX: Also write to input buffer to maintain consistency across all buffers
    inputCells[childAIndex] = childA;
    inputCells[childBIndex] = childB;
    
    // Log diagnostic events for cell lifecycle
    // Cell split start event for parent
    logEnhancedDiagnostic(
        32u, // CELL_SPLIT_START
        childAIndex, // Parent cell (childA takes parent's index)
        childBIndex, // New child cell
        0xFFFFFFFF, // No connection index
        cell.modeIndex, // Parent's mode
        1u, // Split event ID
        childAIndex, // Parent cell ID
        vec3(0.0), vec3(0.0), // No anchor directions for lifecycle events
        cell.age, float(mode.splitInterval) // Event values: actual age, split interval
    );
    
    // Debug output for lineage tracking (this will be visible in console)
    // Note: This is a simple way to verify lineage assignment works
    // In a real implementation, you might want to use a more sophisticated logging system
    
    // Cell birth event for new child
    logEnhancedDiagnostic(
        30u, // CELL_BIRTH
        childBIndex, // New child cell
        0xFFFFFFFF, // No second cell
        0xFFFFFFFF, // No connection index
        childB.modeIndex, // Child's mode
        1u, // Split event ID
        childAIndex, // Parent cell ID
        vec3(0.0), vec3(0.0), // No anchor directions for lifecycle events
        startAge, float(mode.splitInterval) // Event values: starting age, split interval
    );
    
    // Cell split complete event for parent (now childA)
    logEnhancedDiagnostic(
        33u, // CELL_SPLIT_COMPLETE
        childAIndex, // Parent cell (now childA)
        childBIndex, // New child cell
        0xFFFFFFFF, // No connection index
        childA.modeIndex, // Parent's new mode
        1u, // Split event ID
        childAIndex, // Parent cell ID
        vec3(0.0), vec3(0.0), // No anchor directions for lifecycle events
        startAge, float(mode.splitInterval) // Event values: starting age, split interval
    );

    // Inherit adhesions for the new child cells
    for (int i = 0; i < 20; ++i) {
        int oldAdhesionIndex = cell.adhesionIndices[i];
        if (oldAdhesionIndex < 0) continue;

        AdhesionConnection oldConnection = connections[oldAdhesionIndex];
        if (oldConnection.isActive == 0) continue;

        // CRITICAL FIX: Add memory barrier before modifying adhesion connections
        memoryBarrierBuffer();

        // Determine who the parent was connected to
        uint neighborIndex = (oldConnection.cellAIndex == childAIndex)
            ? oldConnection.cellBIndex
            : oldConnection.cellAIndex;

        // Remove the old connection
        removeAdhesion(oldAdhesionIndex);

        // Use stored anchor direction instead of spatial calculation
        // Determine which anchor direction to use based on parent's role in the connection
        bool isParentCellA = (oldConnection.cellAIndex == childAIndex); // childAIndex is same as parent index
        vec3 localAnchorDirection = isParentCellA ? oldConnection.anchorDirectionA : oldConnection.anchorDirectionB;
        
        // Genome-only zone test: compare in parent-local space
        float adhesionZone = dot(localAnchorDirection, mode.splitDirection.xyz);
        // Make selection disjoint to avoid double-inheritance. Use sign only.
        // adhesionZone >= 0 => Child A side, adhesionZone < 0 => Child B side

        // Create proper cousin pairing: A1↔B1 and A2↔B2, avoiding cross connections
        // Use both parent's and neighbor's split directions to determine correct inheritance
        
        // Get neighbor's mode to access its split direction
        ComputeCell neighborCell = inputCells[neighborIndex];
        GPUMode neighborMode = modes[neighborCell.modeIndex];
        
        // Determine which child should inherit based on both split directions
        // Parent's split direction determines which of our children inherits
        bool childAInherits = (adhesionZone >= 0.0);
        bool childBInherits = (adhesionZone < 0.0);
        
        // Determine neighbor's role in the original connection
        bool neighborWasCellA = (oldConnection.cellAIndex == neighborIndex);
        vec3 neighborAnchorDirection = neighborWasCellA ? oldConnection.anchorDirectionA : oldConnection.anchorDirectionB;
        
        // Only one child inherits each connection to avoid cross connections
        if (mode.childAKeepAdhesion == 1 && childAInherits) {
            // Genome-only transform: rotate parent's local anchor into child A's local space via inverse of delta quat
            vec4 invDeltaA = quatInverse(mode.orientationA);
            vec3 childAnchorDirection = rotateVectorByQuaternion(localAnchorDirection, invDeltaA);
            
            int newConnectionIndex = addAdhesionWithDirections(childAIndex, neighborIndex, oldConnection.modeIndex, childAnchorDirection, neighborAnchorDirection);
            if (newConnectionIndex < 0) return;
            
            // Log diagnostic entry for inherited connection (Child A)
            logAdhesionDiagnostic(
                uint(newConnectionIndex), childAIndex, neighborIndex, oldConnection.modeIndex,
                0, // reasonCode: Inherited
                childAnchorDirection, neighborAnchorDirection,
                u_frameNumber, 1u, // frameIndex, splitEventID (1 for split event)
                childAIndex, 1u, uint(oldAdhesionIndex), adhesionZone // parentCellID, inheritanceType (1=childA_keeps), originalConnectionIndex, adhesionZone
            );
        }
        else if (mode.childBKeepAdhesion == 1 && childBInherits) {
            // Genome-only transform: rotate parent's local anchor into child B's local space via inverse of delta quat
            vec4 invDeltaB = quatInverse(mode.orientationB);
            vec3 childAnchorDirection = rotateVectorByQuaternion(localAnchorDirection, invDeltaB);
            
            int newConnectionIndex = addAdhesionWithDirections(childBIndex, neighborIndex, oldConnection.modeIndex, childAnchorDirection, neighborAnchorDirection);
            if (newConnectionIndex < 0) return;
            
            // Log diagnostic entry for inherited connection (Child B)
            logAdhesionDiagnostic(
                uint(newConnectionIndex), childBIndex, neighborIndex, oldConnection.modeIndex,
                0, // reasonCode: Inherited
                childAnchorDirection, neighborAnchorDirection,
                u_frameNumber, 1u, // frameIndex, splitEventID (1 for split event)
                childAIndex, 2u, uint(oldAdhesionIndex), adhesionZone // parentCellID, inheritanceType (2=childB_keeps), originalConnectionIndex, adhesionZone
            );
        }
    }
    
    // Now we need to add the adhesion connection between the children
    if (mode.parentMakeAdhesion == 0)  return;
    
    // Create a new adhesion connection between the two children
    if (!addAdhesion(childAIndex, childBIndex, cell.modeIndex)) return;
}