#version 430 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass;   // x, y, z, mass
    vec4 velocity;          // x, y, z, padding
    vec4 acceleration;      // x, y, z, padding
    vec4 prevAcceleration;  // x, y, z, padding
    vec4 orientation;       // Quaternion to (prevent gimbal lock)
    vec4 angularVelocity;   // Pseudo-vector for easy math
    vec4 angularAcceleration;       // Pseudo-vector for easy math
    vec4 prevAngularAcceleration;   // Pseudo-vector for easy math
    // Internal:
    vec4 signallingSubstances;  // 4 substances for now
    int modeIndex;              // absolute index of the cell's mode
    float age;                  // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
    
    // Lineage tracking (AA.BB.C format)
    uint parentLineageId;       // AA: Parent's unique ID (0 for root cells)
    uint uniqueId;              // BB: This cell's unique ID
    uint childNumber;           // C: Child number (1 or 2, 0 for root cells)
    uint _lineagePadding;       // Padding to maintain 16-byte alignment
};

struct GPUModeAdhesionSettings
{
    int canBreak;                 // bool -> int (4 bytes)
    float breakForce;
    float restLength;
    float linearSpringStiffness;
    float linearSpringDamping;
    float orientationSpringStiffness;
    float orientationSpringDamping;
    float maxAngularDeviation;
    float twistConstraintStiffness;
    float twistConstraintDamping;
    int enableTwistConstraint;    // bool -> int (4 bytes)
    int _padding;                 // pad to 48 bytes
};

// GPU Mode structure
struct GPUMode {
    vec4 color;
    vec4 orientationA;
    vec4 orientationB;
    vec4 splitDirection;
    ivec2 childModes;
    float splitInterval;
    int genomeOffset;
    GPUModeAdhesionSettings adhesionSettings;
    int parentMakeAdhesion;
    int childAKeepAdhesion;
    int childBKeepAdhesion;
    int maxAdhesions;
    float flagellocyteSwimSpeed;
    float flagellocyteNutrientConsumption;
    float nutrientPriority;
    int cellType;
};

// Adhesion connection structure - stores permanent connections between sibling cells
struct AdhesionConnection {
    uint cellAIndex;      // Index of first cell in the connection
    uint cellBIndex;      // Index of second cell in the connection
    uint modeIndex;       // Mode index for the connection ( to lookup adhesion settings )
    uint isActive;        // Whether this connection is still active (1 = active, 0 = inactive)
    uint zoneA;           // Zone classification for cell A (0=ZoneA, 1=ZoneB, 2=ZoneC)
    uint zoneB;           // Zone classification for cell B (0=ZoneA, 1=ZoneB, 2=ZoneC)
    vec3 anchorDirectionA; // Anchor direction for cell A in local cell space (normalized)
    float paddingA;       // Padding to ensure 16-byte alignment
    vec3 anchorDirectionB; // Anchor direction for cell B in local cell space (normalized)
    float paddingB;       // Padding to ensure 16-byte alignment
    vec4 twistReferenceA; // Reference quaternion for twist constraint for cell A (16 bytes)
    vec4 twistReferenceB; // Reference quaternion for twist constraint for cell B (16 bytes)
    uint _padding[4];     // Padding to ensure 16-byte alignment (96 bytes total)
};

// Enhanced diagnostic entry structure - matches C++ EnhancedDiagnosticEntry
struct EnhancedDiagnosticEntry {
    // Core event data
    uint eventType;           // DiagnosticEventType
    uint frameIndex;          // Frame when event occurred
    uint cellA;               // Primary cell involved
    uint cellB;               // Secondary cell (if applicable, -1 otherwise)

    // Event-specific data
    uint connectionIndex;     // For adhesion events
    uint modeIndex;           // Mode of primary cell
    uint splitEventID;        // Groups related split events
    uint parentCellID;        // For inheritance tracking

    // Spatial data
    float positionA[3];       // Position of cell A
    float positionB[3];       // Position of cell B (if applicable)
    float anchorDirA[3];      // Anchor direction for cell A
    float anchorDirB[3];      // Anchor direction for cell B

    // Physics data
    float velocityA[3];       // Velocity of cell A
    float velocityB[3];       // Velocity of cell B (if applicable)
    float massA;              // Mass of cell A
    float massB;              // Mass of cell B (if applicable)

    // Cell state data
    float ageA;               // Age of cell A
    float ageB;               // Age of cell B (if applicable)
    float toxinsA;            // Toxin level of cell A
    float toxinsB;            // Toxin level of cell B (if applicable)
    float nitratesA;          // Nitrate level of cell A
    float nitratesB;          // Nitrate level of cell B (if applicable)

    // Signaling substances
    float signallingA[4];     // Signalling substances of cell A
    float signallingB[4];     // Signalling substances of cell B

    // Lineage data for cell A
    uint lineageA_parentId;   // Parent unique ID for cell A
    uint lineageA_uniqueId;   // Unique ID for cell A
    uint lineageA_childNum;   // Child number for cell A

    // Lineage data for cell B
    uint lineageB_parentId;   // Parent unique ID for cell B
    uint lineageB_uniqueId;   // Unique ID for cell B
    uint lineageB_childNum;   // Child number for cell B

    // Additional event data
    float eventValue1;        // Generic event-specific value 1
    float eventValue2;        // Generic event-specific value 2
    uint eventFlags;          // Bit flags for event properties

    // Padding to ensure 16-byte alignment (added 6 uint32_t fields = 24 bytes)
    float _padding[1];
};

layout(std430, binding = 0) restrict buffer ReadCellBuffer {
    ComputeCell inputCells[];
};

layout(std430, binding = 1) restrict buffer modeBuffer {
    GPUMode modes[];
};

layout(std430, binding = 2) restrict buffer WriteCellBuffer {
    ComputeCell outputCells[];
};

layout(std430, binding = 3) coherent buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    int freeAdhesionTop;
};

layout(std430, binding = 4) coherent buffer AdhesionConnectionBuffer {
    AdhesionConnection connections[];
};

layout(std430, binding = 5) coherent buffer freeCellSlotBuffer {
    uint freeCellSlotIndices[];
};

layout(std430, binding = 6) coherent buffer freeAdhesionSlotBuffer {
    uint freeAdhesionSlotIndices[];
};

layout(std430, binding = 7) coherent buffer EnhancedDiagnosticBuffer {
    EnhancedDiagnosticEntry diagnosticEntries[];
};

layout(std430, binding = 8) coherent buffer DiagnosticCountBuffer {
    uint diagnosticCount;
};

layout(std430, binding = 9) coherent buffer UniqueIdBuffer {
    uint nextUniqueId;
};

uniform float u_deltaTime;
uniform int u_maxCells;
uniform int u_maxAdhesions;
uniform int u_enableAdhesionDiagnostics;
uniform int u_currentFrame;

vec4 quatMultiply(vec4 q1, vec4 q2) {
    return vec4(
        q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y,
        q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x,
        q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w,
        q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z
    );
}

// Classify bond direction into zones (A, B, C) based on angle from split direction
// Based on Unity CellAdhesionManager classification logic
uint classifyBondDirection(vec3 bondDirLocal, vec3 splitDirLocal, float inheritanceAngleDeg) {
    float dot = dot(bondDirLocal, splitDirLocal);
    float angle = acos(clamp(dot, -1.0, 1.0)) * 180.0 / 3.141592653589793; // Convert to degrees
    float halfWidth = inheritanceAngleDeg * 1.0;
    float equatorialAngle = 90.0;

    if (abs(angle - equatorialAngle) <= halfWidth)
        return 2u; // Zone C (equatorial)
    else if (dot > 0.0)
        return 1u; // Zone B (positive dot product)
    else
        return 0u; // Zone A (negative dot product)
}

vec3 rotateVectorByQuaternion(vec3 v, vec4 q) {
    // v' = q * v * q^-1
    // Optimized version using cross product:
    vec3 u = q.xyz;
    float s = q.w;

    return 2.0 * dot(u, v) * u
         + (s * s - dot(u, u)) * v
         + 2.0 * s * cross(u, v);
}

vec4 quatInverse(vec4 q) {
    float norm = dot(q, q);
    if (norm > 0.0) {
        return vec4(-q.xyz, q.w) / norm;
    }
    return vec4(0.0, 0.0, 0.0, 1.0); // Identity quaternion
}

// Snap anchor direction to nearest angle increment
// Snaps spherical angles (theta, phi) to the nearest increment defined by the genome orientation
vec3 snapAnchorToAngleIncrement(vec3 anchorDir, vec4 orientationDelta) {
    // Convert anchor direction to spherical coordinates
    float r = length(anchorDir);
    if (r < 0.001) return vec3(1.0, 0.0, 0.0); // Fallback for zero vector
    
    vec3 dir = anchorDir / r;
    
    // Calculate spherical angles
    float theta = atan(dir.y, dir.x); // Azimuthal angle [-π, π]
    float phi = acos(clamp(dir.z, -1.0, 1.0)); // Polar angle [0, π]
    
    // Determine angle increment from genome orientation
    // Extract rotation angle from the quaternion
    float qw = orientationDelta.w;
    float angleIncrement = 2.0 * acos(clamp(abs(qw), 0.0, 1.0)); // Angle in radians
    
    // If angle is too small, default to 90 degrees (π/2)
    if (angleIncrement < 0.1) {
        angleIncrement = 3.14159265359 / 2.0; // 90 degrees
    }
    
    // Snap theta and phi to nearest increment
    float thetaSnapped = round(theta / angleIncrement) * angleIncrement;
    float phiSnapped = round(phi / angleIncrement) * angleIncrement;
    
    // Convert back to Cartesian coordinates
    float sinPhi = sin(phiSnapped);
    vec3 snapped = vec3(
        sinPhi * cos(thetaSnapped),
        sinPhi * sin(thetaSnapped),
        cos(phiSnapped)
    );
    
    return normalize(snapped);
}

// Deterministic quaternion rotation from one vector to another
// Uses a consistent method that avoids cross product ambiguity
vec4 quatFromTwoVectors(vec3 from, vec3 to) {
    // Normalize inputs
    vec3 v1 = normalize(from);
    vec3 v2 = normalize(to);
    
    float cosAngle = dot(v1, v2);
    
    // Vectors are already aligned
    if (cosAngle > 0.9999) {
        return vec4(0.0, 0.0, 0.0, 1.0); // Identity
    }
    
    // Vectors are opposite - use deterministic perpendicular axis
    if (cosAngle < -0.9999) {
        // Choose axis deterministically based on which component is smallest
        vec3 axis;
        if (abs(v1.x) < abs(v1.y) && abs(v1.x) < abs(v1.z)) {
            axis = normalize(vec3(0.0, -v1.z, v1.y));
        } else if (abs(v1.y) < abs(v1.z)) {
            axis = normalize(vec3(-v1.z, 0.0, v1.x));
        } else {
            axis = normalize(vec3(-v1.y, v1.x, 0.0));
        }
        return vec4(axis, 0.0); // 180 degree rotation
    }
    
    // General case: use half-way quaternion method (more stable than cross product)
    vec3 halfway = normalize(v1 + v2);
    vec3 axis = vec3(
        v1.y * halfway.z - v1.z * halfway.y,
        v1.z * halfway.x - v1.x * halfway.z,
        v1.x * halfway.y - v1.y * halfway.x
    );
    float w = dot(v1, halfway);
    
    return normalize(vec4(axis, w));
}

// Hash function to generate a pseudo-random float in [0,1] from a uint seed
float hash11(uint n) {
    n = (n ^ 61u) ^ (n >> 16u);
    n *= 9u;
    n = n ^ (n >> 4u);
    n *= 0x27d4eb2du;
    n = n ^ (n >> 15u);
    return float(n & 0x00FFFFFFu) / float(0x01000000u);
}

// Create a small random quaternion for a tiny rotation (angle in radians)
vec4 smallRandomQuat(float angle, uint seed) {
    // Random axis
    float rand1 = hash11(seed * 3u + 0u);
    float rand2 = hash11(seed * 3u + 1u);
    float rand3 = hash11(seed * 3u + 2u);
    vec3 axis = normalize(vec3(rand1, rand2, rand3) * 2.0 - 1.0);
    float halfAngle = angle * 0.5;
    float s = sin(halfAngle);
    return normalize(vec4(axis * s, cos(halfAngle)));
}

// Helper function to convert cell index to lineage ID (A.B.C format packed into uint)
uint getLineageIdFromIndex(uint cellIndex) {
    if (cellIndex >= inputCells.length()) return 0u;

    ComputeCell cell = inputCells[cellIndex];
    // Pack lineage ID as: (parentLineageId << 16) | (uniqueId << 8) | childNumber
    return (cell.parentLineageId << 16) | (cell.uniqueId << 8) | cell.childNumber;
}

// Function to log enhanced diagnostic entries
void logEnhancedDiagnostic(uint eventType, uint cellALineageId, uint cellBLineageId, uint connectionIndex,
                          uint modeIndex, uint splitEventID, uint parentCellLineageId,
                          vec3 anchorDirA, vec3 anchorDirB, float eventValue1, float eventValue2, uint eventFlags) {
    if (u_enableAdhesionDiagnostics == 0) return;

    // Atomically increment the counter and get the index
    uint index = atomicAdd(diagnosticCount, 1u);

    // Check if we have space in the buffer
    if (index >= diagnosticEntries.length()) return;

    // Create the enhanced diagnostic entry
    EnhancedDiagnosticEntry entry;

    // Core event data (store lineage IDs instead of indexes)
    entry.eventType = eventType;
    entry.frameIndex = uint(u_currentFrame);
    entry.cellA = cellALineageId;
    entry.cellB = cellBLineageId;

    // Event-specific data
    entry.connectionIndex = connectionIndex;
    entry.modeIndex = modeIndex;
    entry.splitEventID = splitEventID;
    entry.parentCellID = parentCellLineageId;

    // Get cell data for comprehensive logging (use lineage IDs to find cells)
    ComputeCell cellDataA;
    ComputeCell cellDataB;
    bool foundA = false, foundB = false;

    // Find cells by lineage ID (this is a simple linear search for diagnostic purposes)
    for (uint i = 0; i < totalCellCount && (!foundA || !foundB); ++i) {
        ComputeCell candidate = inputCells[i];
        uint candidateLineage = (candidate.parentLineageId << 16) | (candidate.uniqueId << 8) | candidate.childNumber;

        if (!foundA && candidateLineage == cellALineageId) {
            cellDataA = candidate;
            foundA = true;
        }
        if (!foundB && candidateLineage == cellBLineageId) {
            cellDataB = candidate;
            foundB = true;
        }
    }

    // Store lineage data for cell A (if found)
    if (foundA) {
        entry.lineageA_parentId = cellDataA.parentLineageId;
        entry.lineageA_uniqueId = cellDataA.uniqueId;
        entry.lineageA_childNum = cellDataA.childNumber;

        entry.positionA[0] = cellDataA.positionAndMass.x;
        entry.positionA[1] = cellDataA.positionAndMass.y;
        entry.positionA[2] = cellDataA.positionAndMass.z;
        entry.velocityA[0] = cellDataA.velocity.x;
        entry.velocityA[1] = cellDataA.velocity.y;
        entry.velocityA[2] = cellDataA.velocity.z;
        entry.massA = cellDataA.positionAndMass.w;
        entry.ageA = cellDataA.age;
        entry.toxinsA = cellDataA.toxins;
        entry.nitratesA = cellDataA.nitrates;
        entry.signallingA[0] = cellDataA.signallingSubstances.x;
        entry.signallingA[1] = cellDataA.signallingSubstances.y;
        entry.signallingA[2] = cellDataA.signallingSubstances.z;
        entry.signallingA[3] = cellDataA.signallingSubstances.w;
    } else {
        // Initialize cell A lineage data to invalid values
        entry.lineageA_parentId = 0xFFFFFFFF;
        entry.lineageA_uniqueId = 0xFFFFFFFF;
        entry.lineageA_childNum = 0xFFFFFFFF;
        entry.positionA[0] = 0.0; entry.positionA[1] = 0.0; entry.positionA[2] = 0.0;
        entry.velocityA[0] = 0.0; entry.velocityA[1] = 0.0; entry.velocityA[2] = 0.0;
        entry.massA = 0.0; entry.ageA = 0.0; entry.toxinsA = 0.0; entry.nitratesA = 0.0;
        entry.signallingA[0] = 0.0; entry.signallingA[1] = 0.0; entry.signallingA[2] = 0.0; entry.signallingA[3] = 0.0;
    }

    // Get second cell data if applicable
    if (cellBLineageId != 0xFFFFFFFF && foundB) {
        // Store lineage data for cell B
        entry.lineageB_parentId = cellDataB.parentLineageId;
        entry.lineageB_uniqueId = cellDataB.uniqueId;
        entry.lineageB_childNum = cellDataB.childNumber;

        entry.positionB[0] = cellDataB.positionAndMass.x;
        entry.positionB[1] = cellDataB.positionAndMass.y;
        entry.positionB[2] = cellDataB.positionAndMass.z;
        entry.velocityB[0] = cellDataB.velocity.x;
        entry.velocityB[1] = cellDataB.velocity.y;
        entry.velocityB[2] = cellDataB.velocity.z;
        entry.massB = cellDataB.positionAndMass.w;
        entry.ageB = cellDataB.age;
        entry.toxinsB = cellDataB.toxins;
        entry.nitratesB = cellDataB.nitrates;
        entry.signallingB[0] = cellDataB.signallingSubstances.x;
        entry.signallingB[1] = cellDataB.signallingSubstances.y;
        entry.signallingB[2] = cellDataB.signallingSubstances.z;
        entry.signallingB[3] = cellDataB.signallingSubstances.w;
    } else {
        // Initialize cell B lineage data to invalid values
        entry.lineageB_parentId = 0xFFFFFFFF;
        entry.lineageB_uniqueId = 0xFFFFFFFF;
        entry.lineageB_childNum = 0xFFFFFFFF;

        // Clear second cell data if not applicable
        entry.positionB[0] = 0.0f; entry.positionB[1] = 0.0f; entry.positionB[2] = 0.0f;
        entry.velocityB[0] = 0.0f; entry.velocityB[1] = 0.0f; entry.velocityB[2] = 0.0f;
        entry.massB = 0.0f; entry.ageB = 0.0f; entry.toxinsB = 0.0f; entry.nitratesB = 0.0f;
        entry.signallingB[0] = 0.0f; entry.signallingB[1] = 0.0f; entry.signallingB[2] = 0.0f; entry.signallingB[3] = 0.0f;
    }

    // Anchor directions
    entry.anchorDirA[0] = anchorDirA.x;
    entry.anchorDirA[1] = anchorDirA.y;
    entry.anchorDirA[2] = anchorDirA.z;
    entry.anchorDirB[0] = anchorDirB.x;
    entry.anchorDirB[1] = anchorDirB.y;
    entry.anchorDirB[2] = anchorDirB.z;

    // Event values
    entry.eventValue1 = eventValue1;
    entry.eventValue2 = eventValue2;
    entry.eventFlags = eventFlags;

    // Padding (7 floats for 16-byte alignment)
    for (int i = 0; i < 7; i++) {
        entry._padding[i] = 0.0f;
    }

    // Write the entry to the buffer
    diagnosticEntries[index] = entry;
}

// Legacy wrapper function for backward compatibility
void logAdhesionDiagnostic(uint connectionIndex, uint cellALineageId, uint cellBLineageId, uint modeIndex,
                          uint reasonCode, vec3 anchorDirA, vec3 anchorDirB,
                          uint frameIndex, uint splitEventID, uint parentCellLineageId,
                          uint inheritanceType, uint originalConnectionIndex, float adhesionZone) {
    // Map legacy reason codes to enhanced event types (adhesion events are 0-29)
    // For inherited connections, use eventFlags to store original connection index
    uint flags = 0u;
    if (reasonCode == 0) { // Inherited connection
        // Store original connection index in the upper 16 bits of eventFlags
        flags = (originalConnectionIndex << 16) | (inheritanceType & 0xFFFF);
    }
    logEnhancedDiagnostic(reasonCode, cellALineageId, cellBLineageId, connectionIndex, modeIndex,
                         splitEventID, parentCellLineageId, anchorDirA, anchorDirB,
                         adhesionZone, float(inheritanceType), flags);
}

uint getNewAdhesionIndex() {
    // Try to reserve a free adhesion slot
    // Snapshot free top value without modifying it first
    int freeTopBefore = freeAdhesionTop;
    if (freeTopBefore > 0) {
        // Now reserve slot *safely*
        int freeTop = atomicAdd(freeAdhesionTop, -1);
        if (freeTop > 0) {
            return freeAdhesionSlotIndices[freeTop - 1];
        } else {
            // Another thread raced and depleted the stack before we got here
            atomicAdd(freeAdhesionTop, 1); // revert
        }
    }

    // Fallback to allocating a new slot
    uint newAdhesionIndex = atomicAdd(totalAdhesionCount, 1);
    if (newAdhesionIndex >= u_maxAdhesions) {
        atomicMin(totalAdhesionCount, u_maxAdhesions);
        return -1;
    }
    return newAdhesionIndex;
}

// Add adhesion with preserved anchor directions (for inheritance)
// Returns the connection index on success, -1 on failure
int addAdhesionWithDirections(uint cellAIndex, uint cellBIndex, uint modeIndex, vec3 preservedAnchorA, vec3 preservedAnchorB) {
    uint newAdhesionIndex = getNewAdhesionIndex();
    if (newAdhesionIndex == uint(-1)) {
        // Failed to reserve an adhesion index
        return -1;
    }

    // Check for available slot in cell A using atomic compare-exchange to prevent races
    int slotA = -1;
    for (int j = 0; j < 20; ++j) {
        // Atomically try to claim this slot
        int expected = -1;
        int newValue = -2; // Temporary marker to claim the slot
        if (atomicCompSwap(outputCells[cellAIndex].adhesionIndices[j], expected, newValue) == expected) {
            slotA = j;
            break;
        }
    }

    // Check for available slot in cell B using atomic compare-exchange to prevent races
    int slotB = -1;
    for (int j = 0; j < 20; ++j) {
        // Atomically try to claim this slot
        int expected = -1;
        int newValue = -2; // Temporary marker to claim the slot
        if (atomicCompSwap(outputCells[cellBIndex].adhesionIndices[j], expected, newValue) == expected) {
            slotB = j;
            break;
        }
    }

    if (slotA == -1 || slotB == -1) {
        // Roll back the reservation if any cell has no free slot
        // Also release any claimed slots
        if (slotA != -1) {
            outputCells[cellAIndex].adhesionIndices[slotA] = -1;
        }
        if (slotB != -1) {
            outputCells[cellBIndex].adhesionIndices[slotB] = -1;
        }
        int reservation = atomicAdd(freeAdhesionTop, 1);
        int topIndex = reservation;
        freeAdhesionSlotIndices[topIndex] = newAdhesionIndex;
        return -1;
    }

    // Use the preserved anchor directions directly (already in local space)
    vec3 anchorDirectionA = preservedAnchorA;
    vec3 anchorDirectionB = preservedAnchorB;

    // Store current orientations as twist reference for constraint
    vec4 twistReferenceA = inputCells[cellAIndex].orientation;
    vec4 twistReferenceB = inputCells[cellBIndex].orientation;

    // Classify zones using the preserved anchor directions (already in local space)
    ComputeCell cellA = inputCells[cellAIndex];
    ComputeCell cellB = inputCells[cellBIndex];
    GPUMode modeA = modes[cellA.modeIndex];
    GPUMode modeB = modes[cellB.modeIndex];

    // Use preserved anchor directions for zone classification (genome-based, not spatial)
    uint zoneA = classifyBondDirection(anchorDirectionA, modeA.splitDirection.xyz, 10.0);
    uint zoneB = classifyBondDirection(anchorDirectionB, modeB.splitDirection.xyz, 10.0);

    // Write connection and assign indices
    connections[newAdhesionIndex] = AdhesionConnection(
        cellAIndex,
        cellBIndex,
        modeIndex,
        1, // isActive
        zoneA,
        zoneB,
        anchorDirectionA,
        0.0, // paddingA
        anchorDirectionB,
        0.0, // paddingB
        twistReferenceA,
        twistReferenceB,
        uint[4](0u, 0u, 0u, 0u) // padding to ensure 16-byte alignment
    );
    outputCells[cellAIndex].adhesionIndices[slotA] = int(newAdhesionIndex);
    outputCells[cellBIndex].adhesionIndices[slotB] = int(newAdhesionIndex);
    
    // Memory barrier to ensure writes are visible to subsequent slot searches
    memoryBarrierBuffer();

    return int(newAdhesionIndex);
}

bool addAdhesion(uint cellAIndex, uint cellBIndex, uint modeIndex) {
    uint newAdhesionIndex = getNewAdhesionIndex();
    if (newAdhesionIndex == uint(-1)) {
        // Failed to reserve an adhesion index
        return false;
    }

    // Check for available slot in cell A
    int slotA = -1;
    for (int j = 0; j < 20; ++j) {
        if (outputCells[cellAIndex].adhesionIndices[j] < 0) {
            slotA = j;
            break;
        }
    }

    // Check for available slot in cell B
    int slotB = -1;
    for (int j = 0; j < 20; ++j) {
        if (outputCells[cellBIndex].adhesionIndices[j] < 0) {
            slotB = j;
            break;
        }
    }

    if (slotA == -1 || slotB == -1) {
        // Roll back the reservation if any cell has no free slot
        int reservation = atomicAdd(freeAdhesionTop, 1);
        int topIndex = reservation;
        freeAdhesionSlotIndices[topIndex] = newAdhesionIndex;
        return false;
    }

    // Calculate initial anchor directions using ONLY genome-based data
    // This function is called for sibling bonds during split
    // We need to use genome-derived orientations, not actual cell orientations
    GPUMode modeForBond = modes[modeIndex];
    
    // The split direction in the parent's local frame
    vec3 splitDirLocal = modeForBond.splitDirection.xyz;
    
    // Direction vectors in parent's local frame
    // Child A is at +offset, child B is at -offset
    vec3 directionAtoB_parentLocal = -splitDirLocal;  // A points toward B (at -offset)
    vec3 directionBtoA_parentLocal = splitDirLocal;   // B points toward A (at +offset)

    // Transform to each child's local space using genome-derived orientation deltas
    // Child A's local space: rotate by inverse of orientationA
    vec4 invDeltaA = quatInverse(modeForBond.orientationA);
    vec3 anchorDirectionA = normalize(rotateVectorByQuaternion(directionAtoB_parentLocal, invDeltaA));
    
    // Child B's local space: rotate by inverse of orientationB
    vec4 invDeltaB = quatInverse(modeForBond.orientationB);
    vec3 anchorDirectionB = normalize(rotateVectorByQuaternion(directionBtoA_parentLocal, invDeltaB));

    // Get cell data for mode lookup
    ComputeCell cellA = inputCells[cellAIndex];
    ComputeCell cellB = inputCells[cellBIndex];
    
    // Use genome-based orientations as twist reference (deterministic, independent of physics)
    // This ensures twist constraints are consistent regardless of cell rotation before split
    vec4 twistReferenceA = cellA.orientation;
    vec4 twistReferenceB = cellB.orientation;

    // Classify zones using the genome-derived anchor directions (already in local space)
    GPUMode modeA = modes[cellA.modeIndex];
    GPUMode modeB = modes[cellB.modeIndex];

    // Zone classification using genome-based anchors
    uint zoneA = classifyBondDirection(anchorDirectionA, modeA.splitDirection.xyz, 10.0);
    uint zoneB = classifyBondDirection(anchorDirectionB, modeB.splitDirection.xyz, 10.0);

    // Write connection and assign indices
    connections[newAdhesionIndex] = AdhesionConnection(
        cellAIndex,
        cellBIndex,
        modeIndex,
        1, // isActive
        zoneA,
        zoneB,
        anchorDirectionA,
        0.0, // paddingA
        anchorDirectionB,
        0.0, // paddingB
        twistReferenceA,
        twistReferenceB,
        uint[4](0u, 0u, 0u, 0u) // padding to ensure 16-byte alignment
    );
    outputCells[cellAIndex].adhesionIndices[slotA] = int(newAdhesionIndex);
    outputCells[cellBIndex].adhesionIndices[slotB] = int(newAdhesionIndex);

    // Log diagnostic entry for direct adhesion creation
    logAdhesionDiagnostic(
        newAdhesionIndex, getLineageIdFromIndex(cellAIndex), getLineageIdFromIndex(cellBIndex), modeIndex,
        1, // reasonCode: Direct
        anchorDirectionA, anchorDirectionB,
        uint(u_currentFrame), 0u, // frameIndex, splitEventID (0 for direct)
        0u, 0u, 0u, 0.0 // parentCellID, inheritanceType, originalConnectionIndex, adhesionZone
    );

    return true;
}

void removeAdhesion(int adhesionIndex){
    // Log diagnostic entry for adhesion removal
    if (adhesionIndex >= 0 && adhesionIndex < connections.length()) {
        AdhesionConnection conn = connections[adhesionIndex];
        logAdhesionDiagnostic(
            uint(adhesionIndex), getLineageIdFromIndex(conn.cellAIndex), getLineageIdFromIndex(conn.cellBIndex), conn.modeIndex,
            2, // reasonCode: Broken
            conn.anchorDirectionA, conn.anchorDirectionB,
            uint(u_currentFrame), 0u, // frameIndex, splitEventID (0 for general removal)
            0u, 0u, 0u, 0.0 // parentCellID, inheritanceType, originalConnectionIndex, adhesionZone
        );
    }
    
    // Mark as inactive
    
    // Remove from cellA
    connections[adhesionIndex].isActive = 0;
    for (int i = 0; i < 20; ++i) {
        if (outputCells[connections[adhesionIndex].cellAIndex].adhesionIndices[i] == adhesionIndex) {
            outputCells[connections[adhesionIndex].cellAIndex].adhesionIndices[i] = -1;
            break;
        }
    }

    // Remove from cellB
    for (int i = 0; i < 20; ++i) {
        if (outputCells[connections[adhesionIndex].cellBIndex].adhesionIndices[i] == adhesionIndex) {
            outputCells[connections[adhesionIndex].cellBIndex].adhesionIndices[i] = -1;
            break;
        }
    }

    // Push to free stack safely
    int freeIndex = atomicAdd(freeAdhesionTop, 1);
    if (freeIndex < u_maxAdhesions) {
        freeAdhesionSlotIndices[freeIndex] = adhesionIndex;
    } else {
        freeAdhesionTop = u_maxAdhesions;
    }
}

float priority(uint seed) {
    // Generate a pseudo-random priority based on the seed
    return hash11(seed ^ uint(u_currentFrame));
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= totalCellCount) return;

    ComputeCell cell = inputCells[index];
    GPUMode mode = modes[cell.modeIndex];

    outputCells[index] = cell; // Default output is the same cell

    // Check split conditions: age AND nutrient level
    const float SPLIT_NUTRIENT_THRESHOLD = 50.0;
    if (cell.age < mode.splitInterval) return;
    if (cell.nitrates < SPLIT_NUTRIENT_THRESHOLD) return; // Need 50 nutrients to split

    int adhesionCount = 0;
    for (int i = 0; i < 20; ++i) {
        if (cell.adhesionIndices[i] >= 0) {
            adhesionCount++;
        }
    }
    if (adhesionCount >= mode.maxAdhesions) return; // Too many adhesions, cannot split

    // Begin split logic

    // === Compute Split Priority ===
    float myPriority = priority(index);

    // === Check Adhered Cells ===
    for (int i = 0; i < 20; ++i) {
        int adhesionIdx = cell.adhesionIndices[i];
        if (adhesionIdx < 0) continue;

        AdhesionConnection conn = connections[adhesionIdx];
        if (conn.isActive == 0) continue;

        uint otherIndex = (conn.cellAIndex == index) ? conn.cellBIndex : conn.cellAIndex;
        ComputeCell other = inputCells[otherIndex];
        GPUMode otherMode = modes[other.modeIndex];

        if (other.age < otherMode.splitInterval) continue; // Other cell not splitting

        // If other cell wants to split, compare priority
        float otherPriority = priority(otherIndex);
        if (otherPriority < myPriority) {
            // Defer this split - other cell has higher priority (lower index)
            return;
        }
    }

    // CRITICAL FIX: Replace atomic splitting with safer reservation system
    // First, check if we have space for a new cell
    uint currentCount = totalCellCount;
    if (currentCount >= u_maxCells) {
        // No space available, cancel the split
        outputCells[index] = cell;
        return;
    }
    
    // Try to reserve a slot atomically
    uint newIndex = atomicAdd(totalCellCount, 1);

    // Check if we successfully got a valid slot
    if (newIndex >= u_maxCells) {
        // We exceeded the limit, rollback and cancel
        atomicAdd(totalCellCount, -1);
        outputCells[index] = cell;
        return;
    }

    // Successfully reserved a slot, increment live count
    atomicAdd(liveCellCount, 1);

    // CRITICAL FIX: Add memory barrier to ensure atomic operations are complete
    memoryBarrierBuffer();
    
    // CRITICAL FIX: Double-check bounds after memory barrier
    if (newIndex >= u_maxCells) {
        // Rollback the increment if we're still out of bounds
        atomicAdd(totalCellCount, -1);
        atomicAdd(liveCellCount, -1);
        outputCells[index] = cell;
        return;
    }

    uint childAIndex = index;
    uint childBIndex = newIndex;

    vec3 offset = rotateVectorByQuaternion(mode.splitDirection.xyz, cell.orientation) * 0.5;

    // Both child cells should start with the same age after the split
    // Since we already aged the parent cell by deltaTime this frame,
    // we need to subtract the excess age beyond the split interval
    // Clamp to ensure children never start at or above split interval
    float startAge = min(cell.age - mode.splitInterval, mode.splitInterval * 0.99);

    // Apply rotation deltas to parent orientation with small random offset to prevent perfect alignments
    vec4 q_parent = cell.orientation;
    
    // Generate small random rotation offset based on cell's unique ID
    float randomSeed = float(cell.uniqueId);
    float randomAngle = fract(sin(randomSeed * 12.9898) * 43758.5453) * 0.001; // Small random angle ~0.001 radians
    vec3 randomAxis = normalize(vec3(
        fract(sin(randomSeed * 78.233) * 43758.5453),
        fract(sin(randomSeed * 45.164) * 43758.5453),
        fract(sin(randomSeed * 94.673) * 43758.5453)
    ));
    vec4 randomRotation = vec4(randomAxis * sin(randomAngle * 0.5), cos(randomAngle * 0.5));
    
    vec4 q_childA = normalize(quatMultiply(quatMultiply(q_parent, mode.orientationA), randomRotation));
    vec4 q_childB = normalize(quatMultiply(quatMultiply(q_parent, mode.orientationB), randomRotation));

    // Split nutrients evenly between children
    float halfNutrients = cell.nitrates * 0.5;
    
    ComputeCell childA = cell;
    childA.positionAndMass.xyz += offset;
    childA.age = startAge;
    childA.modeIndex = mode.childModes.x;
    childA.orientation = q_childA;
    childA.nitrates = halfNutrients; // Half of parent's nutrients
    // Lineage tracking: Child A inherits parent's unique ID and becomes child 1
    childA.parentLineageId = cell.uniqueId;  // Parent's unique ID becomes child's parent lineage ID
    childA.uniqueId = atomicAdd(nextUniqueId, 1); // Get next unique ID atomically
    childA.childNumber = 1;  // First child
    for (int i = 0; i < 20; ++i) {
        childA.adhesionIndices[i] = -1; // Reset adhesion indices for the new child
    }

    ComputeCell childB = cell;
    childB.positionAndMass.xyz -= offset;
    childB.age = startAge + 0.001;
    childB.modeIndex = mode.childModes.y;
    childB.orientation = q_childB;
    childB.nitrates = halfNutrients; // Half of parent's nutrients
    // Lineage tracking: Child B gets new unique ID and becomes child 2
    childB.parentLineageId = cell.uniqueId;  // Parent's unique ID becomes child's parent lineage ID
    childB.uniqueId = atomicAdd(nextUniqueId, 1); // Get next unique ID atomically
    childB.childNumber = 2;  // Second child
    for (int i = 0; i < 20; ++i) {
        childB.adhesionIndices[i] = -1; // Reset adhesion indices for the new child
    }

    // Store new cells
    outputCells[childAIndex] = childA;
    outputCells[childBIndex] = childB;

    // CRITICAL FIX: Also write to input buffer to maintain consistency across all buffers
    inputCells[childAIndex] = childA;
    inputCells[childBIndex] = childB;

    // Log cell replacement event - parent cell is replaced by its children
    logEnhancedDiagnostic(
        34u, // CELL_REPLACED
        getLineageIdFromIndex(childAIndex), // Child A lineage ID (replaces parent)
        getLineageIdFromIndex(childBIndex), // Child B lineage ID (replaces parent)
        0xFFFFFFFF, // No connection index
        cell.modeIndex, // Parent's original mode
        1u, // Split event ID
        getLineageIdFromIndex(index), // Original parent lineage ID
        vec3(0.0), vec3(0.0), // No anchor directions for lifecycle events
        cell.age, float(mode.splitInterval), // Event values: parent's age, split interval
        0u // eventFlags
    );
    
    // Log diagnostic events for cell lifecycle
    // Cell split start event for parent (log that parent will split into two children)
    logEnhancedDiagnostic(
        32u, // CELL_SPLIT_START
        getLineageIdFromIndex(index), // Original parent lineage ID (before split)
        getLineageIdFromIndex(childAIndex), // Child A lineage ID (continuation of parent)
        0xFFFFFFFF, // No connection index
        cell.modeIndex, // Parent's mode
        1u, // Split event ID
        getLineageIdFromIndex(index), // Original parent lineage ID
        vec3(0.0), vec3(0.0), // No anchor directions for lifecycle events
        cell.age, float(mode.splitInterval), // Event values: actual age, split interval
        0u // eventFlags
    );

    // Also log split start for child B
    logEnhancedDiagnostic(
        32u, // CELL_SPLIT_START
        getLineageIdFromIndex(childAIndex), // Child A lineage ID
        getLineageIdFromIndex(childBIndex), // Child B lineage ID
        0xFFFFFFFF, // No connection index
        childA.modeIndex, // Child A's mode
        1u, // Split event ID
        getLineageIdFromIndex(index), // Original parent lineage ID
        vec3(0.0), vec3(0.0), // No anchor directions for lifecycle events
        startAge, float(mode.splitInterval), // Event values: starting age, split interval
        0u // eventFlags
    );
    
    // Debug output for lineage tracking (this will be visible in console)
    // Note: This is a simple way to verify lineage assignment works
    // In a real implementation, you might want to use a more sophisticated logging system
    
    // Cell birth event for child A (continuation of parent)
    logEnhancedDiagnostic(
        30u, // CELL_BIRTH
        getLineageIdFromIndex(childAIndex), // Child A lineage ID
        0xFFFFFFFF, // No second cell
        0xFFFFFFFF, // No connection index
        childA.modeIndex, // Child A's mode
        1u, // Split event ID
        getLineageIdFromIndex(index), // Original parent lineage ID
        vec3(0.0), vec3(0.0), // No anchor directions for lifecycle events
        startAge, float(mode.splitInterval), // Event values: starting age, split interval
        0u // eventFlags
    );

    // Cell birth event for new child B
    logEnhancedDiagnostic(
        30u, // CELL_BIRTH
        getLineageIdFromIndex(childBIndex), // New child lineage ID
        0xFFFFFFFF, // No second cell
        0xFFFFFFFF, // No connection index
        childB.modeIndex, // Child's mode
        1u, // Split event ID
        getLineageIdFromIndex(index), // Original parent lineage ID
        vec3(0.0), vec3(0.0), // No anchor directions for lifecycle events
        startAge, float(mode.splitInterval), // Event values: starting age, split interval
        0u // eventFlags
    );
    
    // Cell split complete event (log that parent split into two children)
    logEnhancedDiagnostic(
        33u, // CELL_SPLIT_COMPLETE
        getLineageIdFromIndex(childAIndex), // Child A lineage ID (split completed)
        getLineageIdFromIndex(childBIndex), // Child B lineage ID (split completed)
        0xFFFFFFFF, // No connection index
        childA.modeIndex, // Child A's mode
        1u, // Split event ID
        getLineageIdFromIndex(index), // Original parent lineage ID
        vec3(0.0), vec3(0.0), // No anchor directions for lifecycle events
        startAge, float(mode.splitInterval), // Event values: starting age, split interval
        0u // eventFlags
    );

    // Inherit adhesions for the new child cells
    for (int i = 0; i < 20; ++i) {
        int oldAdhesionIndex = cell.adhesionIndices[i];
        if (oldAdhesionIndex < 0) continue;

        // Read connection data BEFORE checking isActive, because the neighbor might have already
        // split and marked it inactive. We need the connection data regardless.
        AdhesionConnection oldConnection = connections[oldAdhesionIndex];
        
        // Skip if this connection was already processed (not from a split)
        // But allow processing if it was marked inactive by a simultaneous split
        bool wasAlreadyProcessed = (oldConnection.isActive == 0 && 
                                     oldConnection.cellAIndex != childAIndex && 
                                     oldConnection.cellBIndex != childAIndex);
        if (wasAlreadyProcessed) continue;

        // CRITICAL FIX: Add memory barrier before modifying adhesion connections
        memoryBarrierBuffer();

        // Determine who the parent was connected to
        uint neighborIndex = (oldConnection.cellAIndex == childAIndex)
            ? oldConnection.cellBIndex
            : oldConnection.cellAIndex;

        // Remove the old connection (this marks it inactive, but we already have the data)
        // Note: If neighbor also splits, it will have already read this connection data
        removeAdhesion(oldAdhesionIndex);

        // Use stored anchor direction instead of spatial calculation
        // Determine which anchor direction to use based on parent's role in the connection
        bool isParentCellA = (oldConnection.cellAIndex == childAIndex); // childAIndex is same as parent index
        vec3 localAnchorDirection = isParentCellA ? oldConnection.anchorDirectionA : oldConnection.anchorDirectionB;

        // Use the stored zone information from the original connection instead of recalculating
        // The original connection already has the correct zone classification
        uint parentZone = isParentCellA ? oldConnection.zoneA : oldConnection.zoneB;

        // Apply inheritance logic - simple zone-based rules
        bool childAInherits = false;
        bool childBInherits = false;
        
        // Zone classification determines inheritance
        if (parentZone == 2u) {
            // Zone C (equatorial) - both children inherit
            childAInherits = (mode.childAKeepAdhesion == 1);
            childBInherits = (mode.childBKeepAdhesion == 1);
        } else if (parentZone == 1u) {
            // Zone B - Child A inherits
            childAInherits = (mode.childAKeepAdhesion == 1);
        } else {
            // Zone A - Child B inherits
            childBInherits = (mode.childBKeepAdhesion == 1);
        }
        
        // Determine neighbor's role in the original connection
        bool neighborWasCellA = (oldConnection.cellAIndex == neighborIndex);
        
        // Get the neighbor's original anchor direction from the bond
        vec3 neighborOriginalAnchor = neighborWasCellA ? oldConnection.anchorDirectionA : oldConnection.anchorDirectionB;

        // Create new adhesion connections for inheriting children
        // Zone C bonds can create connections for both children, polar bonds create connections for specific children

        // Child A inheritance
        if (childAInherits) {
            // Pure geometric calculation using ONLY genome data
            // Work in parent's local frame, then transform to each cell's local frame
            
            // Split offset in parent's local frame (genome parameter)
            vec3 offsetLocal = mode.splitDirection.xyz * 0.5;
            
            // Neighbor is at: localAnchorDirection * restLength (in parent's local frame)
            // Child A is at: offsetLocal (in parent's local frame)
            // Direction from child A to neighbor:
            vec3 neighborRelativeToChildA_parentLocal = localAnchorDirection * mode.adhesionSettings.restLength - offsetLocal;
            
            // Transform to child A's local space using genome delta
            vec4 invDeltaA = quatInverse(mode.orientationA);
            vec3 childAnchorDirection_raw = normalize(rotateVectorByQuaternion(neighborRelativeToChildA_parentLocal, invDeltaA));
            
            // Snap to nearest angle increment for child A (skip for Zone C to preserve intermediate geometry)
            GPUMode childAMode = modes[mode.childModes.x];
            vec3 childAnchorDirection = (parentZone == 2u) ? childAnchorDirection_raw : snapAnchorToAngleIncrement(childAnchorDirection_raw, childAMode.orientationA);
            
            // Calculate neighbor's anchor direction pointing toward Child A
            // Direction from neighbor to Child A in parent's local frame:
            vec3 neighborToChildA_parentLocal = offsetLocal - localAnchorDirection * mode.adhesionSettings.restLength;
            
            // Transform to neighbor's local frame using the bond axis relationship
            // localAnchorDirection (parent→neighbor) and neighborOriginalAnchor (neighbor→parent) define the bond axis
            vec3 bondAxis_parent = normalize(localAnchorDirection);
            vec3 bondAxis_neighbor = normalize(-neighborOriginalAnchor);
            
            // Component along bond axis (scalar, frame-independent)
            float alongBond = dot(neighborToChildA_parentLocal, bondAxis_parent);
            
            // Component perpendicular to bond axis (in parent's frame)
            vec3 perpComponent_parent = neighborToChildA_parentLocal - alongBond * bondAxis_parent;
            
            // Transform perpendicular component: assume aligned (genome-only approximation)
            vec3 perpComponent_neighbor = perpComponent_parent;
            
            // Reconstruct in neighbor's frame
            vec3 neighborToChildA_neighborLocal = alongBond * bondAxis_neighbor + perpComponent_neighbor;
            vec3 neighborAnchorDirection_raw = normalize(neighborToChildA_neighborLocal);
            
            // Snap to nearest angle increment for the neighbor (skip for Zone C to preserve intermediate geometry)
            ComputeCell neighborCell = inputCells[neighborIndex];
            GPUMode neighborMode = modes[neighborCell.modeIndex];
            vec3 neighborAnchorDirection = (parentZone == 2u) ? neighborAnchorDirection_raw : snapAnchorToAngleIncrement(neighborAnchorDirection_raw, neighborMode.orientationA);

            // Preserve original side assignment: if neighbor was originally cellA, keep them as cellA
            int newConnectionIndex;
            if (neighborWasCellA) {
                // Neighbor was cellA, child becomes cellB
                newConnectionIndex = addAdhesionWithDirections(neighborIndex, childAIndex, oldConnection.modeIndex, neighborAnchorDirection, childAnchorDirection);
            } else {
                // Neighbor was cellB, child becomes cellA
                newConnectionIndex = addAdhesionWithDirections(childAIndex, neighborIndex, oldConnection.modeIndex, childAnchorDirection, neighborAnchorDirection);
            }
            
            // If connection creation failed for Child A, skip logging but continue to allow Child B to inherit
            // Failure can occur if: no free adhesion indices, Child A has no free slots, or neighbor has no free slots
            if (newConnectionIndex >= 0) {
                // Log diagnostic entry for inherited connection (Child A)
            // Use the actual cellA/cellB assignment from the connection structure
            uint actualCellA = neighborWasCellA ? neighborIndex : childAIndex;
            uint actualCellB = neighborWasCellA ? childAIndex : neighborIndex;
            logAdhesionDiagnostic(
                uint(newConnectionIndex), getLineageIdFromIndex(actualCellA), getLineageIdFromIndex(actualCellB), oldConnection.modeIndex,
                0, // reasonCode: Inherited
                neighborWasCellA ? neighborAnchorDirection : childAnchorDirection,
                neighborWasCellA ? childAnchorDirection : neighborAnchorDirection,
                uint(u_currentFrame), 1u, // frameIndex, splitEventID (1 for split event)
                getLineageIdFromIndex(index), 1u, uint(oldAdhesionIndex), float(parentZone) // original parentCellID, inheritanceType (1=childA_keeps), originalConnectionIndex, adhesionZone
            );
            }
        }
        
        // Memory barrier to ensure Child A's connection writes are visible before Child B tries to allocate slots
        // This is critical for Zone C where both children connect to the same neighbor
        memoryBarrierBuffer();

        // Child B inheritance (Zone C bonds can also create this)
        if (childBInherits) {
            // Pure geometric calculation using ONLY genome data
            // Work in parent's local frame, then transform to each cell's local frame
            
            // Split offset in parent's local frame (genome parameter)
            vec3 offsetLocal = mode.splitDirection.xyz * 0.5;
            
            // Neighbor is at: localAnchorDirection * restLength (in parent's local frame)
            // Child B is at: -offsetLocal (in parent's local frame)
            // Direction from child B to neighbor:
            vec3 neighborRelativeToChildB_parentLocal = localAnchorDirection * mode.adhesionSettings.restLength + offsetLocal;
            
            // Transform to child B's local space using genome delta
            vec4 invDeltaB = quatInverse(mode.orientationB);
            vec3 childAnchorDirection_raw = normalize(rotateVectorByQuaternion(neighborRelativeToChildB_parentLocal, invDeltaB));
            
            // Snap to nearest angle increment for child B (skip for Zone C to preserve intermediate geometry)
            GPUMode childBMode = modes[mode.childModes.y];
            vec3 childAnchorDirection = (parentZone == 2u) ? childAnchorDirection_raw : snapAnchorToAngleIncrement(childAnchorDirection_raw, childBMode.orientationA);
            
            // Calculate neighbor's anchor direction pointing toward Child B
            // Direction from neighbor to Child B in parent's local frame:
            vec3 neighborToChildB_parentLocal = -offsetLocal - localAnchorDirection * mode.adhesionSettings.restLength;
            
            // Transform to neighbor's local frame using the bond axis relationship
            // localAnchorDirection (parent→neighbor) and neighborOriginalAnchor (neighbor→parent) define the bond axis
            vec3 bondAxis_parent = normalize(localAnchorDirection);
            vec3 bondAxis_neighbor = normalize(-neighborOriginalAnchor);
            
            // Component along bond axis (scalar, frame-independent)
            float alongBond = dot(neighborToChildB_parentLocal, bondAxis_parent);
            
            // Component perpendicular to bond axis (in parent's frame)
            vec3 perpComponent_parent = neighborToChildB_parentLocal - alongBond * bondAxis_parent;
            
            // Transform perpendicular component: assume aligned (genome-only approximation)
            vec3 perpComponent_neighbor = perpComponent_parent;
            
            // Reconstruct in neighbor's frame
            vec3 neighborToChildB_neighborLocal = alongBond * bondAxis_neighbor + perpComponent_neighbor;
            vec3 neighborAnchorDirection_raw = normalize(neighborToChildB_neighborLocal);
            
            // Snap to nearest angle increment for the neighbor (skip for Zone C to preserve intermediate geometry)
            ComputeCell neighborCell = inputCells[neighborIndex];
            GPUMode neighborMode = modes[neighborCell.modeIndex];
            vec3 neighborAnchorDirection = (parentZone == 2u) ? neighborAnchorDirection_raw : snapAnchorToAngleIncrement(neighborAnchorDirection_raw, neighborMode.orientationA);

            // Preserve original side assignment: if neighbor was originally cellA, keep them as cellA
            int newConnectionIndex;
            if (neighborWasCellA) {
                // Neighbor was cellA, child becomes cellB
                newConnectionIndex = addAdhesionWithDirections(neighborIndex, childBIndex, oldConnection.modeIndex, neighborAnchorDirection, childAnchorDirection);
            } else {
                // Neighbor was cellB, child becomes cellA
                newConnectionIndex = addAdhesionWithDirections(childBIndex, neighborIndex, oldConnection.modeIndex, childAnchorDirection, neighborAnchorDirection);
            }
            
            // If connection creation failed, skip logging but continue processing
            if (newConnectionIndex >= 0) {
                // Log diagnostic entry for inherited connection (Child B)
            // Use the actual cellA/cellB assignment from the connection structure
            uint actualCellA_B = neighborWasCellA ? neighborIndex : childBIndex;
            uint actualCellB_B = neighborWasCellA ? childBIndex : neighborIndex;
            logAdhesionDiagnostic(
                uint(newConnectionIndex), getLineageIdFromIndex(actualCellA_B), getLineageIdFromIndex(actualCellB_B), oldConnection.modeIndex,
                0, // reasonCode: Inherited
                neighborWasCellA ? neighborAnchorDirection : childAnchorDirection,
                neighborWasCellA ? childAnchorDirection : neighborAnchorDirection,
                uint(u_currentFrame), 1u, // frameIndex, splitEventID (1 for split event)
                getLineageIdFromIndex(index), 2u, uint(oldAdhesionIndex), float(parentZone) // original parentCellID, inheritanceType (2=childB_keeps), originalConnectionIndex, adhesionZone
            );
            }
        }
    }

    // Now we need to add the adhesion connection between the children
    if (mode.parentMakeAdhesion == 0)  return;

    // Create a new adhesion connection between the two children using ONLY genome data
    // Split direction in parent's local frame
    vec3 splitDirLocal = mode.splitDirection.xyz;
    
    // Direction vectors in parent's local frame
    // Child A is at +offset, child B is at -offset
    vec3 directionAtoB_parentLocal = -splitDirLocal;  // A points toward B (at -offset)
    vec3 directionBtoA_parentLocal = splitDirLocal;   // B points toward A (at +offset)
    
    // Transform to each child's local space using genome-derived orientation deltas
    vec4 invDeltaA = quatInverse(mode.orientationA);
    vec3 anchorDirectionA = normalize(rotateVectorByQuaternion(directionAtoB_parentLocal, invDeltaA));
    
    vec4 invDeltaB = quatInverse(mode.orientationB);
    vec3 anchorDirectionB = normalize(rotateVectorByQuaternion(directionBtoA_parentLocal, invDeltaB));

    // Classify zones using genome-derived anchors
    uint childZoneA = classifyBondDirection(anchorDirectionA, mode.splitDirection.xyz, 10.0);
    uint childZoneB = classifyBondDirection(anchorDirectionB, mode.splitDirection.xyz, 10.0);

    uint childToChildConnectionIndex = getNewAdhesionIndex();
    if (childToChildConnectionIndex == uint(-1)) return;

    // Create child-to-child adhesion connection with properly classified zones
    connections[childToChildConnectionIndex] = AdhesionConnection(
        childAIndex,
        childBIndex,
        cell.modeIndex,
        1, // isActive
        childZoneA, // zoneA: Properly classified based on bond direction
        childZoneB, // zoneB: Properly classified based on bond direction
        anchorDirectionA,
        0.0, // paddingA
        anchorDirectionB,
        0.0, // paddingB
        outputCells[childAIndex].orientation,
        outputCells[childBIndex].orientation,
        uint[4](0u, 0u, 0u, 0u) // padding to ensure 16-byte alignment
    );

    // Assign to cell adhesion slots (find available slots)
    int slotA = -1, slotB = -1;
    for (int j = 0; j < 20; ++j) {
        if (outputCells[childAIndex].adhesionIndices[j] < 0 && slotA == -1) slotA = j;
        if (outputCells[childBIndex].adhesionIndices[j] < 0 && slotB == -1) slotB = j;
        if (slotA != -1 && slotB != -1) break;
    }

    if (slotA != -1 && slotB != -1) {
        outputCells[childAIndex].adhesionIndices[slotA] = int(childToChildConnectionIndex);
        outputCells[childBIndex].adhesionIndices[slotB] = int(childToChildConnectionIndex);

        // Log diagnostic entry for child-to-child adhesion
        logAdhesionDiagnostic(
            childToChildConnectionIndex, getLineageIdFromIndex(childAIndex), getLineageIdFromIndex(childBIndex), cell.modeIndex,
            3, // reasonCode: ChildToChild
            anchorDirectionA, anchorDirectionB,
            uint(u_currentFrame), 1u, // frameIndex, splitEventID (1 for split event)
            getLineageIdFromIndex(index), 3u, 0u, float(childZoneA) // original parentCellID, inheritanceType (3=child_to_child), originalConnectionIndex=0, adhesionZone (actual zone)
        );
    }
}