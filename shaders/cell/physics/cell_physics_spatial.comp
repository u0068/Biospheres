#version 430 core

// Optimized work group size for better GPU utilization with 100k cells
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass;   // x, y, z, mass
    vec4 velocity;          // x, y, z, padding
    vec4 acceleration;      // x, y, z, padding
    vec4 prevAcceleration;  // x, y, z, padding
    vec4 orientation;       // Quaternion to (prevent gimbal lock)
    vec4 angularVelocity;   // Pseudo-vector for easy math
    vec4 angularAcceleration;       // Pseudo-vector for easy math
    vec4 prevAngularAcceleration;   // Pseudo-vector for easy math
    // Internal:
    vec4 signallingSubstances; // 4 substances for now
    int modeIndex;  // absolute index of the cell's mode
    float age; // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
    
    // Lineage tracking (AA.BB.C format)
    uint parentLineageId;       // AA: Parent's unique ID (0 for root cells)
    uint uniqueId;              // BB: This cell's unique ID
    uint childNumber;           // C: Child number (1 or 2, 0 for root cells)
    uint _lineagePadding;       // Padding to maintain 16-byte alignment
};

struct GPUModeAdhesionSettings
{
    int canBreak;                 // bool -> int (4 bytes)
    float breakForce;
    float restLength;
    float linearSpringStiffness;
    float linearSpringDamping;
    float orientationSpringStiffness;
    float orientationSpringDamping;
    float maxAngularDeviation;
    float twistConstraintStiffness;
    float twistConstraintDamping;
    int enableTwistConstraint;    // bool -> int (4 bytes)
    int _padding;                 // pad to 48 bytes
};

// GPU Mode structure
struct GPUMode {
    vec4 color;
    vec4 orientationA;
    vec4 orientationB;
    vec4 splitDirection;
    ivec2 childModes;
    float splitInterval;
    int genomeOffset;
    GPUModeAdhesionSettings adhesionSettings;
    int parentMakeAdhesion;
    int childAKeepAdhesion;
    int childBKeepAdhesion;
    int maxAdhesions;
    float flagellocyteSwimSpeed;
    float flagellocyteNutrientConsumption;
    float nutrientPriority;
    int cellType;
    float splitMass;
    float _padding;
    int _padding2;
    int _padding3;
};

// Shader storage buffer objects
layout(std430, binding = 0) restrict buffer CellInputBuffer {
    ComputeCell inputCells[];  // Previous frame cell data (read-only)
};

layout(std430, binding = 1) restrict buffer GridBuffer {
    uint gridCells[];  // Stores cell indices for each grid cell
};

layout(std430, binding = 2) restrict buffer GridCountBuffer {
    uint gridCounts[];
};

layout(std430, binding = 3) restrict buffer CellOutputBuffer {
    ComputeCell outputCells[];  // Current frame cell data (write-only)
};

layout(std430, binding = 4) coherent buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    uint freeAdhesionTop;
};

layout(std430, binding = 5) restrict readonly buffer ModeBuffer {
    GPUMode modes[];
};

// Uniforms
uniform int u_draggedCellIndex; // Index of cell being dragged (-1 if none)
uniform float u_accelerationDamping; // Damping factor for small accelerations
uniform int u_gridResolution;
uniform float u_gridCellSize;
uniform float u_worldSize;
uniform int u_maxCellsPerGrid;
uniform int u_enableThrustForce = 1; // Enable/disable flagellocyte thrust force (0=disabled, 1=enabled)
uniform float u_rollingFriction = 0.3; // Rolling friction coefficient (0=no friction, 1=high friction)
uniform vec3 u_gravity = vec3(0.0, 0.0, 0.0); // Global gravity acceleration (units/s²)

// Function to convert world position to grid coordinates
ivec3 worldToGrid(vec3 worldPos) {
    // Clamp to world bounds first
    vec3 clampedPos = clamp(worldPos, vec3(-u_worldSize * 0.5), vec3(u_worldSize * 0.5));
    
    // Convert to grid coordinates [0, gridResolution)
    vec3 normalizedPos = (clampedPos + u_worldSize * 0.5) / u_worldSize;
    ivec3 gridPos = ivec3(normalizedPos * u_gridResolution);
    
    // Ensure we stay within bounds
    return clamp(gridPos, ivec3(0), ivec3(u_gridResolution - 1));
}

// Function to convert 3D grid coordinates to 1D index
uint gridToIndex(ivec3 gridPos) {
    return uint(gridPos.x + gridPos.y * u_gridResolution + gridPos.z * u_gridResolution * u_gridResolution);
}

// Function to check if grid coordinates are valid
bool isValidGridPos(ivec3 gridPos) {
    return gridPos.x >= 0 && gridPos.x < u_gridResolution &&
           gridPos.y >= 0 && gridPos.y < u_gridResolution &&
           gridPos.z >= 0 && gridPos.z < u_gridResolution;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
      // Check bounds
    if (index >= totalCellCount) {
        return;
    }
      // Skip physics for dragged cell - it will be positioned directly
    if (int(index) == u_draggedCellIndex) {
        // Copy input to output but clear velocity and acceleration for dragged cell
        outputCells[index] = inputCells[index];
        outputCells[index].velocity.xyz = vec3(0.0);
        outputCells[index].acceleration = vec4(0.0);
        outputCells[index].angularAcceleration = vec4(0.0);
        return;
    }    
    // Copy input cell data to output and reset accelerations
    outputCells[index] = inputCells[index];
    outputCells[index].acceleration = vec4(0.0);
    outputCells[index].angularAcceleration = vec4(0.0);
    
    // Calculate forces from nearby cells using spatial partitioning
    vec3 totalForce = vec3(0.0);
    vec3 totalTorque = vec3(0.0);
    vec3 myPos = inputCells[index].positionAndMass.xyz;
    float myMass = inputCells[index].positionAndMass.w;
    float myRadius = pow(myMass, 1./3.);
    vec3 myVelocity = inputCells[index].velocity.xyz;
    vec3 myAngularVelocity = inputCells[index].angularVelocity.xyz;
    
    // Get the grid cell this cell belongs to
    ivec3 myGridPos = worldToGrid(myPos);
    
    // OPTIMIZED: Reduced neighbor search - only check necessary neighbors
    // Use smaller search radius based on typical cell sizes
    int searchRadius = 1; // Can be reduced to 0 for very dense grids
    
    // Check neighboring grid cells with early termination
    for (int dx = -searchRadius; dx <= searchRadius; dx++) {
        for (int dy = -searchRadius; dy <= searchRadius; dy++) {
            for (int dz = -searchRadius; dz <= searchRadius; dz++) {
                ivec3 neighborGridPos = myGridPos + ivec3(dx, dy, dz);
                
                // Skip if neighbor is outside grid bounds
                if (!isValidGridPos(neighborGridPos)) {
                    continue;
                }
                
                uint neighborGridIndex = gridToIndex(neighborGridPos);
                uint localCellCount = gridCounts[neighborGridIndex];
                
                // OPTIMIZED: Early exit if no cells in this grid
                if (localCellCount == 0) {
                    continue;
                }
                
                // OPTIMIZED: Limit search to reasonable number of cells
                uint maxCellsToCheck = min(localCellCount, uint(u_maxCellsPerGrid));
                
                // Check all cells in this neighboring grid cell
                for (uint i = 0; i < maxCellsToCheck; i++) {
                    uint gridBufferIndex = neighborGridIndex * u_maxCellsPerGrid + i;
                    uint otherIndex = gridCells[gridBufferIndex];
                    
                    // Skip self and invalid indices
                    if (otherIndex == index || otherIndex >= totalCellCount) {
                        continue;
                    }
                    
                    vec3 otherPos = inputCells[otherIndex].positionAndMass.xyz;
                    vec3 delta = myPos - otherPos;
                    float distance = length(delta);
                    
                    // OPTIMIZED: Early distance check before radius calculation
                    if (distance > 4.0) { // Approximate max interaction distance
                        continue;
                    }
                    
                    float otherRadius = pow(inputCells[otherIndex].positionAndMass.w, 1./3.);
                    float minDistance = myRadius + otherRadius;
                    
                    if (distance < minDistance && distance > 0.001) {
                        // Collision detected - apply repulsion force
                        vec3 direction = normalize(delta);
                        float overlap = minDistance - distance;
                        float hardness = 10.0;
                        totalForce += direction * overlap * hardness;
                        
                        // === GEAR-LIKE MESHING CONTACT MECHANICS ===
                        // Calculate contact point (on surface of this cell)
                        vec3 contactPoint = myPos - direction * myRadius;
                        vec3 contactOffset = contactPoint - myPos;
                        
                        // Get other cell's velocity and angular velocity
                        vec3 otherVelocity = inputCells[otherIndex].velocity.xyz;
                        vec3 otherAngularVelocity = inputCells[otherIndex].angularVelocity.xyz;
                        
                        // Calculate velocity at contact point for both cells
                        // v_contact = v_linear + ω × r
                        vec3 myContactVelocity = myVelocity + cross(myAngularVelocity, contactOffset);
                        vec3 otherContactOffset = contactPoint - otherPos;
                        vec3 otherContactVelocity = otherVelocity + cross(otherAngularVelocity, otherContactOffset);
                        
                        // Relative velocity at contact point
                        vec3 relativeVelocity = myContactVelocity - otherContactVelocity;
                        
                        // Decompose into normal and tangential components
                        vec3 normalVelocity = dot(relativeVelocity, direction) * direction;
                        vec3 tangentialVelocity = relativeVelocity - normalVelocity;
                        
                        // Calculate normal force (used for both friction types)
                        float normalForce = hardness * overlap;
                        
                        // GEAR MESHING: Surfaces should have zero relative tangential velocity
                        // Apply strong constraint force to eliminate sliding
                        float tangentialSpeed = length(tangentialVelocity);
                        if (tangentialSpeed > 0.001) {
                            vec3 frictionDirection = -normalize(tangentialVelocity);
                            
                            // Use high friction multiplier to simulate gear teeth engagement
                            float gearFriction = u_rollingFriction * 3.0; // 3x stronger for gear-like behavior
                            vec3 frictionForce = frictionDirection * normalForce * gearFriction;
                            
                            // Apply friction force to linear motion
                            totalForce += frictionForce;
                            
                            // Calculate torque from friction: τ = r × F
                            // This causes cells to rotate like meshing gears
                            vec3 torque = cross(contactOffset, frictionForce);
                            totalTorque += torque;
                        }
                        
                        // ADDITIONAL GEAR COUPLING: Direct angular velocity coupling
                        // For perfect gear meshing, angular velocities should be related by radius ratio
                        // ω1 * r1 = -ω2 * r2 (opposite rotation directions)
                        vec3 relativeAngularVel = myAngularVelocity - otherAngularVelocity;
                        float angularMismatch = length(relativeAngularVel);
                        
                        if (angularMismatch > 0.001) {
                            // Apply torque to synchronize rotation like gears
                            // The torque should be proportional to the angular velocity mismatch
                            float couplingStrength = normalForce * u_rollingFriction * 0.5;
                            vec3 couplingTorque = -relativeAngularVel * couplingStrength;
                            totalTorque += couplingTorque;
                        }
                    }
                }
            }
        }
    }
    
    // Calculate acceleration (F = ma, so a = F/m)
    vec3 acceleration = totalForce / myMass;
    
    // Add global gravity
    acceleration += u_gravity;
    
    // Add flagellocyte thrust force (continuous forward movement)
    // Force is proportional to swim speed and inversely proportional to total mass being pushed
    if (u_enableThrustForce != 0) {
        int modeIndex = inputCells[index].modeIndex;
        if (modeIndex >= 0 && modeIndex < modes.length()) {
            float swimSpeed = modes[modeIndex].flagellocyteSwimSpeed;
            if (swimSpeed > 0.0) {
                // Base thrust force (can be adjusted)
                const float BASE_THRUST = 5.0;
                
                // Calculate effective thrust based on swim speed
                float thrustForce = BASE_THRUST * swimSpeed;
                
                // Apply thrust in the forward direction (negative Z in local space)
                vec4 orientation = inputCells[index].orientation;
                // Convert quaternion to forward direction
                vec3 forward = vec3(
                    2.0 * (orientation.x * orientation.z + orientation.w * orientation.y),
                    2.0 * (orientation.y * orientation.z - orientation.w * orientation.x),
                    1.0 - 2.0 * (orientation.x * orientation.x + orientation.y * orientation.y)
                );
                
                // Thrust is divided by mass - heavier cells (or structures) move slower
                // Multiple flagellocytes can cooperate by each contributing thrust
                acceleration += forward * thrustForce / myMass;
            }
        }
    }
    
    float accMagnitude = length(acceleration);
    
    // Multi-tier acceleration damping to prevent drift
    if (accMagnitude < 0.001) {
        // Eliminate extremely tiny forces entirely
        acceleration = vec3(0.0);
    } else if (accMagnitude < 0.01) {
        // Very aggressive damping for very small forces
        acceleration *= 0.1;
    } else if (accMagnitude < 0.05) {
        // Strong damping for small forces
        acceleration *= u_accelerationDamping;
    }
    
    // Store acceleration in output buffer
    outputCells[index].acceleration.xyz = acceleration;
    
    // Calculate angular acceleration from torque: α = τ / I
    // For a sphere: I = (2/5) * m * r^2
    float momentOfInertia = 0.4 * myMass * myRadius * myRadius;
    vec3 angularAcceleration = totalTorque / momentOfInertia;
    
    // Apply damping to angular acceleration to prevent drift
    float angularAccMagnitude = length(angularAcceleration);
    if (angularAccMagnitude < 0.001) {
        angularAcceleration = vec3(0.0);
    } else if (angularAccMagnitude < 0.01) {
        angularAcceleration *= 0.1;
    } else if (angularAccMagnitude < 0.05) {
        angularAcceleration *= u_accelerationDamping;
    }
    
    // Store angular acceleration in output buffer
    outputCells[index].angularAcceleration.xyz = angularAcceleration;
}

