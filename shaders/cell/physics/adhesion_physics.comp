#version 430 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct AdhesionSettings
{
    bool canBreak;
    float breakForce;
    float restLength;
    float linearSpringStiffness;
    float linearSpringDamping;
    float orientationSpringStiffness;
    float orientationSpringDamping;
    float maxAngularDeviation; // degrees
};

// GPU Mode structure
struct GPUMode {
    vec4 color;           // R, G, B, padding
    vec4 orientationA;    // quaternion
    vec4 orientationB;    // quaternion
    vec4 splitDirection;  // x, y, z, padding
    ivec2 childModes;     // mode indices for children
    float splitInterval;
    int genomeOffset;
    AdhesionSettings adhesionSettings;
    int parentMakeAdhesion; // Boolean flag for adhesion creation
    int childAKeepAdhesion; // Boolean flag for child A to keep adhesion
    int childBKeepAdhesion; // Boolean flag for child B to keep adhesion
    int maxAdhesions;       // Max number of adhesions
};

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass; // x, y, z, mass
    vec4 velocity;        // Fixed to match CPU layout
    vec4 acceleration;    // Fixed to match CPU layout
    vec4 orientation;     // angular stuff in quaternion to prevent gimbal lock
    vec4 angularVelocity;
    vec4 angularAcceleration;
    // Internal:
    vec4 signallingSubstances; // 4 substances for now
    int modeIndex;  // absolute index of the cell's mode
    float age; // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
};

// Adhesion connection structure - stores permanent connections between sibling cells
struct AdhesionConnection {
    uint cellAIndex;      // Index of first cell in the connection
    uint cellBIndex;      // Index of second cell in the connection
    uint modeIndex;       // Mode index for the connection ( to lookup adhesion settings )
    uint isActive;        // Whether this connection is still active (1 = active, 0 = inactive)
};

// Input Cell data
layout(std430, binding = 0) restrict buffer ReadCellBuffer {
    ComputeCell inputCells[];
};

// Input: Mode data
layout(std430, binding = 1) buffer ModeBuffer {
    GPUMode modes[];
};

layout(std430, binding = 2) buffer AdhesionConnectionBuffer {
    AdhesionConnection connections[];
};

// Cell count
layout(std430, binding = 3) buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    uint freeAdhesionTop;
};

// Output Cell data
layout(std430, binding = 4) restrict buffer WriteCellBuffer {
    ComputeCell outputCells[];
};

// Uniforms
uniform float u_deltaTime;

float getRadius(ComputeCell cell) {
    float mass = cell.positionAndMass.w; // mass is stored in w component 
    return pow(mass, 1./3.);
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    if (index >= totalCellCount) {
        return;
    }

    ComputeCell cell = inputCells[index];

    // Apply a spring force for each adhesion connection
    for (int i = 0; i < 20; ++i) {
        int adhesionIndex = cell.adhesionIndices[i];
        if (adhesionIndex < 0) continue; // No adhesion connection
        AdhesionConnection connection = connections[adhesionIndex];
        if (connection.isActive == 0) continue; // Inactive connection
        uint otherIndex = (connection.cellAIndex == index) ? connection.cellBIndex : connection.cellAIndex;
        ComputeCell otherCell = inputCells[otherIndex];
        // Calculate the vector between the two cells
        vec3 deltaPosition = otherCell.positionAndMass.xyz - cell.positionAndMass.xyz;
        float springLength = length(deltaPosition);
        if (springLength < 0.0001) continue; // Prevent division by zero
        
        // Calculate the spring force
        AdhesionSettings settings = modes[connection.modeIndex].adhesionSettings;
        
        vec3 forceDirection = normalize(deltaPosition);
        float forceMagnitude = settings.linearSpringStiffness * (springLength - settings.restLength - getRadius(cell) - getRadius(otherCell));
        vec3 springForce = forceDirection * forceMagnitude;
        // Apply damping
        //vec3 relativeVelocity = otherCell.velocity.xyz - cell.velocity.xyz;
        //float dampingForceMagnitude = settings.linearSpringDamping * dot(relativeVelocity, forceDirection);
        //springForce -= forceDirection * dampingForceMagnitude;
        // Update accelerations
        cell.acceleration.xyz += springForce / cell.positionAndMass.w; // mass
        // dont update other cell to prevent double force application and race conditions
    }

    outputCells[index] = cell; // Write the updated cell back to output buffer
} 