#version 430 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct GPUModeAdhesionSettings
{
    int canBreak;                 // bool -> int (4 bytes)
    float breakForce;
    float restLength;
    float linearSpringStiffness;
    float linearSpringDamping;
    float orientationSpringStiffness;
    float orientationSpringDamping;
    float maxAngularDeviation;
    float twistConstraintStiffness;
    float twistConstraintDamping;
    int enableTwistConstraint;    // bool -> int (4 bytes)
    int _padding;                 // pad to 48 bytes
};

// GPU Mode structure
struct GPUMode {
    vec4 color;
    vec4 orientationA;
    vec4 orientationB;
    vec4 splitDirection;
    ivec2 childModes;
    float splitInterval;
    int genomeOffset;
    GPUModeAdhesionSettings adhesionSettings;
    int parentMakeAdhesion;
    int childAKeepAdhesion;
    int childBKeepAdhesion;
    int maxAdhesions;
    float flagellocyteSwimSpeed;
    float flagellocyteNutrientConsumption;
    float nutrientPriority;
    int cellType;
    float splitMass;
    float _padding;
    int _padding2;
    int _padding3;
};

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass;   // x, y, z, mass
    vec4 velocity;          // x, y, z, padding
    vec4 acceleration;      // x, y, z, padding
    vec4 prevAcceleration;  // x, y, z, padding
    vec4 orientation;       // Quaternion to (prevent gimbal lock)
    vec4 angularVelocity;   // Pseudo-vector for easy math
    vec4 angularAcceleration;       // Pseudo-vector for easy math
    vec4 prevAngularAcceleration;   // Pseudo-vector for easy math
    // Internal:
    vec4 signallingSubstances; // 4 substances for now
    int modeIndex;  // absolute index of the cell's mode
    float age; // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
    
    // Lineage tracking (AA.BB.C format)
    uint parentLineageId;       // AA: Parent's unique ID (0 for root cells)
    uint uniqueId;              // BB: This cell's unique ID
    uint childNumber;           // C: Child number (1 or 2, 0 for root cells)
    uint _lineagePadding;       // Padding to maintain 16-byte alignment
};

// Adhesion connection structure - stores permanent connections between sibling cells
struct AdhesionConnection {
    uint cellAIndex;      // Index of first cell in the connection
    uint cellBIndex;      // Index of second cell in the connection
    uint modeIndex;       // Mode index for the connection ( to lookup adhesion settings )
    uint isActive;        // Whether this connection is still active (1 = active, 0 = inactive)
    uint zoneA;           // Zone classification for cell A (0=ZoneA, 1=ZoneB, 2=ZoneC)
    uint zoneB;           // Zone classification for cell B (0=ZoneA, 1=ZoneB, 2=ZoneC)
    vec3 anchorDirectionA; // Anchor direction for cell A in local cell space (normalized)
    float paddingA;       // Padding to ensure 16-byte alignment
    vec3 anchorDirectionB; // Anchor direction for cell B in local cell space (normalized)
    float paddingB;       // Padding to ensure 16-byte alignment
    vec4 twistReferenceA; // Reference quaternion for twist constraint for cell A (16 bytes)
    vec4 twistReferenceB; // Reference quaternion for twist constraint for cell B (16 bytes)
    uint _padding[2];     // Padding to ensure 16-byte alignment (96 bytes total)
};

// Input Cell data
layout(std430, binding = 0) restrict buffer ReadCellBuffer {
    ComputeCell inputCells[];
};

// Input: Mode data
layout(std430, binding = 1) buffer ModeBuffer {
    GPUMode modes[];
};

layout(std430, binding = 2) buffer AdhesionConnectionBuffer {
    AdhesionConnection connections[];
};

// Cell count
layout(std430, binding = 3) buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    uint freeAdhesionTop;
};

// Output Cell data
layout(std430, binding = 4) restrict buffer WriteCellBuffer {
    ComputeCell outputCells[];
};

// Uniforms
uniform float u_deltaTime;
uniform int u_draggedCellIndex; // Index of cell being dragged (-1 if none)

float getRadius(ComputeCell cell) {
    float mass = cell.positionAndMass.w; // mass is stored in w component 
    return pow(mass, 1./3.);
}

// Quaternion math functions for orientation locking
vec4 quatMultiply(vec4 q1, vec4 q2) {
    return vec4(
        q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y,
        q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x,
        q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w,
        q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z
    );
}

vec4 quatConjugate(vec4 q) {
    return vec4(-q.xyz, q.w);
}

vec4 quatInverse(vec4 q) {
    float norm = dot(q, q);
    if (norm > 0.0) {
        return quatConjugate(q) / norm;
    }
    return vec4(0.0, 0.0, 0.0, 1.0);
}

vec3 rotateVectorByQuaternion(vec3 v, vec4 q) {
    vec3 u = q.xyz;
    float s = q.w;
    return 2.0 * dot(u, v) * u + (s * s - dot(u, u)) * v + 2.0 * s * cross(u, v);
}

// Convert quaternion to axis-angle representation
vec4 quatToAxisAngle(vec4 q) {
    float angle = 2.0 * acos(clamp(q.w, -1.0, 1.0));
    vec3 axis;
    if (angle < 0.001) {
        axis = vec3(1.0, 0.0, 0.0);
    } else {
        axis = normalize(q.xyz / sin(angle * 0.5));
    }
    return vec4(axis, angle);
}

// Convert axis-angle to quaternion
vec4 axisAngleToQuat(vec4 axisAngle) {
    float halfAngle = axisAngle.w * 0.5;
    float s = sin(halfAngle);
    return vec4(axisAngle.xyz * s, cos(halfAngle));
}

// Deterministic quaternion rotation from one vector to another
// Uses a consistent method that avoids cross product ambiguity
vec4 quatFromTwoVectors(vec3 from, vec3 to) {
    // Normalize inputs
    vec3 v1 = normalize(from);
    vec3 v2 = normalize(to);
    
    float cosAngle = dot(v1, v2);
    
    // Vectors are already aligned
    if (cosAngle > 0.9999) {
        return vec4(0.0, 0.0, 0.0, 1.0); // Identity
    }
    
    // Vectors are opposite - use deterministic perpendicular axis
    if (cosAngle < -0.9999) {
        // Choose axis deterministically based on which component is smallest
        vec3 axis;
        if (abs(v1.x) < abs(v1.y) && abs(v1.x) < abs(v1.z)) {
            axis = normalize(vec3(0.0, -v1.z, v1.y));
        } else if (abs(v1.y) < abs(v1.z)) {
            axis = normalize(vec3(-v1.z, 0.0, v1.x));
        } else {
            axis = normalize(vec3(-v1.y, v1.x, 0.0));
        }
        return vec4(axis, 0.0); // 180 degree rotation
    }
    
    // General case: use half-way quaternion method (more stable than cross product)
    vec3 halfway = normalize(v1 + v2);
    vec3 axis = vec3(
        v1.y * halfway.z - v1.z * halfway.y,
        v1.z * halfway.x - v1.x * halfway.z,
        v1.x * halfway.y - v1.y * halfway.x
    );
    float w = dot(v1, halfway);
    
    return normalize(vec4(axis, w));
}

void computeAdhesionForces(
    ComputeCell A, ComputeCell B,
    GPUMode adhesionMode,
    AdhesionConnection connection,
    out vec3 forceA, out vec3 torqueA,
    out vec3 forceB, out vec3 torqueB
) {
    forceA = vec3(0.0); torqueA = vec3(0.0);
    forceB = vec3(0.0); torqueB = vec3(0.0);
    
    GPUModeAdhesionSettings settings = adhesionMode.adhesionSettings;
    
    // Connection vector from A to B
    vec3 deltaPos = B.positionAndMass.xyz - A.positionAndMass.xyz;
    float dist = length(deltaPos);
    if (dist < 0.0001) return;
    
    vec3 adhesionDir = deltaPos / dist;
    // Calculate rest length as the distance between cell surfaces (sum of radii) plus the settings offset
    float restLength = settings.restLength + getRadius(A) + getRadius(B);
    
    // Linear spring
    float forceMag = settings.linearSpringStiffness * (dist - restLength);
    vec3 springForce = adhesionDir * forceMag;

    // Damping - oppose relative motion
    vec3 relVel = B.velocity.xyz - A.velocity.xyz;
    float dampMag = 1. - settings.linearSpringDamping * dot(relVel, adhesionDir);
    vec3 dampingForce = -adhesionDir * dampMag; // Negative to oppose motion

    forceA += springForce + dampingForce;
    forceB -= springForce + dampingForce;
    
    // Use the fixed anchor directions from the connection, transformed to world space
    vec3 anchorA, anchorB;
    if (length(connection.anchorDirectionA) < 0.001 && length(connection.anchorDirectionB) < 0.001) {
        // Fallback: use default directions (this should not happen in genome-based system)
        // Use a default direction to avoid spatial dependencies
        anchorA = vec3(1.0, 0.0, 0.0);
        anchorB = vec3(-1.0, 0.0, 0.0);
    } else {
        // Transform the stored local anchor directions to world space using cell orientations
        anchorA = rotateVectorByQuaternion(connection.anchorDirectionA, A.orientation);
        anchorB = rotateVectorByQuaternion(connection.anchorDirectionB, B.orientation);
    }
    
    // Apply orientation spring and damping using the fixed anchor directions
    vec3 axisA = cross(anchorA, adhesionDir);
    float sinA = length(axisA);
    float cosA = dot(anchorA, adhesionDir);
    float angleA = atan(sinA, cosA);
    if (sinA > 0.0001) {
        axisA = normalize(axisA);
        // Orientation spring and damping
        vec3 springTorqueA = axisA * angleA * settings.orientationSpringStiffness;
        vec3 dampingTorqueA = -axisA * dot(A.angularVelocity.xyz, axisA) * settings.orientationSpringDamping;
        torqueA += springTorqueA + dampingTorqueA;
    }

    vec3 axisB = cross(anchorB, -adhesionDir);
    float sinB = length(axisB);
    float cosB = dot(anchorB, -adhesionDir);
    float angleB = atan(sinB, cosB);
    if (sinB > 0.0001) {
        axisB = normalize(axisB);
        // Orientation spring and damping
        vec3 springTorqueB = axisB * angleB * settings.orientationSpringStiffness;
        vec3 dampingTorqueB = -axisB * dot(B.angularVelocity.xyz, axisB) * settings.orientationSpringDamping;
        torqueB += springTorqueB + dampingTorqueB;
    }

    // Apply twist constraints if enabled
    if (settings.enableTwistConstraint != 0 && 
        length(connection.twistReferenceA) > 0.001 && 
        length(connection.twistReferenceB) > 0.001) {
        
        // Calculate adhesion axis (from A to B)
        vec3 adhesionAxis = normalize(deltaPos);
        
        // Calculate target orientations that maintain the original twist relationship
        // but allow the anchor alignment to work properly
        
        // Get the current anchor directions in world space
        vec3 currentAnchorA = rotateVectorByQuaternion(connection.anchorDirectionA, A.orientation);
        vec3 currentAnchorB = rotateVectorByQuaternion(connection.anchorDirectionB, B.orientation);
        
        // Calculate what the orientations should be if anchors were perfectly aligned
        vec3 targetAnchorA = adhesionAxis;
        vec3 targetAnchorB = -adhesionAxis;
        
        // Find the rotation needed to align current anchor to target anchor
        vec4 alignmentRotA = quatFromTwoVectors(currentAnchorA, targetAnchorA);
        vec4 alignmentRotB = quatFromTwoVectors(currentAnchorB, targetAnchorB);
        
        // Apply the alignment rotation to the reference orientations to get target orientations
        vec4 targetOrientationA = quatMultiply(alignmentRotA, connection.twistReferenceA);
        vec4 targetOrientationB = quatMultiply(alignmentRotB, connection.twistReferenceB);
        
        // Calculate the rotation needed to reach target orientations
        vec4 correctionRotA = quatMultiply(targetOrientationA, quatConjugate(A.orientation));
        vec4 correctionRotB = quatMultiply(targetOrientationB, quatConjugate(B.orientation));
        
        // Convert to axis-angle and apply as torque (but only around adhesion axis)
        vec4 axisAngleA = quatToAxisAngle(correctionRotA);
        vec4 axisAngleB = quatToAxisAngle(correctionRotB);
        
        // Project correction onto adhesion axis to get twist component only
        float twistCorrectionA = axisAngleA.w * dot(axisAngleA.xyz, adhesionAxis);
        float twistCorrectionB = axisAngleB.w * dot(axisAngleB.xyz, adhesionAxis);
        
        // Apply twist correction with higher strength for snake body alignment
        // Normalize the correction angles to prevent excessive torques
        twistCorrectionA = clamp(twistCorrectionA, -1.57, 1.57); // Limit to Â±90 degrees
        twistCorrectionB = clamp(twistCorrectionB, -1.57, 1.57);
        
        vec3 twistTorqueA = adhesionAxis * twistCorrectionA * settings.twistConstraintStiffness * 0.3;
        vec3 twistTorqueB = adhesionAxis * twistCorrectionB * settings.twistConstraintStiffness * 0.3;
        
        // Add strong damping to prevent oscillation and maintain stable snake body
        float angularVelA = dot(A.angularVelocity.xyz, adhesionAxis);
        float angularVelB = dot(B.angularVelocity.xyz, adhesionAxis);
        float relativeAngularVel = angularVelA - angularVelB;
        
        vec3 twistDampingA = -adhesionAxis * relativeAngularVel * settings.twistConstraintDamping * 0.4;
        vec3 twistDampingB = adhesionAxis * relativeAngularVel * settings.twistConstraintDamping * 0.4;
        
        torqueA += twistTorqueA + twistDampingA;
        torqueB += twistTorqueB + twistDampingB;
    }

    // Apply a tangential force from the torque
    forceA += cross(-deltaPos, torqueB);
    forceB += cross(deltaPos, torqueA);

    // This conserves angular momentum but makes cells look less natural, maybe better to comment it out
    torqueA -= torqueB;
    torqueB -= torqueA;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    if (index >= totalCellCount) {
        return;
    }

    ComputeCell thisCell = inputCells[index];
    
    bool isDraggedCell = (int(index) == u_draggedCellIndex);
    
    if (isDraggedCell) {
        // Copy input to output but clear acceleration for dragged cell
        thisCell.acceleration = vec4(0.0);
        thisCell.angularAcceleration = vec4(0.0);
        outputCells[index] = thisCell;
        return;
    }

    // Apply forces for each adhesion connection
    for (int i = 0; i < 20; ++i) {
        int adhesionIndex = thisCell.adhesionIndices[i];
        if (adhesionIndex < 0) continue; // No adhesion connection
        AdhesionConnection connection = connections[adhesionIndex];
        if (connection.isActive == 0) continue; // Inactive connection
        bool isCellA = (connection.cellAIndex == index);
        uint otherIndex        = isCellA ? connection.cellBIndex : connection.cellAIndex;
        ComputeCell otherCell  = inputCells[otherIndex];
        
        ComputeCell cellA = isCellA ? thisCell : otherCell;
        ComputeCell cellB = isCellA ? otherCell : thisCell;

        //GPUMode thisMode      = modes[thisCell.modeIndex];
        //GPUMode otherMode     = modes[otherCell.modeIndex];

        GPUMode adhesionMode = modes[connection.modeIndex];

        vec3 fA, tA, fB, tB;
        computeAdhesionForces(cellA, cellB, adhesionMode, connection, fA, tA, fB, tB);
        
        // Torque needs to be divided by moment of inertia (for sphere: 2/5 * m * r^2)
        float radius = getRadius(thisCell);
        float momentOfInertia = 0.4 * thisCell.positionAndMass.w * radius * radius;

        if (isCellA) {
            thisCell.acceleration.xyz += fA / thisCell.positionAndMass.w;
            thisCell.angularAcceleration.xyz += tA / momentOfInertia;
        } else {
            thisCell.acceleration.xyz += fB / thisCell.positionAndMass.w;
            thisCell.angularAcceleration.xyz += tB / momentOfInertia;
        }
    }

    // Write the updated cell back to output buffer
    outputCells[index] = thisCell;
} 
