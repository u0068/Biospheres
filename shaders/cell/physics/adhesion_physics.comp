#version 430 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct GPUModeAdhesionSettings
{
    int canBreak;                 // bool -> int (4 bytes)
    float breakForce;
    float restLength;
    float linearSpringStiffness;
    float linearSpringDamping;
    float orientationSpringStiffness;
    float orientationSpringDamping;
    float maxAngularDeviation;
    float twistConstraintStiffness;
    float twistConstraintDamping;
    int enableTwistConstraint;    // bool -> int (4 bytes)
    int _padding;                 // pad to 48 bytes
};

// GPU Mode structure
struct GPUMode {
    vec4 color;           // R, G, B, padding
    vec4 orientationA;    // Quaternion
    vec4 orientationB;    // Quaternion
    vec4 splitDirection;  // x, y, z, padding
    ivec2 childModes;     // mode indices for children
    float splitInterval;
    int genomeOffset;
    GPUModeAdhesionSettings adhesionSettings;
    int parentMakeAdhesion; // Boolean flag for adhesion creation
    int childAKeepAdhesion; // Boolean flag for child A to keep adhesion
    int childBKeepAdhesion; // Boolean flag for child B to keep adhesion
    int maxAdhesions;       // Max number of adhesions
};

// Cell data structure for compute shader
struct ComputeCell {
    // Physics:
    vec4 positionAndMass;   // x, y, z, mass
    vec4 velocity;          // x, y, z, padding
    vec4 acceleration;      // x, y, z, padding
    vec4 prevAcceleration;  // x, y, z, padding
    vec4 orientation;       // Quaternion to (prevent gimbal lock)
    vec4 angularVelocity;   // Pseudo-vector for easy math
    vec4 angularAcceleration;       // Pseudo-vector for easy math
    vec4 prevAngularAcceleration;   // Pseudo-vector for easy math
    // Internal:
    vec4 signallingSubstances; // 4 substances for now
    int modeIndex;  // absolute index of the cell's mode
    float age; // also used for split timer
    float toxins;
    float nitrates;
    int adhesionIndices[20];
};

// Adhesion connection structure - stores permanent connections between sibling cells
struct AdhesionConnection {
    uint cellAIndex;      // Index of first cell in the connection
    uint cellBIndex;      // Index of second cell in the connection
    uint modeIndex;       // Mode index for the connection ( to lookup adhesion settings )
    uint isActive;        // Whether this connection is still active (1 = active, 0 = inactive)
    vec3 anchorDirectionA; // Anchor direction for cell A in local cell space (normalized)
    float paddingA;       // Padding to ensure 16-byte alignment
    vec3 anchorDirectionB; // Anchor direction for cell B in local cell space (normalized)
    float paddingB;       // Padding to ensure 16-byte alignment
    vec4 twistReferenceA; // Reference quaternion for twist constraint for cell A (16 bytes)
    vec4 twistReferenceB; // Reference quaternion for twist constraint for cell B (16 bytes)
};

// Input Cell data
layout(std430, binding = 0) restrict buffer ReadCellBuffer {
    ComputeCell inputCells[];
};

// Input: Mode data
layout(std430, binding = 1) buffer ModeBuffer {
    GPUMode modes[];
};

layout(std430, binding = 2) buffer AdhesionConnectionBuffer {
    AdhesionConnection connections[];
};

// Cell count
layout(std430, binding = 3) buffer CellCountBuffer {
    uint totalCellCount;
    uint liveCellCount;
    uint totalAdhesionCount;
    uint freeAdhesionTop;
};

// Output Cell data
layout(std430, binding = 4) restrict buffer WriteCellBuffer {
    ComputeCell outputCells[];
};

// Uniforms
uniform float u_deltaTime;
uniform int u_draggedCellIndex; // Index of cell being dragged (-1 if none)

float getRadius(ComputeCell cell) {
    float mass = cell.positionAndMass.w; // mass is stored in w component 
    return pow(mass, 1./3.);
}

// Quaternion math functions for orientation locking
vec4 quatMultiply(vec4 q1, vec4 q2) {
    return vec4(
        q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y,
        q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x,
        q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w,
        q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z
    );
}

vec4 quatConjugate(vec4 q) {
    return vec4(-q.xyz, q.w);
}

vec4 quatInverse(vec4 q) {
    float norm = dot(q, q);
    if (norm > 0.0) {
        return quatConjugate(q) / norm;
    }
    return vec4(0.0, 0.0, 0.0, 1.0);
}

vec3 rotateVectorByQuaternion(vec3 v, vec4 q) {
    vec3 u = q.xyz;
    float s = q.w;
    return 2.0 * dot(u, v) * u + (s * s - dot(u, u)) * v + 2.0 * s * cross(u, v);
}

// Convert quaternion to axis-angle representation
vec4 quatToAxisAngle(vec4 q) {
    float angle = 2.0 * acos(clamp(q.w, -1.0, 1.0));
    vec3 axis;
    if (angle < 0.001) {
        axis = vec3(1.0, 0.0, 0.0);
    } else {
        axis = normalize(q.xyz / sin(angle * 0.5));
    }
    return vec4(axis, angle);
}

// Convert axis-angle to quaternion
vec4 axisAngleToQuat(vec4 axisAngle) {
    float halfAngle = axisAngle.w * 0.5;
    float s = sin(halfAngle);
    return vec4(axisAngle.xyz * s, cos(halfAngle));
}

// Create quaternion that rotates from vector a to vector b
vec4 quatFromTwoVectors(vec3 a, vec3 b) {
    vec3 normA = normalize(a);
    vec3 normB = normalize(b);
    
    float dot_product = dot(normA, normB);
    
    // If vectors are nearly identical, return identity quaternion
    if (dot_product > 0.9999) {
        return vec4(0.0, 0.0, 0.0, 1.0);
    }
    
    // If vectors are nearly opposite, find a perpendicular axis
    if (dot_product < -0.9999) {
        vec3 axis = cross(vec3(1.0, 0.0, 0.0), normA);
        if (length(axis) < 0.01) {
            axis = cross(vec3(0.0, 1.0, 0.0), normA);
        }
        axis = normalize(axis);
        return vec4(axis, 0.0); // 180 degree rotation
    }
    
    // General case
    vec3 axis = cross(normA, normB);
    float w = sqrt((1.0 + dot_product) * 2.0);
    float inv_w = 1.0 / w;
    
    return normalize(vec4(axis * inv_w, w * 0.5));
}

void computeAdhesionForces(
    ComputeCell A, ComputeCell B,
    GPUMode adhesionMode,
    AdhesionConnection connection,
    out vec3 forceA, out vec3 torqueA,
    out vec3 forceB, out vec3 torqueB
) {
    forceA = vec3(0.0); torqueA = vec3(0.0);
    forceB = vec3(0.0); torqueB = vec3(0.0);
    
    GPUModeAdhesionSettings settings = adhesionMode.adhesionSettings;
    
    // Connection vector from A to B
    vec3 deltaPos = B.positionAndMass.xyz - A.positionAndMass.xyz;
    float dist = length(deltaPos);
    if (dist < 0.0001) return;
    
    vec3 adhesionDir = deltaPos / dist;
    float restLength = settings.restLength;// + getRadius(A) + getRadius(B);
    
    // Linear spring
    float forceMag = settings.linearSpringStiffness * (dist - restLength);
    vec3 springForce = adhesionDir * forceMag;

    // Damping - oppose relative motion
    vec3 relVel = B.velocity.xyz - A.velocity.xyz;
    float dampMag = 1. - settings.linearSpringDamping * dot(relVel, adhesionDir);
    vec3 dampingForce = -adhesionDir * dampMag; // Negative to oppose motion

    forceA += springForce + dampingForce;
    forceB -= springForce + dampingForce;
    
    // Use the fixed anchor directions from the connection, transformed to world space
    vec3 anchorA, anchorB;
    if (length(connection.anchorDirectionA) < 0.001 && length(connection.anchorDirectionB) < 0.001) {
        // Fallback: use default directions (this should not happen in genome-based system)
        // Use a default direction to avoid spatial dependencies
        anchorA = vec3(1.0, 0.0, 0.0);
        anchorB = vec3(-1.0, 0.0, 0.0);
    } else {
        // Transform the stored local anchor directions to world space using cell orientations
        anchorA = rotateVectorByQuaternion(connection.anchorDirectionA, A.orientation);
        anchorB = rotateVectorByQuaternion(connection.anchorDirectionB, B.orientation);
    }
    
    // Apply orientation spring and damping using the fixed anchor directions
    vec3 axisA = cross(anchorA, adhesionDir);
    float sinA = length(axisA);
    float cosA = dot(anchorA, adhesionDir);
    float angleA = atan(sinA, cosA);
    if (sinA > 0.0001) {
        axisA = normalize(axisA);
        // Orientation spring and damping
        vec3 springTorqueA = axisA * angleA * settings.orientationSpringStiffness;
        vec3 dampingTorqueA = -axisA * dot(A.angularVelocity.xyz, axisA) * settings.orientationSpringDamping;
        torqueA += springTorqueA + dampingTorqueA;
    }

    vec3 axisB = cross(anchorB, -adhesionDir);
    float sinB = length(axisB);
    float cosB = dot(anchorB, -adhesionDir);
    float angleB = atan(sinB, cosB);
    if (sinB > 0.0001) {
        axisB = normalize(axisB);
        // Orientation spring and damping
        vec3 springTorqueB = axisB * angleB * settings.orientationSpringStiffness;
        vec3 dampingTorqueB = -axisB * dot(B.angularVelocity.xyz, axisB) * settings.orientationSpringDamping;
        torqueB += springTorqueB + dampingTorqueB;
    }

    // Apply twist constraints if enabled
    if (settings.enableTwistConstraint != 0 && 
        length(connection.twistReferenceA) > 0.001 && 
        length(connection.twistReferenceB) > 0.001) {
        
        // Calculate adhesion axis (from A to B)
        vec3 adhesionAxis = normalize(deltaPos);
        
        // Calculate target orientations that maintain the original twist relationship
        // but allow the anchor alignment to work properly
        
        // Get the current anchor directions in world space
        vec3 currentAnchorA = rotateVectorByQuaternion(connection.anchorDirectionA, A.orientation);
        vec3 currentAnchorB = rotateVectorByQuaternion(connection.anchorDirectionB, B.orientation);
        
        // Calculate what the orientations should be if anchors were perfectly aligned
        vec3 targetAnchorA = adhesionAxis;
        vec3 targetAnchorB = -adhesionAxis;
        
        // Find the rotation needed to align current anchor to target anchor
        vec4 alignmentRotA = quatFromTwoVectors(currentAnchorA, targetAnchorA);
        vec4 alignmentRotB = quatFromTwoVectors(currentAnchorB, targetAnchorB);
        
        // Apply the alignment rotation to the reference orientations to get target orientations
        vec4 targetOrientationA = quatMultiply(alignmentRotA, connection.twistReferenceA);
        vec4 targetOrientationB = quatMultiply(alignmentRotB, connection.twistReferenceB);
        
        // Calculate the rotation needed to reach target orientations
        vec4 correctionRotA = quatMultiply(targetOrientationA, quatConjugate(A.orientation));
        vec4 correctionRotB = quatMultiply(targetOrientationB, quatConjugate(B.orientation));
        
        // Convert to axis-angle and apply as torque (but only around adhesion axis)
        vec4 axisAngleA = quatToAxisAngle(correctionRotA);
        vec4 axisAngleB = quatToAxisAngle(correctionRotB);
        
        // Project correction onto adhesion axis to get twist component only
        float twistCorrectionA = axisAngleA.w * dot(axisAngleA.xyz, adhesionAxis);
        float twistCorrectionB = axisAngleB.w * dot(axisAngleB.xyz, adhesionAxis);
        
        // Apply twist correction with higher strength for snake body alignment
        // Normalize the correction angles to prevent excessive torques
        twistCorrectionA = clamp(twistCorrectionA, -1.57, 1.57); // Limit to ±90 degrees
        twistCorrectionB = clamp(twistCorrectionB, -1.57, 1.57);
        
        vec3 twistTorqueA = adhesionAxis * twistCorrectionA * settings.twistConstraintStiffness * 0.3;
        vec3 twistTorqueB = adhesionAxis * twistCorrectionB * settings.twistConstraintStiffness * 0.3;
        
        // Add strong damping to prevent oscillation and maintain stable snake body
        float angularVelA = dot(A.angularVelocity.xyz, adhesionAxis);
        float angularVelB = dot(B.angularVelocity.xyz, adhesionAxis);
        float relativeAngularVel = angularVelA - angularVelB;
        
        vec3 twistDampingA = -adhesionAxis * relativeAngularVel * settings.twistConstraintDamping * 0.4;
        vec3 twistDampingB = adhesionAxis * relativeAngularVel * settings.twistConstraintDamping * 0.4;
        
        torqueA += twistTorqueA + twistDampingA;
        torqueB += twistTorqueB + twistDampingB;
    }

    // Apply tangential forces derived from torques in a zero-sum fashion for conservation
    vec3 tangentialForce = 0.5 * (cross(-deltaPos, torqueB) - cross(deltaPos, torqueA));
    forceA += tangentialForce;
    forceB -= tangentialForce;

    // Symmetrize torques to be equal-and-opposite (conserve angular momentum across the pair)
    vec3 pairTorque = 0.5 * (torqueA - torqueB);
    torqueA = pairTorque;
    torqueB = -pairTorque;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    if (index >= totalCellCount) {
        return;
    }

    ComputeCell thisCell = inputCells[index];
    
    bool isDraggedCell = (int(index) == u_draggedCellIndex);
    
    if (isDraggedCell) {
        // Copy input to output but clear acceleration for dragged cell
        thisCell.acceleration = vec4(0.0);
        thisCell.angularAcceleration = vec4(0.0);
        outputCells[index] = thisCell;
        return;
    }

    // Apply forces for each adhesion connection
    for (int i = 0; i < 20; ++i) {
        int adhesionIndex = thisCell.adhesionIndices[i];
        if (adhesionIndex < 0) continue; // No adhesion connection
        AdhesionConnection connection = connections[adhesionIndex];
        if (connection.isActive == 0) continue; // Inactive connection
        bool isCellA = (connection.cellAIndex == index);
        uint otherIndex        = isCellA ? connection.cellBIndex : connection.cellAIndex;
        ComputeCell otherCell  = inputCells[otherIndex];
        
        ComputeCell cellA = isCellA ? thisCell : otherCell;
        ComputeCell cellB = isCellA ? otherCell : thisCell;

        //GPUMode thisMode      = modes[thisCell.modeIndex];
        //GPUMode otherMode     = modes[otherCell.modeIndex];

        GPUMode adhesionMode = modes[connection.modeIndex];

        vec3 fA, tA, fB, tB;
        computeAdhesionForces(cellA, cellB, adhesionMode, connection, fA, tA, fB, tB);
        
        // Torque needs to be divided by moment of inertia (for sphere: 2/5 * m * r^2)
        float radius = getRadius(thisCell);
        float momentOfInertia = 0.4 * thisCell.positionAndMass.w * radius * radius;

        if (isCellA) {
            thisCell.acceleration.xyz += fA / thisCell.positionAndMass.w;
            thisCell.angularAcceleration.xyz += tA / momentOfInertia;
        } else {
            thisCell.acceleration.xyz += fB / thisCell.positionAndMass.w;
            thisCell.angularAcceleration.xyz += tB / momentOfInertia;
        }
        
        // ANTI-DRIFT: Apply immediate momentum correction for this connection
        // This ensures each adhesion connection doesn't contribute to net system momentum
        float connectionDamping = 0.1;
        thisCell.acceleration.xyz -= thisCell.velocity.xyz * connectionDamping;
    }

    // ANTI-DRIFT CORRECTION: Apply center-of-mass stabilization
    // This prevents the entire connected system from drifting by applying
    // forces that counteract any net momentum accumulation
    bool hasConnections = false;
    for (int i = 0; i < 20; ++i) {
        if (thisCell.adhesionIndices[i] >= 0) {
            hasConnections = true;
            break;
        }
    }
    
    if (hasConnections) {
        // Apply strong velocity damping to prevent drift accumulation
        float driftDamping = 0.5; // Much stronger damping for connected systems
        vec3 driftCorrectionForce = -thisCell.velocity.xyz * driftDamping;
        
        // Apply the correction force
        thisCell.acceleration.xyz += driftCorrectionForce;
        
        // Additional position-based correction to prevent center-of-mass drift
        // This applies a restoring force toward the origin for connected systems
        float comRestoreStrength = 0.1;
        vec3 comRestoreForce = -thisCell.positionAndMass.xyz * comRestoreStrength;
        thisCell.acceleration.xyz += comRestoreForce;
    }

    // Write the updated cell back to output buffer
    outputCells[index] = thisCell;
} 
