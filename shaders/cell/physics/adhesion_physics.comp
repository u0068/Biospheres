#version 430 core
#extension GL_ARB_gpu_shader_int64 : enable

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct ComputeCell {
    vec4 positionAndMass;
    vec4 velocity;
    vec4 acceleration;
    vec4 orientation;
    vec4 angularVelocity;
    vec4 angularAcceleration;
    vec4 signallingSubstances;
    int modeIndex;
    float age;
    float toxins;
    float nitrates;
    uint cellIndex;
    uint justSplit;
    uint padding2[2];
};

struct ComputeAdhesion {
    uint cellIndexA;
    uint cellIndexB;
    float breakForce;
    float restLength;
    float linearSpringStiffness;
    float linearSpringDamping;
    float orientationSpringStrength;
    float maxAngularDeviation;
    uint isActive;
    uint padding[3];
};

layout(std430, binding = 0) buffer CellBuffer {
    ComputeCell cells[];
};

layout(std430, binding = 1) buffer AdhesionBuffer {
    ComputeAdhesion adhesions[];
};

layout(std430, binding = 2) buffer AdhesionCountBuffer {
    uint adhesionCount;
};

uniform float u_deltaTime;
uniform int u_maxCells;

vec4 quatMultiply(vec4 q1, vec4 q2) {
    return vec4(
        q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y,
        q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x,
        q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w,
        q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z
    );
}

vec4 quatInverse(vec4 q) {
    return vec4(-q.xyz, q.w) / dot(q, q);
}

float quatAngle(vec4 q1, vec4 q2) {
    float dotProduct = abs(dot(q1, q2));
    return 2.0 * acos(clamp(dotProduct, 0.0, 1.0));
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= adhesionCount) return;

    ComputeAdhesion adhesion = adhesions[index];
    
    // Skip inactive adhesions
    if (adhesion.isActive == 0) return;
    
    // Get connected cells
    uint cellAIndex = adhesion.cellIndexA;
    uint cellBIndex = adhesion.cellIndexB;
    
    // Check bounds
    if (cellAIndex >= uint(u_maxCells) || cellBIndex >= uint(u_maxCells)) return;
    
    ComputeCell cellA = cells[cellAIndex];
    ComputeCell cellB = cells[cellBIndex];
    
    // Skip if either cell is dead (mass <= 0)
    if (cellA.positionAndMass.w <= 0.0 || cellB.positionAndMass.w <= 0.0) return;
    
    // Calculate distance and direction between cells
    vec3 posA = cellA.positionAndMass.xyz;
    vec3 posB = cellB.positionAndMass.xyz;
    vec3 direction = posB - posA;
    float distance = length(direction);
    
    if (distance < 0.001) return; // Avoid division by zero
    
    vec3 normalizedDirection = direction / distance;
    
    // Linear spring force
    float displacement = distance - adhesion.restLength;
    vec3 springForce = normalizedDirection * displacement * adhesion.linearSpringStiffness;
    
    // Damping force
    vec3 relativeVelocity = cellB.velocity.xyz - cellA.velocity.xyz;
    vec3 dampingForce = normalizedDirection * dot(relativeVelocity, normalizedDirection) * adhesion.linearSpringDamping;
    
    // Total linear force
    vec3 totalLinearForce = springForce - dampingForce;
    
    // Check if adhesion should break
    float forceMagnitude = length(totalLinearForce);
    if (forceMagnitude > adhesion.breakForce) {
        // Break the adhesion
        adhesion.isActive = 0;
        adhesions[index] = adhesion;
        return;
    }
    
    // Apply forces to cells (equal and opposite)
    vec3 forceA = totalLinearForce;
    vec3 forceB = -totalLinearForce;
    
    // Apply linear forces
    cellA.acceleration.xyz += forceA / cellA.positionAndMass.w;
    cellB.acceleration.xyz += forceB / cellB.positionAndMass.w;
    
    // Orientation spring force (if enabled)
    if (adhesion.orientationSpringStrength > 0.0) {
        vec4 qA = cellA.orientation;
        vec4 qB = cellB.orientation;
        
        // Calculate angular difference
        float angularDiff = quatAngle(qA, qB);
        
        if (angularDiff > adhesion.maxAngularDeviation) {
            // Calculate correction quaternion
            vec4 qDiff = quatMultiply(qB, quatInverse(qA));
            
            // Apply orientation correction force
            vec3 correctionAxis = normalize(qDiff.xyz);
            float correctionAngle = adhesion.orientationSpringStrength * u_deltaTime;
            
            vec4 correctionQuat = vec4(correctionAxis * sin(correctionAngle * 0.5), cos(correctionAngle * 0.5));
            
            // Apply correction to both cells
            cellA.orientation = normalize(quatMultiply(correctionQuat, cellA.orientation));
            cellB.orientation = normalize(quatMultiply(quatInverse(correctionQuat), cellB.orientation));
        }
    }
    
    // Write back updated cells
    cells[cellAIndex] = cellA;
    cells[cellBIndex] = cellB;
} 