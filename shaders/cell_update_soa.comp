#version 430

// Local work group size
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Structure of Arrays (SoA) approach for better memory access patterns
layout(std430, binding = 0) restrict buffer PositionBuffer {
    vec3 positions[];
};

layout(std430, binding = 1) restrict buffer RadiusBuffer {
    float radii[];
};

layout(std430, binding = 2) restrict buffer VelocityBuffer {
    vec3 velocities[];
};

layout(std430, binding = 3) restrict buffer MassBuffer {
    float masses[];
};

layout(std430, binding = 4) restrict buffer AccelerationBuffer {
    vec3 accelerations[];
};

// Uniforms
uniform float u_deltaTime;
uniform int u_cellCount;
uniform float u_damping;
uniform int u_draggedCellIndex; // Index of cell being dragged (-1 if none)

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    // Check bounds
    if (index >= u_cellCount) {
        return;
    }
    
    // Skip position updates for dragged cell - position is set directly by dragging
    if (int(index) == u_draggedCellIndex) {
        return;
    }
    
    // Update velocity based on acceleration
    velocities[index] += accelerations[index] * u_deltaTime;
    
    // Apply damping
    velocities[index] *= u_damping;
    
    // Update position based on velocity (Euler integration)
    positions[index] += velocities[index] * u_deltaTime;
    
    // Optional: Add boundary constraints here
    // For example, keep cells within a certain bounds
    vec3 pos = positions[index];
    float bounds = 50.0;
    
    if (length(pos) > bounds) {
        // Simple boundary reflection
        positions[index] = normalize(pos) * bounds;
        velocities[index] = -velocities[index] * 0.5; // Damped reflection
    }
}
