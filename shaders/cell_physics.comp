#version 430

// Local work group size
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Cell data structure for compute shader
struct ComputeCell {
    vec4 positionAndRadius;  // x, y, z, radius
    vec4 velocityAndMass;    // vx, vy, vz, mass
    vec4 acceleration;       // ax, ay, az, unused
};

// Shader storage buffer objects
layout(std430, binding = 0) restrict buffer CellBuffer {
    ComputeCell cells[];
};

// Uniforms
uniform float u_deltaTime;
uniform int u_cellCount;
uniform float u_damping;
uniform int u_draggedCellIndex; // Index of cell being dragged (-1 if none)

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    // Check bounds
    if (index >= u_cellCount) {
        return;
    }
    
    // Skip physics for dragged cell - it will be positioned directly
    if (int(index) == u_draggedCellIndex) {
        // Clear velocity and acceleration for dragged cell
        cells[index].velocityAndMass.xyz = vec3(0.0);
        cells[index].acceleration = vec4(0.0);
        return;
    }
    
    // Reset acceleration
    cells[index].acceleration = vec4(0.0);
    
    // Calculate forces from other cells (collision resolution)
    vec3 totalForce = vec3(0.0);
    vec3 myPos = cells[index].positionAndRadius.xyz;
    float myRadius = cells[index].positionAndRadius.w;
    float myMass = cells[index].velocityAndMass.w;
    
    for (uint j = 0; j < u_cellCount; ++j) {
        if (j == index) continue;
        
        vec3 otherPos = cells[j].positionAndRadius.xyz;
        float otherRadius = cells[j].positionAndRadius.w;
        
        vec3 delta = myPos - otherPos;
        float distance = length(delta);
        float minDistance = myRadius + otherRadius;
        
        if (distance < minDistance && distance > 0.001) {
            // Collision detected - apply repulsion force
            vec3 direction = normalize(delta);
            float overlap = minDistance - distance;
            totalForce += direction * overlap * 100.0; // Force strength
        }
    }
    
    // Store acceleration (F = ma, so a = F/m)
    cells[index].acceleration.xyz = totalForce / myMass;
}
